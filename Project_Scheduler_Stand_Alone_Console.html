<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise Project Scheduler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Banking/Enterprise Theme */
        :root {
            --primary-color: #1e3a8a; /* Deep blue */
            --secondary-color: #374151; /* Dark gray */
            --accent-color: #059669; /* Professional green */
            --warning-color: #d97706; /* Amber */
            --danger-color: #dc2626; /* Red */
            --background-color: #f8fafc; /* Light gray */
            --card-background: #ffffff;
            --border-color: #e5e7eb;
        }
        
        /* Custom styles for enterprise feel */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            color: var(--secondary-color);
        }
        
        .enterprise-container {
            max-width: 1600px;
        }
        
        .input-card, .output-card {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }
        
        .input-card:hover, .output-card:hover {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        }
        
        .enterprise-header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            border-bottom: 3px solid var(--accent-color);
        }
        
        /* Compact Enterprise Task Sizing */
        .task-size-manager {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .task-size-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .task-size-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .size-input-enhanced {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--secondary-color);
            font-weight: 600;
            text-align: center;
            width: 70px;
            font-size: 11px;
        }
        
        .size-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .size-label-enhanced {
            font-weight: bold;
            font-size: 12px;
            min-width: 50px;
        }
        
        .size-metrics {
            font-size: 10px;
            opacity: 0.9;
            margin-top: 3px;
        }
        
        .preset-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .custom-size-form {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
        }
        
        /* Enterprise Timeline Styles */
        .timeline-container {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
        }
        
        /* Custom scrollbar styles for timeline */
        .timeline-scroll-container {
            scrollbar-width: thin;
            scrollbar-color: #6b7280 #f3f4f6;
        }
        
        .timeline-scroll-container::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 6px;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-thumb {
            background: #6b7280;
            border-radius: 6px;
            border: 2px solid #f3f4f6;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-corner {
            background: #f3f4f6;
        }
        
        /* Modal Styles for Banking */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(30, 58, 138, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--card-background);
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            margin: 20px;
            width: calc(100% - 40px);
            border: 2px solid var(--primary-color);
        }
        
        @media (min-width: 640px) {
            .modal-content {
                width: auto;
                margin: 0;
            }
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        
        .modal-header {
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 12px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .modal-close:hover {
            background-color: #f3f4f6;
        }
        
        .calculation-details {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            background: #f8fafc;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
            max-height: 350px;
            overflow-y: auto;
        }
        
        .details-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            margin-left: 6px;
            transition: background-color 0.2s;
        }
        
        .details-btn:hover {
            background: #1e40af;
        }
        
        /* Size Dropdown Banking Style */
        .size-dropdown {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 11px;
            font-weight: 600;
            color: var(--primary-color);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            min-width: 70px;
        }
        
        .size-dropdown:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 1px var(--primary-color);
        }
        
        .size-dropdown:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(30, 58, 138, 0.2);
        }
        
        .size-dropdown option {
            padding: 3px;
            font-weight: normal;
        }
        
        /* Timeline Styles */
        .timeline-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }
        
        .timeline-marker:hover {
            transform: translateY(-50%) scale(1.2);
            z-index: 101;
        }
        
        .timeline-marker.active {
            transform: translateY(-50%) scale(1.4);
            z-index: 102;
        }
        
        /* Timeline Tooltip */
        .timeline-tooltip {
            position: absolute;
            bottom: 150%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            white-space: normal;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            margin-bottom: 12px;
            min-width: 350px;
            max-width: 450px;
            width: 400px;
            text-align: left;
            line-height: 1.4;
        }
        
        .timeline-tooltip.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-8px);
        }
        
        .timeline-tooltip.tooltip-left.visible {
            opacity: 1;
            transform: translateX(0) translateY(-8px);
        }
        
        .timeline-tooltip.tooltip-right.visible {
            opacity: 1;
            transform: translateX(0) translateY(-8px);
        }
        
        .timeline-tooltip.tooltip-center.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-8px);
        }
        
        .timeline-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }
        
        .timeline-tooltip.tooltip-left::after {
            left: 20px;
            transform: translateX(0);
        }
        
        .timeline-tooltip.tooltip-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }
        
        .timeline-delayed {
            background: linear-gradient(45deg, var(--danger-color) 0%, #b91c1c 100%);
        }
        
        .timeline-ontime {
            background: linear-gradient(45deg, var(--accent-color) 0%, #047857 100%);
        }
        
        .timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 11px;
        }
        
        .timeline-legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        
        .tooltip-container {
            position: relative;
            cursor: pointer;
        }
        
        .tooltip-text {
            visibility: hidden;
            width: 280px;
            background-color: var(--secondary-color);
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -140px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            pointer-events: none;
            white-space: pre-wrap;
        }
        
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Select dropdowns */
        .select-multiple {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%236b7280'%3e%3cpath d='M7 7l3-3 3 3m0 6l-3 3-3-3' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em;
        }
        
        /* Compact spacing */
        .compact-spacing {
            gap: 12px;
        }
        
        .compact-card {
            padding: 12px;
        }
        
        /* Enterprise buttons */
        .btn-enterprise {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        
        .btn-enterprise:hover {
            background: #1e40af;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .btn-secondary {
            background: var(--secondary-color);
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }
        
        .btn-success {
            background: var(--accent-color);
        }
        
        .btn-success:hover {
            background: #047857;
        }
        
        .btn-danger {
            background: var(--danger-color);
        }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        /* Main layout override for better control */
        #main-content {
            display: block !important;
            margin-bottom: 2rem !important;
        }
        
        @media (max-width: 1024px) {
            #main-content {
                display: block !important;
            }
            
            .task-config-container {
                width: 100% !important;
                float: none !important;
                margin-right: 0 !important;
                margin-bottom: 20px !important;
            }
        }
        
        /* Task Configuration on the left - fixed sizing */
        .task-config-container {
            width: 350px !important;
            max-width: 350px !important;
            float: left !important;
            margin-right: 20px !important;
            margin-bottom: 20px !important;
        }
        
        /* Task management area - clear the float */
        .task-management-area {
            overflow: hidden !important;
        }
        
        /* Vertical arrangement for task size cards */
        #task-size-cards.space-y-2 > * + * {
            margin-top: 0.5rem !important;
        }
        
        /* Team Availability Scrollable Area Styles */
        .team-availability-scroll {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
            position: relative;
        }
        
        .team-availability-scroll::-webkit-scrollbar {
            width: 6px;
        }
        
        .team-availability-scroll::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .team-availability-scroll::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .team-availability-scroll::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Scroll fade indicator */
        .team-availability-scroll::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(transparent, rgba(248, 250, 252, 0.8));
            pointer-events: none;
            border-radius: 0 0 8px 8px;
        }
        
        /* Enhanced hover effects for people cards in scroll area */
        .team-availability-scroll .person-card {
            transition: all 0.2s ease;
        }
        
        .team-availability-scroll .person-card:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Compact table styles */
        .enterprise-table {
            font-size: 12px;
        }
        
        .enterprise-table th {
            padding: 8px 12px;
            background: var(--primary-color);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }
        
        .enterprise-table td {
            padding: 6px 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .enterprise-table tr:hover {
            background: rgba(30, 58, 138, 0.03);
        }
        
        /* Enterprise Input Styling */
        .enterprise-input {
            background: var(--card-background);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--secondary-color);
            font-weight: 500;
            transition: all 0.2s ease;
            outline: none;
        }
        
        .enterprise-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(30, 58, 138, 0.1);
        }
        
        .enterprise-input:hover {
            border-color: var(--primary-color);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="enterprise-container mx-auto">
        <div class="enterprise-header flex justify-between items-center mb-4 p-4 rounded-lg">
            <h1 class="text-2xl font-bold">Enterprise Project Delivery Console</h1>
            <div class="flex gap-2">
                <button onclick="exportConfiguration()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                    Export Config
                </button>
                <button onclick="triggerImport()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                    </svg>
                    Import Config
                </button>
                <button onclick="triggerTaskImport()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Import Tasks
                </button>
                <button onclick="exportData()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Export Schedule
                </button>
                <button onclick="resetToDefaults()" class="btn-danger flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Reset
                </button>
            </div>
        </div>
        
        <p id="auth-status" class="text-xs text-gray-600 mb-3">üìä Enterprise data management - All information stored securely in browser storage.</p>
        
        <!-- Hidden file input for configuration import -->
        <input type="file" id="import-config-file" accept=".csv" style="display: none;" onchange="handleConfigImport(event)">
        
        <!-- Hidden file input for task bulk import -->
        <input type="file" id="import-tasks-file" accept=".csv" style="display: none;" onchange="handleTaskImport(event)">
        
        <div id="loading-spinner" class="text-center p-10 hidden">
            <!-- Spinner removed as local loading is instant -->
        </div>

        <div id="main-content" class="mb-8">
            
            <!-- Task Configuration - Now on the left with fixed width -->
            <div class="task-config-container input-card enterprise-table p-4 rounded-lg">
                
                <!-- Enhanced Task Sizing Management -->
                <div class="task-size-manager">
                    <h2 class="text-lg font-bold mb-3 flex items-center text-primary-dark">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        üìè Task Configuration
                    </h2>
                    
                    <div class="compact-spacing">
                        <div class="mb-3 flex items-center gap-4 flex-wrap">
                            <div class="flex items-center gap-2">
                                <label class="text-base font-semibold text-white">Hours/Day:</label>
                                <input type="number" id="hours-per-day" value="8" min="1" max="24" 
                                       onchange="updateEffortMapping(event.target.value)" 
                                       class="enterprise-input w-20 text-lg font-bold">
                            </div>
                            <div class="text-base font-medium text-blue-100 bg-blue-800 bg-opacity-50 px-2 py-1 rounded">
                                Total = Days √ó <span id="hours-per-day-display" class="font-bold text-yellow-300">8</span>h
                            </div>
                        </div>
                        
                        <!-- Vertical arrangement of task size cards -->
                        <div id="task-size-cards" class="space-y-2 mb-3">
                            <!-- Enhanced task size cards will be rendered here vertically -->
                        </div>
                        
                        <div class="flex gap-2 mb-3 flex-wrap text-xs">
                            <button onclick="applyPreset('agile')" class="btn-enterprise">üèÉ Agile</button>
                            <button onclick="applyPreset('enterprise')" class="btn-enterprise">üè¢ Enterprise</button>
                            <button onclick="applyPreset('startup')" class="btn-enterprise">üöÄ Startup</button>
                            <button onclick="applyPreset('conservative')" class="btn-enterprise">üõ°Ô∏è Conservative</button>
                            <button onclick="showCustomSizeForm()" class="btn-enterprise">‚ûï Custom</button>
                        </div>
                        
                        <div id="custom-size-form" class="custom-size-form hidden">
                            <h4 class="font-semibold mb-2 text-sm">Add Custom Task Size</h4>
                            <div class="flex gap-2 items-end flex-wrap">
                                <div>
                                    <label class="block text-xs mb-1">Key</label>
                                    <input type="text" id="new-size-key" placeholder="XS" maxlength="4" 
                                           class="enterprise-input w-16">
                                </div>
                                <div>
                                    <label class="block text-xs mb-1">Name</label>
                                    <input type="text" id="new-size-name" placeholder="Extra Small" 
                                           class="enterprise-input w-24">
                                </div>
                                <div>
                                    <label class="block text-xs mb-1">Days</label>
                                    <input type="number" id="new-size-days" placeholder="0.5" min="0.1" max="50" step="0.5" 
                                           class="enterprise-input w-16">
                                </div>
                                <button onclick="addCustomSize()" class="btn-enterprise">Add</button>
                                <button onclick="hideCustomSizeForm()" class="btn-danger">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Task Management - Takes remaining space -->
            <div class="task-management-area input-card enterprise-table p-4 rounded-lg">
                
                <!-- Visual Timeline Display -->
                <div class="mt-4 p-3 enterprise-timeline border rounded-lg">
                    <h3 class="text-md font-semibold mb-2 text-primary-dark flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        üìà Project Timeline
                    </h3>
                    <div id="timeline-container" class="relative" style="margin-top: 20px; margin-bottom: 20px;">
                        <div id="timeline-info" class="text-sm text-gray-600 mb-4">
                            üìÖ <span id="timeline-start-date">No tasks defined</span> ‚Üí 
                            üèÅ <span id="timeline-end-date">No tasks defined</span> 
                            (<span id="timeline-duration">0 days</span>)
                        </div>
                        <div class="timeline-scroll-container border border-gray-300 rounded-lg p-4 bg-gray-50" style="height: 200px; overflow-x: auto; overflow-y: auto;">
                            <div style="min-width: 1200px; min-height: 350px; display: flex; flex-direction: column; justify-content: flex-start; padding-top: 20px;">
                                <div class="relative" style="margin-top: 160px; margin-bottom: 60px;">
                                    <div id="timeline-bar" class="relative bg-gray-200 h-8 rounded-lg" style="width: 100%; min-width: 1200px; overflow: visible;">
                                        <div id="timeline-progress" class="h-full bg-gradient-to-r from-blue-400 to-green-400 transition-all duration-500" style="width: 0%"></div>
                                        <div id="timeline-markers" class="absolute inset-0 flex items-center px-2">
                                            <!-- Task markers will be populated here -->
                                        </div>
                                        <!-- Week markers for better visualization -->
                                        <div id="week-markers" class="absolute inset-0 pointer-events-none">
                                            <!-- Week markers will be populated here -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="timeline-legend" class="flex flex-wrap gap-2 mt-2 text-xs">
                            <!-- Legend items will be populated here -->
                        </div>
                    </div>
                </div>
                
                <h2 class="text-lg font-semibold mb-3 text-primary-dark flex items-center mt-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Task Management
                </h2>

                <!-- Common Start Date Control -->
                <div class="mb-4 p-3 enterprise-card border rounded-lg">
                    <div class="flex items-center gap-4 mb-2">
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="use-common-start-date" onchange="toggleCommonStartDate()" 
                                   class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <span class="ml-2 text-sm font-medium text-primary-dark">üìÖ Unified Start Date</span>
                        </label>
                        <input type="date" id="common-start-date" disabled 
                               class="enterprise-input text-sm" 
                               title="Common start date for all tasks"
                               onchange="updateAllTaskStartDates()">
                    </div>
                    <div class="text-xs text-gray-600">
                        üí° Synchronizes all task start dates for streamlined project planning
                    </div>
                </div>

                <div class="mt-4">
                    <h3 class="font-semibold text-md mb-3">Add New Task</h3>
                    <div class="compact-spacing">
                        <div class="grid grid-cols-1 xl:grid-cols-12 gap-3 items-end">
                            <div class="xl:col-span-4">
                                <label class="block text-xs text-gray-600 mb-1">Task Description</label>
                                <input type="text" id="new-ticket-desc" placeholder="Task Description" class="enterprise-input w-full">
                            </div>
                            <div class="xl:col-span-2">
                                <label class="block text-xs text-gray-600 mb-1">Start Date</label>
                                <input type="date" id="new-ticket-start-date" class="enterprise-input w-full" title="Start Date">
                            </div>
                            <div class="xl:col-span-1">
                                <label class="block text-xs text-gray-600 mb-1">Size</label>
                                <select id="new-ticket-size" class="enterprise-input w-full">
                                    <!-- Options populated dynamically by JavaScript -->
                                </select>
                            </div>
                            <div class="xl:col-span-1">
                                <label class="block text-xs text-gray-600 mb-1">Priority</label>
                                <select id="new-ticket-priority" class="enterprise-input w-full" title="Priority">
                                    <option value="P3">P3</option>
                                    <option value="P1">P1</option>
                                    <option value="P2">P2</option>
                                    <option value="P4">P4</option>
                                    <option value="P5">P5</option>
                                </select>
                            </div>
                            <div class="xl:col-span-3">
                                <label class="block text-xs text-gray-600 mb-1">Assign to:</label>
                                <div id="new-ticket-assigned" class="flex flex-wrap gap-1 p-2 border border-gray-300 rounded-md bg-white min-h-[35px] items-start">
                                    <!-- Checkboxes populated by JS -->
                                </div>
                            </div>
                            <div class="xl:col-span-1">
                                <button onclick="addTicket()" class="btn-enterprise w-full h-[35px] flex-shrink-0">Add</button>
                            </div>
                        </div>
                        <div class="text-xs text-gray-500 mt-2">
                            üí° <span id="start-date-help">Individual start dates enabled. Team availability calculated from earliest task.</span>
                        </div>
                    </div>
                </div>
                
                <!-- Task List and Projection -->
                <div class="mt-4">
                    <h3 class="text-lg font-semibold mb-2 text-primary-dark">Task Schedule</h3>
                    
                    <!-- Task Filtering Controls -->
                    <div id="task-filter-section" class="mb-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
                        <div class="flex items-center gap-3 mb-2">
                            <span class="text-sm font-medium text-gray-700">üîç Filter tasks by person:</span>
                            <div id="person-filter-buttons" class="flex flex-wrap gap-2">
                                <!-- Person filter buttons will be populated by JavaScript -->
                            </div>
                            <button id="clear-filter-btn" onclick="clearPersonFilter()" 
                                    class="px-3 py-1 bg-red-100 text-red-700 rounded-md text-xs hover:bg-red-200 transition-colors" 
                                    style="display: none;">
                                Clear Filter
                            </button>
                        </div>
                        <div id="filter-status" class="text-xs text-gray-600" style="display: none;">
                            <!-- Filter status will be shown here -->
                        </div>
                    </div>
                    
                    <div class="overflow-x-auto rounded-lg border">
                        <table class="enterprise-table min-w-full divide-y">
                            <thead>
                                <tr>
                                    <th class="px-3 py-2 text-left w-16">ID</th>
                                    <th class="px-3 py-2 text-left min-w-0 flex-1">Description</th>
                                    <th class="px-3 py-2 text-left w-32">
                                        <span id="start-date-column-header">Start Date</span>
                                    </th>
                                    <th class="px-3 py-2 text-left w-20">Size</th>
                                    <th class="px-3 py-2 text-left w-20">Priority</th>
                                    <th class="px-3 py-2 text-left w-48">Assigned</th>
                                    <th class="px-3 py-2 text-left w-32 tooltip-container">End Date
                                        <div class="tooltip-text">
                                            Calculated from start date, team availability, and effort hours.
                                        </div>
                                    </th>
                                    <th class="px-3 py-2 text-left w-24">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="ticket-table-body" class="divide-y">
                                <!-- Tickets will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                    <p id="no-tickets" class="text-center py-3 text-gray-500 hidden">No tasks defined. Add a task to begin!</p>
                </div>
                </div>
                <!-- End task-management-area -->
                
            </div>
            <!-- End right-side-container -->
            
        </div>
        <!-- End main-content -->
        
    </div>

    <!-- Modal for Calculation Details -->
    <div id="calculation-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-title">Calculation Details</h3>
                <button class="modal-close" onclick="closeCalculationModal()">&times;</button>
            </div>
            <div class="calculation-details" id="calculation-content">
                <!-- Calculation details will be populated here -->
            </div>
        </div>
    </div>

    <!-- Team Workload Heat Map Section -->
    <div class="container mx-auto px-4 py-6">
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">üìä Team Workload Heat Map (Next 8 Weeks)</h2>
                <p class="text-sm text-gray-600 mt-1">Visual overview of team capacity utilization based on individual availability</p>
            </div>
            <div class="card-content">
                <div id="workload-heatmap" class="overflow-x-auto">
                    <!-- Heat map will be rendered here -->
                </div>
                <div class="mt-4 flex flex-wrap gap-4 text-sm">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-green-100 border border-green-300 rounded"></div>
                        <span>0-60% Capacity (Available)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-yellow-100 border border-yellow-300 rounded"></div>
                        <span>61-90% Capacity (Busy)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-red-100 border border-red-300 rounded"></div>
                        <span>91%+ Capacity (Overloaded)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Team Configuration Section -->
    <div class="container mx-auto px-4 py-6">
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">üë• Team Configuration</h2>
                <p id="availability-header" class="text-sm text-gray-600 mt-1">Team Availability (Next 8 Weeks)</p>
            </div>
            <div class="card-content">
                <!-- People list with larger cards for configuration -->
                <div id="people-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 mb-6">
                    <!-- People cards will be rendered here in grid -->
                </div>
                
                <!-- Add member section -->
                <div class="border-t pt-4">
                    <h3 class="text-lg font-semibold mb-3">Add New Team Member</h3>
                    <div class="flex gap-3 items-center max-w-md">
                        <input type="text" id="new-person-name" placeholder="Enter team member name" class="enterprise-input flex-grow">
                        <button onclick="addPerson()" class="btn-enterprise">Add Member</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL CONFIG & STATE ---
        const STORAGE_KEY = 'projectSchedulerDataV2';
        let people = [];
        let tickets = [];
        let hoursPerDay = 8; 
        let ticketDays = {
            S: 1, M: 2, L: 5, XL: 10, XXL: 15
        };
        
        // Enhanced task sizing with display names and presets
        let taskSizeDefinitions = {
            S: { name: 'Small', days: 1, removable: false },
            M: { name: 'Medium', days: 2, removable: false },
            L: { name: 'Large', days: 5, removable: false },
            XL: { name: 'X-Large', days: 10, removable: false },
            XXL: { name: 'XX-Large', days: 15, removable: false }
        };
        
        let effortMap = {};
        let currentTicketId = 1;
        let useCommonStartDate = false;

        // Task filtering variables
        let selectedPersonFilters = []; // Array to track which people are selected for filtering

        // Date constants (used as the start of Week 1)
        const startDate = getNextMonday(new Date());
        
        // Get effective start date for calculations (either default, common, or earliest task date)
        function getEffectiveStartDate() {
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                if (commonDate) {
                    const date = new Date(commonDate);
                    // Find the Monday of the week containing this date
                    return getMondayOfWeek(date);
                }
            }
            
            // Always try to find the earliest start date among all tasks first
            const earliestTaskDate = getEarliestTaskStartDate();
            if (earliestTaskDate) {
                // Find the Monday of the week containing the earliest date
                return getMondayOfWeek(earliestTaskDate);
            }
            
            // Only fall back to default startDate if no tasks exist
            return startDate;
        }
        
        // Get the Monday of the week containing the given date
        function getMondayOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Sunday being 0
            const monday = new Date(d.setDate(diff));
            monday.setHours(0, 0, 0, 0);
            return monday;
        }
        
        // Get the earliest start date from all defined tasks
        function getEarliestTaskStartDate() {
            if (tickets.length === 0) return null;
            
            const taskDates = tickets
                .map(ticket => ticket.startDate ? new Date(ticket.startDate) : null)
                .filter(date => date !== null)
                .sort((a, b) => a - b);
            
            return taskDates.length > 0 ? taskDates[0] : null;
        }

        // --- LOCAL STORAGE FUNCTIONS (Persistence) ---

        function saveToLocalStorage() {
            console.log('üíæ Saving to localStorage...');
            console.log('üìä taskSizeDefinitions being saved:', taskSizeDefinitions);
            
            const data = {
                people,
                tickets,
                hoursPerDay,
                ticketDays,
                taskSizeDefinitions,
                currentTicketId,
                useCommonStartDate,
                lastUpdated: new Date().toISOString()
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                console.log('‚úÖ Save successful');
            } catch (e) {
                console.error("Error saving to local storage:", e);
            }
        }

        function loadFromLocalStorage() {
            try {
                console.log('üîß Loading from localStorage...');
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    console.log('üì¶ Found stored data, parsing...');
                    const data = JSON.parse(storedData);
                    people = data.people || [];
                    tickets = data.tickets || [];
                    hoursPerDay = data.hoursPerDay || 8;
                    ticketDays = data.ticketDays || { S: 1, M: 2, L: 5, XL: 10, XXL: 15 };
                    
                    console.log('üìä Loaded taskSizeDefinitions from storage:', data.taskSizeDefinitions);
                    taskSizeDefinitions = data.taskSizeDefinitions || {
                        S: { name: 'Small', days: 1, removable: false },
                        M: { name: 'Medium', days: 2, removable: false },
                        L: { name: 'Large', days: 5, removable: false },
                        XL: { name: 'X-Large', days: 10, removable: false },
                        XXL: { name: 'XX-Large', days: 15, removable: false }
                    };
                    console.log('üìä Final taskSizeDefinitions after loading:', taskSizeDefinitions);
                    
                    // Backup the loaded task size definitions
                    backupTaskSizeDefinitions();
                    
                    currentTicketId = data.currentTicketId || (tickets.length > 0 ? Math.max(...tickets.map(t => t.id)) + 1 : 1);
                    useCommonStartDate = data.useCommonStartDate || false;
                    
                    // Sync ticketDays with taskSizeDefinitions
                    console.log('üîÑ About to sync task sizes...');
                    syncTaskSizes();
                    console.log('üìä taskSizeDefinitions after sync:', taskSizeDefinitions);
                    
                    // Migrate people availability arrays to 8 weeks if needed
                    migratePeopleToEightWeeks();
                    
                    return true;
                }
            } catch (e) {
                console.error("Error loading from local storage:", e);
            }
            return false;
        }
        
        function syncTaskSizes() {
            // Ensure ticketDays and taskSizeDefinitions stay in sync
            Object.keys(taskSizeDefinitions).forEach(key => {
                ticketDays[key] = taskSizeDefinitions[key].days;
            });
        }
        
        function migratePeopleToEightWeeks() {
            // Migrate existing people data to 8-week availability arrays
            people.forEach(person => {
                if (!person.availability) {
                    // If no availability array, create default 8-week array
                    person.availability = [25, 25, 25, 25, 25, 25, 25, 25];
                } else if (person.availability.length < 8) {
                    // If availability array is shorter than 8 weeks, extend it
                    const lastValue = person.availability[person.availability.length - 1] || 25;
                    while (person.availability.length < 8) {
                        person.availability.push(lastValue); // Use last known value as default
                    }
                } else if (person.availability.length > 8) {
                    // If somehow longer than 8, truncate (shouldn't happen but just in case)
                    person.availability = person.availability.slice(0, 8);
                }
            });
            
            // Save the migrated data
            saveToLocalStorage();
        }

        // --- UTILITY FUNCTIONS ---

        function getNextMonday(date) {
            const d = new Date(date);
            const currentDay = d.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            // Calculate days until next Monday
            let daysUntilMonday;
            if (currentDay === 0) { // Sunday
                daysUntilMonday = 1;
            } else if (currentDay === 1) { // Monday
                // If it's Monday and it's still early (before 9 AM), use today
                // Otherwise, use next Monday
                daysUntilMonday = (d.getHours() < 9) ? 0 : 7;
            } else { // Tuesday to Saturday
                daysUntilMonday = 8 - currentDay; // Days to next Monday
            }
            
            const nextMonday = new Date(d);
            nextMonday.setDate(d.getDate() + daysUntilMonday);
            nextMonday.setHours(0, 0, 0, 0);
            
            return nextMonday;
        }

        // --- TASK FILTERING FUNCTIONS ---

        function generatePersonFilterButtons() {
            const container = document.getElementById('person-filter-buttons');
            if (!container) return;
            
            container.innerHTML = '';
            
            people.forEach(person => {
                const button = document.createElement('button');
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border';
                button.textContent = person.name;
                button.onclick = () => togglePersonFilter(person.name);
                button.setAttribute('data-person', person.name);
                
                // Set initial state
                updatePersonFilterButtonState(button, person.name);
                
                container.appendChild(button);
            });
        }

        function updatePersonFilterButtonState(button, personName) {
            const isSelected = selectedPersonFilters.includes(personName);
            
            if (isSelected) {
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-blue-600 text-white border-blue-600 font-medium';
                button.title = `‚úì Showing ${personName}'s tasks (click to remove filter)`;
            } else if (selectedPersonFilters.length > 0) {
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-gray-100 text-gray-500 border-gray-300';
                button.title = `Click to show ${personName}'s tasks`;
            } else {
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-white text-gray-700 border-gray-300 hover:bg-gray-50';
                button.title = `Click to filter ${personName}'s tasks`;
            }
        }

        function togglePersonFilter(personName) {
            if (selectedPersonFilters.includes(personName)) {
                // Remove from filter
                selectedPersonFilters = selectedPersonFilters.filter(name => name !== personName);
            } else {
                // Add to filter
                selectedPersonFilters.push(personName);
            }
            
            updateFilterUI();
            updateTable(); // Re-render the table with filtering applied
        }

        function clearPersonFilter() {
            selectedPersonFilters = [];
            updateFilterUI();
            updateTable(); // Re-render the table
        }

        function updateFilterUI() {
            try {
                // Update all filter button states
                document.querySelectorAll('.person-filter-btn').forEach(button => {
                    const personName = button.getAttribute('data-person');
                    updatePersonFilterButtonState(button, personName);
                });
                
                // Update filter status and clear button
                const filterStatus = document.getElementById('filter-status');
                const clearBtn = document.getElementById('clear-filter-btn');
                
                if (!filterStatus || !clearBtn) {
                    console.warn('Filter UI elements not found');
                    return;
                }
                
                if (selectedPersonFilters.length === 0) {
                    filterStatus.style.display = 'none';
                    clearBtn.style.display = 'none';
                } else {
                    filterStatus.style.display = 'block';
                    clearBtn.style.display = 'inline-block';
                    
                    const filteredTaskCount = getFilteredTickets().length;
                    filterStatus.innerHTML = `
                        Showing tasks assigned to: <strong>${selectedPersonFilters.join(', ')}</strong> 
                        (${filteredTaskCount} task${filteredTaskCount !== 1 ? 's' : ''} visible)
                    `;
                }
            } catch (error) {
                console.error('Error updating filter UI:', error);
            }
        }

        function shouldShowTicket(ticket) {
            // If no filter is active, show all tickets
            if (selectedPersonFilters.length === 0) return true;
            
            // If filter is active, only show tickets assigned to selected people
            return selectedPersonFilters.some(filterPerson => 
                ticket.assigned.some(assignedPerson => 
                    assignedPerson.toLowerCase() === filterPerson.toLowerCase()
                )
            );
        }

        function getFilteredTickets() {
            return tickets.filter(ticket => shouldShowTicket(ticket));
        }

        // Alias for compatibility with the filtering functions
        function updateTable() {
            calculateProjection();
        }

        function getDefaultTaskStartDate() {
            const today = new Date();
            const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            const currentHour = today.getHours();
            
            // If it's a weekday (Monday-Thursday) and before 5 PM, use today
            if (currentDay >= 1 && currentDay <= 4 && currentHour < 17) {
                return today;
            }
            
            // If it's Friday and before noon, use today
            if (currentDay === 5 && currentHour < 12) {
                return today;
            }
            
            // If it's a weekday after hours, use tomorrow
            if (currentDay >= 1 && currentDay <= 4) {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                return tomorrow;
            }
            
            // For Friday afternoon, weekend, use next Monday
            return getNextMonday(today);
        }
        
        function formatDate(dateString) {
            if (!dateString) return 'Not set';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric'
            });
        }
        
        function formatWeekEndDate(weekIndex) {
            const effectiveStart = getEffectiveStartDate();
            const date = new Date(effectiveStart);
            date.setDate(date.getDate() + (weekIndex * 7) + 4); // +4 days for Friday
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        function getWeekDateRange(weekIndex) {
            const effectiveStart = getEffectiveStartDate();
            const startDate = new Date(effectiveStart);
            startDate.setDate(startDate.getDate() + (weekIndex * 7));
            
            const endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 4); // Friday
            
            return `${startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        }

        function formatCompletionDate(startWeekIndex, remainingHours, totalWeeklyCapacity) {
            const effectiveStart = getEffectiveStartDate();
            const completionDate = new Date(effectiveStart);
            let daysIntoWeek = 0;

            if (totalWeeklyCapacity > 0) {
                // Calculate how many calendar days are needed to complete the remaining hours
                // at the current work pace (hoursPerDay)
                const daysNeeded = remainingHours / hoursPerDay;
                daysIntoWeek = Math.ceil(daysNeeded);
                daysIntoWeek = Math.min(daysIntoWeek, 5); // Cap at 5 working days per week
            }

            completionDate.setDate(completionDate.getDate() + (startWeekIndex * 7) + daysIntoWeek);
            
            let dayOfWeek = completionDate.getDay();
            if (dayOfWeek === 6) { // Saturday
                completionDate.setDate(completionDate.getDate() + 2);
            } else if (dayOfWeek === 0) { // Sunday
                completionDate.setDate(completionDate.getDate() + 1);
            }

            return completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        function getCompletionDateDetails(startWeekIndex, remainingHours, totalWeeklyCapacity) {
            const effectiveStart = getEffectiveStartDate();
            const weekStartDate = new Date(effectiveStart);
            weekStartDate.setDate(weekStartDate.getDate() + (startWeekIndex * 7));
            
            // Ensure we start on a business day
            const actualStartDate = getNextBusinessDay(weekStartDate);
            
            if (totalWeeklyCapacity > 0) {
                // Calculate business days needed based on the task size definition
                const daysNeeded = Math.ceil(remainingHours / hoursPerDay);
                const completionDate = addBusinessDays(actualStartDate, Math.max(1, daysNeeded - 1));
                
                return {
                    formatted: completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    rawDate: new Date(completionDate)
                };
            }

            // Fallback if no capacity
            return {
                formatted: actualStartDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                rawDate: new Date(actualStartDate)
            };
        }
        
        // Function to get default task size definitions
        function getDefaultTaskSizeDefinitions() {
            return {
                S: { name: 'Small', days: 1, removable: false },
                M: { name: 'Medium', days: 2, removable: false },
                L: { name: 'Large', days: 5, removable: false },
                XL: { name: 'X-Large', days: 10, removable: false },
                XXL: { name: 'XX-Large', days: 15, removable: false }
            };
        }

        // Function to backup current task size definitions (only if changed)
        function backupTaskSizeDefinitions() {
            if (!taskSizeDefinitions || Object.keys(taskSizeDefinitions).length === 0) {
                return;
            }
            
            try {
                // Check if backup already exists and is the same
                const existingBackup = localStorage.getItem('taskSizeDefinitions_backup');
                const currentData = JSON.stringify(taskSizeDefinitions);
                
                if (existingBackup === currentData) {
                    // No changes, skip backup
                    return;
                }
                
                // Only backup if data has actually changed
                localStorage.setItem('taskSizeDefinitions_backup', currentData);
                const timestamp = new Date().toISOString();
                localStorage.setItem('taskSizeDefinitions_backup_timestamp', timestamp);
                console.log('üìÅ Backed up taskSizeDefinitions (changed data detected)');
                
                // Optional: Clean up old backups (keep only the latest)
                cleanupOldBackups();
                
            } catch (e) {
                console.log('‚ö†Ô∏è Could not create backup:', e.message);
            }
        }

        // Function to clean up old backup data
        function cleanupOldBackups() {
            try {
                // Remove any old backup keys that might exist
                const keysToCheck = ['taskSizeDefinitions_backup_1', 'taskSizeDefinitions_backup_2', 'taskSizeDefinitions_backup_old'];
                keysToCheck.forEach(key => {
                    if (localStorage.getItem(key)) {
                        localStorage.removeItem(key);
                        console.log(`üßπ Cleaned up old backup: ${key}`);
                    }
                });
            } catch (e) {
                console.log('‚ö†Ô∏è Could not clean up old backups:', e.message);
            }
        }

        // Function to restore from backup or defaults
        function restoreTaskSizeDefinitions() {
            console.log('üîß Attempting to restore taskSizeDefinitions...');
            
            // First try to restore from backup
            try {
                const backup = localStorage.getItem('taskSizeDefinitions_backup');
                const backupTimestamp = localStorage.getItem('taskSizeDefinitions_backup_timestamp');
                
                if (backup) {
                    const restored = JSON.parse(backup);
                    if (restored && Object.keys(restored).length > 0) {
                        console.log('‚úÖ Restored from backup:', restored);
                        if (backupTimestamp) {
                            console.log('üìÖ Backup created:', new Date(backupTimestamp).toLocaleString());
                        }
                        return restored;
                    }
                }
            } catch (e) {
                console.log('‚ö†Ô∏è Could not restore from backup:', e.message);
            }
            
            // Fall back to defaults
            const defaults = getDefaultTaskSizeDefinitions();
            console.log('‚úÖ Restored from defaults:', defaults);
            return defaults;
        }
        
        function calculateEffortMap() {
            console.log('üîß calculateEffortMap called');
            console.log('üìä taskSizeDefinitions keys count:', Object.keys(taskSizeDefinitions).length);
            console.log('üìä taskSizeDefinitions:', taskSizeDefinitions);
            
            // Add a check to see if it's unexpectedly empty
            if (Object.keys(taskSizeDefinitions).length === 0) {
                console.error('‚ùå CRITICAL: taskSizeDefinitions is empty! Stack trace:');
                console.trace();
                
                // Restore from backup or defaults
                taskSizeDefinitions = restoreTaskSizeDefinitions();
            }
            
            effortMap = {};
            Object.keys(taskSizeDefinitions).forEach(key => {
                // Task effort should be based on a standard 8-hour workday
                // This represents the actual work content, not the daily pace
                const days = taskSizeDefinitions[key].days;
                const effort = days * 8;
                effortMap[key] = effort;
                console.log(`üìä Size ${key}: ${days} days √ó 8 hours = ${effort} hours`);
            });
            console.log('üìä Final effort map:', effortMap);
        }

        // --- CORE SCHEDULING LOGIC ---

        function getProjectedTickets() {
            console.log('üîß getProjectedTickets called');
            console.log('üìä People count:', people.length);
            console.log('üìä Tickets count:', tickets.length);
            
            if (people.length === 0 || tickets.length === 0) {
                console.log('‚ùå No people or tickets, returning N/A end dates');
                return tickets.map(t => ({ ...t, endDate: 'N/A', explanation: 'No people or no effort.', isDelayed: false }));
            }

            calculateEffortMap();
            console.log('üìä Effort map:', effortMap);
            console.log('üìä Task size definitions:', taskSizeDefinitions);

            // Create a deep clone of availability for resource tracking
            const availabilityTracker = people.reduce((acc, p) => {
                acc[p.name] = [...p.availability];
                return acc;
            }, {});
            
            // Sort tickets by start date to ensure proper capacity allocation
            const sortedTickets = [...tickets].sort((a, b) => {
                const dateA = new Date(a.startDate || getEffectiveStartDate());
                const dateB = new Date(b.startDate || getEffectiveStartDate());
                return dateA - dateB;
            });
            
            const projectedTickets = sortedTickets.map(ticket => {
                console.log(`üé´ Processing ticket ${ticket.id}: ${ticket.description}`);
                const totalEffortHours = effortMap[ticket.size] || 0;
                const assignedCount = ticket.assigned.length;
                
                console.log(`üìä Ticket ${ticket.id} - Size: ${ticket.size}, Effort: ${totalEffortHours}h, Assigned: ${assignedCount} people`);
                
                if (totalEffortHours === 0 || assignedCount === 0) {
                    console.log(`‚ùå Ticket ${ticket.id} - No effort defined or no one assigned`);
                    return { ...ticket, endDate: 'N/A', explanation: 'No effort defined or no one assigned.', isDelayed: false };
                }

                // Calculate which week the task can start based on start date
                let taskStartDate;
                let weekStartDate; // This should match the planning baseline for this specific task
                
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    taskStartDate = commonDate ? new Date(commonDate) : getEffectiveStartDate();
                    weekStartDate = taskStartDate; // Use the same date as the baseline
                } else {
                    taskStartDate = new Date(ticket.startDate || getEffectiveStartDate());
                    weekStartDate = taskStartDate; // Use the task's individual start date as baseline
                }
                
                // Ensure task starts on a business day
                taskStartDate = getNextBusinessDay(taskStartDate);
                
                const daysDiff = Math.max(0, Math.floor((taskStartDate - weekStartDate) / (1000 * 60 * 60 * 24)));
                const startWeekIndex = Math.max(0, Math.floor(daysDiff / 7));

                let hoursRemaining = totalEffortHours; // Total effort stays the same regardless of team size
                const initialHours = hoursRemaining;
                
                let completionWeekIndex = -1;
                let finalCapacity = 0;
                let pooledCapacityThisWeek = 0; 
                
                let explanation = `Ticket Effort: ${totalEffortHours} hours (${ticket.size}, ${taskSizeDefinitions[ticket.size].days} person-days).\n`;
                explanation += `Assigned: ${ticket.assigned.join(', ')} (${assignedCount} person(s)).\n`;
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    explanation += `Start Date: ${formatDate(taskStartDate.toISOString().split('T')[0])} (Week ${startWeekIndex + 1}) [Common Start Date].\n`;
                } else {
                    explanation += `Start Date: ${formatDate(taskStartDate.toISOString().split('T')[0])} (Week ${startWeekIndex + 1}).\n`;
                }
                explanation += `Required Duration Hours (pooled): ${initialHours.toFixed(1)} hours.\n`;
                explanation += `Planning baseline: Week 1 starts ${formatDate(weekStartDate.toISOString().split('T')[0])}.\n\n`;

                let currentHoursToConsume = hoursRemaining;

                // Iterate through 8 weeks, starting from the appropriate week
                for (let w = startWeekIndex; w < 8; w++) {
                    pooledCapacityThisWeek = 0;
                    const capacityBreakdown = {};
                    
                    ticket.assigned.forEach(name => {
                        const personCapacity = availabilityTracker[name] ? availabilityTracker[name][w] || 0 : 0;
                        pooledCapacityThisWeek += personCapacity;
                        capacityBreakdown[name] = personCapacity;
                    });
                    
                    explanation += `--- Week ${w + 1} (${getWeekDateRange(w)}) ---\n`;
                    explanation += `Pooled Capacity: ${pooledCapacityThisWeek.toFixed(1)} hours.\n`;
                    
                    if (pooledCapacityThisWeek <= 0) {
                        explanation += 'No capacity this week from assigned team members. Moving to next week.\n';
                        continue;
                    }
                    
                    if (currentHoursToConsume <= pooledCapacityThisWeek) {
                        completionWeekIndex = w;
                        finalCapacity = currentHoursToConsume;
                        explanation += `Task completes this week, consuming ${currentHoursToConsume.toFixed(1)} hours of pooled capacity.\n`;
                        
                        let capacityUsed = currentHoursToConsume;
                        ticket.assigned.forEach(name => {
                            const personCapacity = capacityBreakdown[name];
                            if (personCapacity > 0) {
                                const proportion = personCapacity / pooledCapacityThisWeek;
                                const timeToDeduct = capacityUsed * proportion;
                                availabilityTracker[name][w] -= timeToDeduct;
                                explanation += `  - ${name} contribution: ${timeToDeduct.toFixed(1)} hours (Remaining: ${availabilityTracker[name][w].toFixed(1)}).\n`;
                            }
                        });
                        break;
                    } else {
                        currentHoursToConsume -= pooledCapacityThisWeek;
                        explanation += `Full capacity consumed (${pooledCapacityThisWeek.toFixed(1)} hours). Remaining hours for task: ${currentHoursToConsume.toFixed(1)}.\n`;

                        ticket.assigned.forEach(name => {
                            availabilityTracker[name][w] = 0;
                        });
                    }
                }

                let endDate;
                let rawEndDate = null;
                let isDelayed = false;

                // Use capacity-based calculation for end date
                if (completionWeekIndex !== -1) {
                    // Calculate completion date based on the actual task start date and week offset
                    const weekStartDate = new Date(taskStartDate);
                    weekStartDate.setDate(weekStartDate.getDate() + ((completionWeekIndex - startWeekIndex) * 7));
                    
                    // Ensure we start on a business day
                    const actualCompletionDate = getNextBusinessDay(weekStartDate);
                    
                    if (pooledCapacityThisWeek > 0) {
                        // Calculate business days needed based on remaining capacity
                        const daysNeeded = Math.ceil(finalCapacity / 8); // Assuming 8 hours per day
                        const completionDate = addBusinessDays(actualCompletionDate, Math.max(0, daysNeeded - 1));
                        
                        endDate = completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        rawEndDate = completionDate;
                    } else {
                        endDate = actualCompletionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        rawEndDate = actualCompletionDate;
                    }
                    
                    explanation += `\nTask completes in Week ${completionWeekIndex + 1}: ${endDate}\n`;
                } else {
                    explanation += '\nTask is projected to finish AFTER the 8-week window based on capacity.';
                    isDelayed = true;
                    // Fallback to business day calculation only when capacity calculation fails
                    const taskDurationInDays = taskSizeDefinitions[ticket.size].days;
                    const actualEndDate = addBusinessDays(taskStartDate, taskDurationInDays - 1);
                    endDate = actualEndDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    rawEndDate = actualEndDate;
                }
                
                // Show business day calculation for reference
                const taskDurationInDays = taskSizeDefinitions[ticket.size].days;
                const businessDayEndDate = addBusinessDays(taskStartDate, taskDurationInDays - 1);
                explanation += `\n--- BUSINESS DAY REFERENCE ---\n`;
                explanation += `Task Duration: ${taskDurationInDays} business days\n`;
                explanation += `Start: ${taskStartDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}\n`;
                explanation += `Business Day End: ${businessDayEndDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}\n`;
                
                return { 
                    ...ticket, 
                    endDate: endDate,
                    rawEndDate: rawEndDate,
                    explanation: explanation,
                    isDelayed: isDelayed
                };
            });
            
            // Restore original order for UI display
            const orderedResults = tickets.map(originalTicket => 
                projectedTickets.find(pt => pt.id === originalTicket.id) || originalTicket
            );
            
            return orderedResults;
        }

        function calculateProjection() {
            const projectedTickets = getProjectedTickets();
            renderTickets(projectedTickets);
            renderTimeline(projectedTickets);
            renderWorkloadHeatMap();
        }
        
        function renderTimeline(projectedTickets) {
            const timelineStartDateEl = document.getElementById('timeline-start-date');
            const timelineEndDateEl = document.getElementById('timeline-end-date');
            const timelineDurationEl = document.getElementById('timeline-duration');
            const timelineProgressEl = document.getElementById('timeline-progress');
            const timelineMarkersEl = document.getElementById('timeline-markers');
            const timelineLegendEl = document.getElementById('timeline-legend');
            
            if (projectedTickets.length === 0) {
                timelineStartDateEl.textContent = 'No tasks defined';
                timelineEndDateEl.textContent = 'No tasks defined';
                timelineDurationEl.textContent = '0 days';
                timelineProgressEl.style.width = '0%';
                timelineMarkersEl.innerHTML = '';
                timelineLegendEl.innerHTML = '';
                return;
            }
            
            // Calculate timeline bounds - start from the earliest actual task start date
            let projectStartDate;
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                projectStartDate = commonDate ? new Date(commonDate) : getEarliestTaskStartDate() || new Date();
            } else {
                projectStartDate = getEarliestTaskStartDate() || new Date();
            }
            
            let projectEndDate = new Date(projectStartDate);
            let latestEndDate = new Date(projectStartDate);
            let hasDelayedTasks = false;
            
            // Find the latest completion date
            projectedTickets.forEach(ticket => {
                if (ticket.rawEndDate && !ticket.isDelayed) {
                    // Use the raw date object for accurate timeline calculation
                    if (ticket.rawEndDate > latestEndDate) {
                        latestEndDate = ticket.rawEndDate;
                    }
                } else if (ticket.isDelayed || (ticket.endDate && ticket.endDate.includes('>'))) {
                    hasDelayedTasks = true;
                    // For delayed tasks, assume they extend beyond 8 weeks
                    const delayedDate = new Date(projectStartDate);
                    delayedDate.setDate(delayedDate.getDate() + 56); // 8 weeks
                    if (delayedDate > latestEndDate) {
                        latestEndDate = delayedDate;
                    }
                }
            });
            
            projectEndDate = latestEndDate;
            
            // Calculate duration
            const durationDays = Math.ceil((projectEndDate - projectStartDate) / (1000 * 60 * 60 * 24));
            const durationWeeks = Math.ceil(durationDays / 7);
            
            // Update timeline info
            timelineStartDateEl.textContent = formatDate(projectStartDate.toLocaleDateString('en-CA')); // YYYY-MM-DD format
            timelineEndDateEl.textContent = formatDate(projectEndDate.toLocaleDateString('en-CA')); // YYYY-MM-DD format
            timelineDurationEl.textContent = `${durationDays} days (${durationWeeks} weeks)`;
            
            // Determine timeline health based on 8-week planning horizon
            // Green: <= 6 weeks (good), Red: > 6 weeks or has delayed tasks (concerning)
            const isOverSchedule = hasDelayedTasks || durationWeeks > 6;
            
            if (isOverSchedule) {
                timelineProgressEl.className = 'h-full timeline-delayed transition-all duration-500';
            } else {
                timelineProgressEl.className = 'h-full timeline-ontime transition-all duration-500';
            }
            
            // Add task markers
            timelineMarkersEl.innerHTML = '';
            
            // Track the furthest task position for progress bar alignment
            let furthestTaskPosition = 0;
            
            // Add week markers for better visualization
            const weekMarkersEl = document.getElementById('week-markers');
            if (weekMarkersEl) {
                weekMarkersEl.innerHTML = '';
                for (let week = 1; week <= 8; week++) {
                    const weekPosition = (week / 8) * 100;
                    const weekMarker = document.createElement('div');
                    weekMarker.className = 'absolute top-0 bottom-0 w-px bg-gray-300 opacity-50';
                    weekMarker.style.left = `${weekPosition}%`;
                    weekMarker.setAttribute('data-label', `Week ${week}`);
                    weekMarkersEl.appendChild(weekMarker);
                    
                    // Add week labels at the bottom
                    const weekLabel = document.createElement('div');
                    weekLabel.className = 'absolute text-xs text-gray-500';
                    weekLabel.style.left = `${weekPosition}%`;
                    weekLabel.style.bottom = '-20px';
                    weekLabel.style.transform = 'translateX(-50%)';
                    weekLabel.textContent = `W${week}`;
                    weekMarkersEl.appendChild(weekLabel);
                }
            }
            
            projectedTickets.forEach((ticket, index) => {
                if (ticket.rawEndDate && !ticket.isDelayed) {
                    // Use raw date for accurate positioning
                    const dayFromStart = Math.ceil((ticket.rawEndDate - projectStartDate) / (1000 * 60 * 60 * 24));
                    // Position based on actual project duration, but ensure it fits within the visual timeline
                    const timelineScaleDays = Math.max(56, durationDays); // Use 8 weeks minimum, or actual duration if longer
                    const positionPercentage = Math.min(100, Math.max(0, (dayFromStart / timelineScaleDays) * 100));
                    
                    // Track the furthest task position
                    furthestTaskPosition = Math.max(furthestTaskPosition, positionPercentage);
                    
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.style.left = `calc(${positionPercentage}% - 8px)`; // Center the 16px wide marker
                    marker.style.position = 'relative'; // For tooltip positioning
                    marker.setAttribute('data-ticket-id', ticket.id);
                    marker.setAttribute('data-tooltip-text', `Task #${ticket.id}: ${ticket.description}\nDue: ${ticket.endDate}\nAssigned: ${ticket.assigned.join(', ') || 'Unassigned'}`);
                    // Use white markers with colored border for better visibility on any background
                    marker.style.background = '#ffffff';
                    marker.style.border = '4px solid #10b981';
                    marker.style.boxShadow = '0 3px 6px rgba(0,0,0,0.3)';
                    
                    // Create tooltip element
                    const tooltip = document.createElement('div');
                    tooltip.className = 'timeline-tooltip';
                    tooltip.innerHTML = `
                        <div style="margin-bottom: 4px;">
                            <strong>Task #${ticket.id}:</strong> ${ticket.description}
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 12px;">
                            <span><em>Due: ${ticket.endDate}</em></span>
                            <span>Assigned: ${ticket.assigned.join(', ') || 'Unassigned'}</span>
                        </div>
                    `;
                    marker.appendChild(tooltip);
                    
                    // Add click event handler
                    marker.addEventListener('click', function(e) {
                        e.stopPropagation();
                        toggleTimelineTooltip(this);
                    });
                    
                    timelineMarkersEl.appendChild(marker);
                } else if (ticket.isDelayed || (ticket.endDate && ticket.endDate.includes('>'))) {
                    // Add a marker for delayed tasks at the end (beyond 8 weeks)
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.style.left = 'calc(98% - 8px)'; // Center the 16px wide marker
                    marker.style.position = 'relative'; // For tooltip positioning
                    marker.setAttribute('data-ticket-id', ticket.id);
                    marker.setAttribute('data-tooltip-text', `Task #${ticket.id}: ${ticket.description}\nStatus: Delayed (>8 weeks)\nAssigned: ${ticket.assigned.join(', ') || 'Unassigned'}`);
                    // Use white background with red border for delayed tasks
                    marker.style.background = '#ffffff';
                    marker.style.border = '4px solid #ef4444';
                    marker.style.boxShadow = '0 3px 6px rgba(0,0,0,0.3)';
                    
                    // Create tooltip element
                    const tooltip = document.createElement('div');
                    tooltip.className = 'timeline-tooltip';
                    tooltip.innerHTML = `
                        <div style="margin-bottom: 4px;">
                            <strong>Task #${ticket.id} (DELAYED):</strong> ${ticket.description}
                        </div>
                        <div style="display: flex; justify-content: space-between; font-size: 12px;">
                            <span><em>Status: Over 8 weeks</em></span>
                            <span>Assigned: ${ticket.assigned.join(', ') || 'Unassigned'}</span>
                        </div>
                    `;
                    marker.appendChild(tooltip);
                    
                    // Add click event handler
                    marker.addEventListener('click', function(e) {
                        e.stopPropagation();
                        toggleTimelineTooltip(this);
                    });
                    
                    timelineMarkersEl.appendChild(marker);
                }
            });
            
            // Update progress bar to end exactly at the furthest task marker
            timelineProgressEl.style.width = `${furthestTaskPosition}%`;
            
            // Update legend
            timelineLegendEl.innerHTML = `
                <div class="timeline-legend-item">
                    <div class="timeline-legend-dot bg-white border-2 border-green-500"></div>
                    <span>On Schedule (‚â§6 weeks)</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-dot bg-white border-2 border-red-500"></div>
                    <span>Over Schedule (>6 weeks)</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-dot bg-gray-400"></div>
                    <span>Click markers for task details</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="w-2 h-1 bg-gray-300"></div>
                    <span>Week markers (8-week horizon)</span>
                </div>
            `;
        }

        // Timeline marker click handler
        function toggleTimelineTooltip(marker) {
            console.log('Marker clicked:', marker.getAttribute('data-ticket-id')); // Debug log
            
            // Close any other active tooltips first
            document.querySelectorAll('.timeline-marker').forEach(otherMarker => {
                if (otherMarker !== marker) {
                    otherMarker.classList.remove('active');
                    const otherTooltip = otherMarker.querySelector('.timeline-tooltip');
                    if (otherTooltip) {
                        otherTooltip.classList.remove('visible');
                    }
                }
            });
            
            // Toggle the clicked marker and its tooltip
            const tooltip = marker.querySelector('.timeline-tooltip');
            const isActive = marker.classList.contains('active');
            
            if (isActive) {
                // Close tooltip
                marker.classList.remove('active');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                }
            } else {
                // Open tooltip with smart positioning
                marker.classList.add('active');
                if (tooltip) {
                    // Get marker position relative to timeline container
                    const timelineContainer = document.querySelector('.timeline-scroll-container');
                    const markerRect = marker.getBoundingClientRect();
                    const containerRect = timelineContainer.getBoundingClientRect();
                    const markerLeft = markerRect.left - containerRect.left + timelineContainer.scrollLeft;
                    const containerWidth = timelineContainer.clientWidth;
                    const tooltipWidth = 400; // Our tooltip width
                    
                    // Reset positioning classes
                    tooltip.classList.remove('tooltip-left', 'tooltip-right', 'tooltip-center');
                    
                    // Smart positioning logic
                    if (markerLeft < tooltipWidth / 2) {
                        // Marker is too far left - align tooltip to left edge
                        tooltip.classList.add('tooltip-left');
                        tooltip.style.left = '0px';
                        tooltip.style.transform = 'translateX(0)';
                    } else if (markerLeft > containerWidth - tooltipWidth / 2) {
                        // Marker is too far right - align tooltip to right edge
                        tooltip.classList.add('tooltip-right');
                        tooltip.style.left = 'auto';
                        tooltip.style.right = '0px';
                        tooltip.style.transform = 'translateX(0)';
                    } else {
                        // Marker is in the middle - center tooltip normally
                        tooltip.classList.add('tooltip-center');
                        tooltip.style.left = '50%';
                        tooltip.style.right = 'auto';
                        tooltip.style.transform = 'translateX(-50%)';
                    }
                    
                    tooltip.classList.add('visible');
                }
            }
            
            console.log('Marker active state:', marker.classList.contains('active')); // Debug log
        }

        // Close marker info when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.timeline-marker')) {
                document.querySelectorAll('.timeline-marker').forEach(marker => {
                    marker.classList.remove('active');
                    const tooltip = marker.querySelector('.timeline-tooltip');
                    if (tooltip) {
                        tooltip.classList.remove('visible');
                    }
                });
            }
        });

        // --- RENDERING FUNCTIONS ---

        function renderEffortMap() {
            calculateEffortMap(); 
            
            document.getElementById('hours-per-day-display').textContent = hoursPerDay;
            document.getElementById('hours-per-day').value = hoursPerDay;

            renderTaskSizeCards();
        }
        
        function renderTaskSizeCards() {
            const container = document.getElementById('task-size-cards');
            if (!container) return;

            container.innerHTML = Object.keys(taskSizeDefinitions).map(key => {
                const size = taskSizeDefinitions[key];
                const totalHours = size.days * hoursPerDay;
                
                return `
                    <div class="task-size-card">
                        <div class="flex justify-between items-start mb-2">
                            <div class="size-label-enhanced">${size.name}</div>
                            ${size.removable ? `<button onclick="removeTaskSize('${key}')" class="text-red-300 hover:text-red-100 text-xs">‚úï</button>` : ''}
                        </div>
                        <div class="size-controls">
                            <input 
                                type="number" 
                                value="${size.days}" 
                                min="0.1" 
                                max="50"
                                step="0.5"
                                onchange="updateTaskSizeDaysEnhanced('${key}', this.value)" 
                                class="size-input-enhanced"
                            >
                            <span class="text-sm">days</span>
                        </div>
                        <div class="size-metrics">
                            <div>üìä <strong>${totalHours}h</strong> total</div>
                            <div>‚ö° ${(totalHours/hoursPerDay).toFixed(1)} person-days</div>
                            <div class="text-xs mt-1 opacity-75">Size: <strong>${key}</strong></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Update ticket size dropdown options
            updateTicketSizeDropdown();
        }
        
        function updateTaskSizeDaysEnhanced(sizeKey, newDays) {
            const days = parseFloat(newDays);
            if (isNaN(days) || days <= 0) {
                alert('Please enter a valid number of days');
                return;
            }
            
            // Backup current configuration before making changes
            backupTaskSizeDefinitions();
            
            // Update the task size definition
            taskSizeDefinitions[sizeKey].days = days;
            
            // Sync with the old ticketDays object for compatibility
            syncTaskSizes();
            
            // Recalculate effort map
            calculateEffortMap();
            
            // Re-render the task size cards to update the display
            renderTaskSizeCards();
            
            // Update projections and displays
            updateTable();
            
            // Save to localStorage
            saveData();
            
            console.log(`‚úÖ Updated ${sizeKey} to ${days} days and backed up configuration`);
        }
        
        function updateTicketSizeDropdown() {
            const dropdown = document.getElementById('new-ticket-size');
            if (!dropdown) return;
            
            dropdown.innerHTML = Object.keys(taskSizeDefinitions).map(key => {
                const size = taskSizeDefinitions[key];
                return `<option value="${key}">${size.name} (${key})</option>`;
            }).join('');
        }

        function updateAvailabilityHeader() {
            const header = document.getElementById('availability-header');
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                if (commonDate) {
                    const formattedDate = formatDate(commonDate);
                    header.textContent = `Team Availability (8 weeks from ${formattedDate})`;
                } else {
                    header.textContent = 'Team Availability (8 weeks from common start date)';
                }
            } else {
                const earliestTaskDate = getEarliestTaskStartDate();
                if (earliestTaskDate) {
                    const formattedDate = formatDate(earliestTaskDate.toISOString().split('T')[0]);
                    header.textContent = `Team Availability (8 weeks from ${formattedDate})`;
                } else {
                    header.textContent = 'Team Availability (Next 8 Weeks)';
                }
            }
        }
        
        function updateStartDateColumnHeader() {
            const header = document.getElementById('start-date-column-header');
            if (useCommonStartDate) {
                header.textContent = 'Start Date (Common)';
            } else {
                header.textContent = 'Start Date (Editable)';
            }
        }

        function renderPeople() {
            // Update the header to reflect current mode
            updateAvailabilityHeader();
            
            const peopleList = document.getElementById('people-list');
            const assignContainer = document.getElementById('new-ticket-assigned');
            peopleList.innerHTML = '';
            assignContainer.innerHTML = '';

            people.forEach((person, pIndex) => {
                const card = document.createElement('div');
                card.className = 'p-4 bg-indigo-50 rounded-lg border border-indigo-200 hover:bg-indigo-100 transition-colors';
                
                let availabilityInputs = '';
                for (let w = 0; w < 8; w++) {
                    const weekEnd = formatWeekEndDate(w);
                    availabilityInputs += `
                        <div class="flex flex-col items-center min-w-[40px]">
                            <label class="text-xs text-gray-600 mb-1">W${w+1}</label>
                            <label class="text-xs text-gray-500 mb-1">${weekEnd}</label>
                            <input 
                                type="number" 
                                value="${person.availability[w] || 0}" 
                                min="0" 
                                onchange="updatePersonAvailability('${person.name}', ${w}, this.value)" 
                                class="w-10 p-1 text-xs border border-gray-300 rounded text-center focus:border-blue-500 focus:ring-1 focus:ring-blue-200"
                            >
                        </div>
                    `;
                }

                const weekRangeInfo = useCommonStartDate ? 
                    ' (Based on common start date)' : 
                    (getEarliestTaskStartDate() ? ' (Based on earliest task start date)' : '');
                
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-3">
                        <span class="font-bold text-indigo-800 text-base">${person.name}</span>
                        <button onclick="removePerson('${person.name}')" class="text-red-500 hover:text-red-700 transition p-1 rounded hover:bg-red-50">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                    <div class="overflow-x-auto">
                        <div class="flex gap-1 text-xs min-w-max">
                            ${availabilityInputs}
                        </div>
                    </div>
                    ${weekRangeInfo ? `<div class="text-xs text-blue-600 mt-2">${weekRangeInfo}</div>` : ''}
                `;
                peopleList.appendChild(card);

                // Create checkbox for "Add New Task" form
                const checkboxWrapper = document.createElement('label');
                checkboxWrapper.className = 'flex items-center space-x-1 px-2 py-1 hover:bg-gray-100 rounded cursor-pointer';
                checkboxWrapper.innerHTML = `
                    <input type="checkbox" value="${person.name}" class="w-3 h-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500 focus:ring-1">
                    <span class="text-sm text-gray-700">${person.name}</span>
                `;
                assignContainer.appendChild(checkboxWrapper);
            });
            
            // Generate person filter buttons whenever people are updated
            generatePersonFilterButtons();
        }

        function renderTickets(projectedTickets) {
            const tbody = document.getElementById('ticket-table-body');
            tbody.innerHTML = '';
            
            // Update column header based on current mode
            updateStartDateColumnHeader();
            
            // Apply person filtering
            const filteredTickets = projectedTickets.filter(ticket => shouldShowTicket(ticket));
            
            if (filteredTickets.length === 0) {
                document.getElementById('no-tickets').classList.remove('hidden');
                // Update the no-tickets message based on whether filtering is active
                const noTicketsMsg = document.getElementById('no-tickets');
                if (selectedPersonFilters.length > 0) {
                    noTicketsMsg.textContent = `No tasks found for ${selectedPersonFilters.join(', ')}.`;
                } else {
                    noTicketsMsg.textContent = 'No tasks defined. Add a task to begin!';
                }
                return;
            }
            document.getElementById('no-tickets').classList.add('hidden');

            filteredTickets.forEach(ticket => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50';

                // Rebuild the assignment checkboxes
                const assignmentCheckboxes = people.map(p => {
                    const isChecked = ticket.assigned.includes(p.name);
                    return `
                        <label class="flex items-center space-x-1 text-xs whitespace-nowrap">
                            <input 
                                type="checkbox" 
                                value="${p.name}" 
                                ${isChecked ? 'checked' : ''}
                                onchange="handleAssignmentCheckboxChange(this, ${ticket.id})"
                                class="w-3 h-3 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500"
                            >
                            <span class="text-gray-700">${p.name}</span>
                        </label>
                    `;
                }).join('');

                // Create size dropdown options
                const sizeOptions = Object.keys(taskSizeDefinitions).map(key => {
                    const size = taskSizeDefinitions[key];
                    const isSelected = ticket.size === key;
                    return `<option value="${key}" ${isSelected ? 'selected' : ''}>${size.name} (${key})</option>`;
                }).join('');

                // Create priority dropdown options
                const priorityOptions = ['P1', 'P2', 'P3', 'P4', 'P5'].map(priority => {
                    const isSelected = (ticket.priority || 'P3') === priority;
                    return `<option value="${priority}" ${isSelected ? 'selected' : ''}>${priority}</option>`;
                }).join('');

                const completionDateClass = ticket.isDelayed ? 'bg-red-100 text-red-700 font-bold p-1 rounded' : 'text-green-600 font-semibold';
                
                // Determine displayed start date
                let displayStartDate;
                let startDateInput = '';
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    displayStartDate = formatDate(commonDate) + ' üîó';
                    startDateInput = `<span class="text-gray-500 text-sm">${displayStartDate}</span>`;
                } else {
                    startDateInput = `
                        <input 
                            type="date" 
                            value="${ticket.startDate || ''}" 
                            onchange="handleStartDateChange(this, ${ticket.id})"
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white"
                            title="Change task start date"
                        >
                    `;
                }
                
                tr.innerHTML = `
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${ticket.id}</td>
                    <td class="px-3 py-2 text-sm text-gray-900 w-1/3">${ticket.description}</td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-600">${startDateInput}</td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm font-medium">
                        <select 
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white text-indigo-600 font-medium"
                            onchange="handleSizeChange(this, ${ticket.id})"
                            title="Change task size"
                        >
                            ${sizeOptions}
                        </select>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm font-medium">
                        <select 
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white text-purple-600 font-medium"
                            onchange="handlePriorityChange(this, ${ticket.id})"
                            title="Change task priority"
                        >
                            ${priorityOptions}
                        </select>
                    </td>
                    <td class="px-3 py-2 text-sm text-gray-500 w-1/4">
                        <div class="flex flex-wrap gap-1 min-h-[40px] items-center">
                            ${assignmentCheckboxes}
                        </div>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">
                        <div class="flex items-center">
                            <span class="${completionDateClass}">${ticket.endDate}</span>
                            <button onclick="showCalculationDetails(${ticket.id})" class="details-btn" title="Show calculation details">
                                Details
                            </button>
                        </div>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button onclick="removeTicket(${ticket.id})" class="text-red-500 hover:text-red-700 transition">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        // --- CSV EXPORT FUNCTION ---

        window.exportData = () => {
            const projectedTickets = getProjectedTickets();
            if (projectedTickets.length === 0) {
                alert("No tickets to export.");
                return;
            }

            // 1. Generate the CSV content
            let csvContent = "Ticket ID,Description,Start Date,Size,Priority,Person Days,Total Hours,Assigned Team,Projected End Date,Detailed Explanation\n";

            projectedTickets.forEach(ticket => {
                const totalHours = effortMap[ticket.size] || 0;
                const personDays = taskSizeDefinitions[ticket.size]?.days || 0;

                // Escape double quotes and ensure data is wrapped in quotes
                const escapeCSV = (value) => `"${String(value).replace(/"/g, '""')}"`;

                const row = [
                    ticket.id,
                    escapeCSV(ticket.description),
                    formatDate(ticket.startDate),
                    ticket.size,
                    ticket.priority || 'P3',
                    personDays,
                    totalHours,
                    escapeCSV(ticket.assigned.join('; ')),
                    ticket.endDate.replace(/,/g, ''),
                    escapeCSV(ticket.explanation.replace(/\n/g, ' | ')) // Replace newlines for single-cell explanation
                ].join(',');
                csvContent += row + "\n";
            });

            // 2. Trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `project_schedule_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- COMPREHENSIVE CONFIGURATION EXPORT/IMPORT ---

        window.exportConfiguration = () => {
            const timestamp = new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
            
            // Create comprehensive configuration data
            const configData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    version: '2.0',
                    description: 'Enterprise Project Scheduler Configuration Export'
                },
                settings: {
                    hoursPerDay: hoursPerDay,
                    useCommonStartDate: useCommonStartDate,
                    commonStartDate: document.getElementById('common-start-date')?.value || '',
                    currentTicketId: currentTicketId
                },
                taskSizeDefinitions: taskSizeDefinitions,
                people: people,
                tickets: tickets
            };

            // Convert to CSV format with multiple sections
            let csvContent = '';
            
            // Metadata section
            csvContent += "SECTION,METADATA\n";
            csvContent += "Key,Value\n";
            csvContent += `Export Date,${configData.metadata.exportDate}\n`;
            csvContent += `Version,${configData.metadata.version}\n`;
            csvContent += `Description,${configData.metadata.description}\n`;
            csvContent += "\n";
            
            // Settings section
            csvContent += "SECTION,SETTINGS\n";
            csvContent += "Key,Value\n";
            csvContent += `Hours Per Day,${configData.settings.hoursPerDay}\n`;
            csvContent += `Use Common Start Date,${configData.settings.useCommonStartDate}\n`;
            csvContent += `Common Start Date,${configData.settings.commonStartDate}\n`;
            csvContent += `Current Ticket ID,${configData.settings.currentTicketId}\n`;
            csvContent += "\n";
            
            // Task Size Definitions section
            csvContent += "SECTION,TASK_SIZES\n";
            csvContent += "Size Key,Name,Days,Removable\n";
            Object.keys(configData.taskSizeDefinitions).forEach(key => {
                const size = configData.taskSizeDefinitions[key];
                csvContent += `${key},"${size.name}",${size.days},${size.removable}\n`;
            });
            csvContent += "\n";
            
            // People section
            csvContent += "SECTION,PEOPLE\n";
            csvContent += "Name,Week1,Week2,Week3,Week4,Week5,Week6,Week7,Week8\n";
            configData.people.forEach(person => {
                // Ensure person has 8-week availability
                const availability = [...person.availability];
                while (availability.length < 8) {
                    availability.push(25);
                }
                csvContent += `"${person.name}",${availability.slice(0, 8).join(',')}\n`;
            });
            csvContent += "\n";
            
            // Tickets section
            csvContent += "SECTION,TICKETS\n";
            csvContent += "ID,Description,Start Date,Size,Priority,Assigned Team\n";
            configData.tickets.forEach(ticket => {
                const assignedTeam = ticket.assigned.join(';');
                const priority = ticket.priority || 'P3';
                csvContent += `${ticket.id},"${ticket.description.replace(/"/g, '""')}",${ticket.startDate},${ticket.size},${priority},"${assignedTeam}"\n`;
            });
            
            // Download the configuration file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `project_config_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Show success message
            alert(`‚úÖ Configuration exported successfully!\n\nFile: project_config_${timestamp}.csv\n\nThis file contains:\n‚Ä¢ All team member configurations\n‚Ä¢ Task size definitions\n‚Ä¢ All tickets and assignments\n‚Ä¢ System settings\n\nUse "Import Config" to restore this configuration later.`);
        }

        window.triggerImport = () => {
            const fileInput = document.getElementById('import-config-file');
            fileInput.click();
        }

        window.handleConfigImport = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                alert('‚ùå Please select a CSV configuration file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    importConfiguration(csvContent);
                } catch (error) {
                    alert(`‚ùå Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input for repeated imports
            event.target.value = '';
        }

        function importConfiguration(csvContent) {
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            let currentSection = '';
            let importedData = {
                settings: {},
                taskSizeDefinitions: {},
                people: [],
                tickets: []
            };
            
            let skipHeader = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check for section headers
                if (line.startsWith('SECTION,')) {
                    currentSection = line.split(',')[1];
                    skipHeader = true;
                    continue;
                }
                
                // Skip column headers after section declaration
                if (skipHeader) {
                    skipHeader = false;
                    continue;
                }
                
                // Skip empty lines
                if (!line) continue;
                
                // Parse based on current section
                try {
                    if (currentSection === 'SETTINGS') {
                        const [key, value] = parseCSVLine(line);
                        if (key === 'Hours Per Day') importedData.settings.hoursPerDay = parseInt(value);
                        else if (key === 'Use Common Start Date') importedData.settings.useCommonStartDate = value === 'true';
                        else if (key === 'Common Start Date') importedData.settings.commonStartDate = value;
                        else if (key === 'Current Ticket ID') importedData.settings.currentTicketId = parseInt(value);
                    }
                    else if (currentSection === 'TASK_SIZES') {
                        const [sizeKey, name, days, removable] = parseCSVLine(line);
                        importedData.taskSizeDefinitions[sizeKey] = {
                            name: name,
                            days: parseFloat(days),
                            removable: removable === 'true'
                        };
                    }
                    else if (currentSection === 'PEOPLE') {
                        const parsed = parseCSVLine(line);
                        const name = parsed[0];
                        
                        // Handle both old 5-week and new 8-week format
                        const availabilityValues = parsed.slice(1).map(val => parseInt(val) || 0);
                        
                        // Ensure we have exactly 8 weeks
                        while (availabilityValues.length < 8) {
                            // If missing weeks, use the last available value or 25 as default
                            const lastValue = availabilityValues[availabilityValues.length - 1] || 25;
                            availabilityValues.push(lastValue);
                        }
                        
                        // If somehow more than 8, truncate
                        if (availabilityValues.length > 8) {
                            availabilityValues.length = 8;
                        }
                        
                        importedData.people.push({
                            name: name,
                            availability: availabilityValues
                        });
                    }
                    else if (currentSection === 'TICKETS') {
                        const [id, description, startDate, size, priority, assignedTeam] = parseCSVLine(line);
                        const assigned = assignedTeam ? assignedTeam.split(';').filter(name => name.trim()) : [];
                        importedData.tickets.push({
                            id: parseInt(id),
                            description: description,
                            startDate: startDate,
                            size: size,
                            priority: priority || 'P3',
                            assigned: assigned
                        });
                    }
                } catch (error) {
                    console.warn(`Skipping invalid line in ${currentSection}: ${line}`);
                }
            }
            
            // Validate imported data
            if (!validateImportedData(importedData)) {
                alert('‚ùå Invalid configuration file. Please check the file format and try again.');
                return;
            }
            
            // Confirm import
            const confirmMessage = `üìã Import Configuration\n\nFound:\n‚Ä¢ ${Object.keys(importedData.taskSizeDefinitions).length} task size definitions\n‚Ä¢ ${importedData.people.length} team members\n‚Ä¢ ${importedData.tickets.length} tickets\n\n‚ö†Ô∏è This will replace ALL current data!\n\nContinue with import?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Apply imported configuration
            try {
                // Apply settings
                hoursPerDay = importedData.settings.hoursPerDay || 8;
                useCommonStartDate = importedData.settings.useCommonStartDate || false;
                currentTicketId = importedData.settings.currentTicketId || 1;
                
                // Apply configurations
                console.log('üîÑ IMPORT: About to replace taskSizeDefinitions');
                console.log('üîÑ IMPORT: Current taskSizeDefinitions:', taskSizeDefinitions);
                console.log('üîÑ IMPORT: Incoming taskSizeDefinitions:', importedData.taskSizeDefinitions);
                taskSizeDefinitions = importedData.taskSizeDefinitions;
                console.log('üîÑ IMPORT: After replacement:', taskSizeDefinitions);
                people = importedData.people;
                tickets = importedData.tickets;
                
                // Reset filtering state after import
                selectedPersonFilters = [];
                
                // Update UI
                document.getElementById('hours-per-day').value = hoursPerDay;
                document.getElementById('use-common-start-date').checked = useCommonStartDate;
                if (importedData.settings.commonStartDate) {
                    document.getElementById('common-start-date').value = importedData.settings.commonStartDate;
                }
                
                // Apply common start date logic
                if (useCommonStartDate) {
                    toggleCommonStartDate();
                }
                
                // Sync and recalculate everything
                syncTaskSizes();
                calculateEffortMap();
                renderEffortMap();
                renderPeople();
                calculateProjection();
                
                // Update filter UI to ensure clean state
                updateFilterUI();
                
                saveToLocalStorage();
                
                alert(`‚úÖ Configuration imported successfully!\n\n‚Ä¢ ${Object.keys(taskSizeDefinitions).length} task sizes loaded\n‚Ä¢ ${people.length} team members configured\n‚Ä¢ ${tickets.length} tickets imported\n\nAll data has been restored and calculations updated.`);
                
            } catch (error) {
                alert(`‚ùå Error applying configuration: ${error.message}\n\nPlease check your file and try again.`);
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"' && (i === 0 || line[i-1] === ',')) {
                    inQuotes = true;
                } else if (char === '"' && inQuotes && (i === line.length - 1 || line[i+1] === ',')) {
                    inQuotes = false;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result;
        }

        function validateImportedData(data) {
            // Basic validation
            if (!data.settings || !data.taskSizeDefinitions || !data.people || !data.tickets) {
                return false;
            }
            
            // Validate people have required fields
            for (const person of data.people) {
                if (!person.name || !Array.isArray(person.availability) || person.availability.length !== 8) {
                    return false;
                }
            }
            
            // Validate tickets have required fields
            for (const ticket of data.tickets) {
                if (!ticket.id || !ticket.description || !ticket.size || !Array.isArray(ticket.assigned)) {
                    return false;
                }
            }
            
            return true;
        }

        // --- BULK TASK IMPORT ---

        window.triggerTaskImport = () => {
            const fileInput = document.getElementById('import-tasks-file');
            fileInput.click();
        }

        window.handleTaskImport = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                alert('‚ùå Please select a CSV file with tasks.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    importTasksFromCSV(csvContent);
                } catch (error) {
                    alert(`‚ùå Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input for repeated imports
            event.target.value = '';
        }

        function importTasksFromCSV(csvContent) {
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            if (lines.length === 0) {
                alert('‚ùå The CSV file appears to be empty.');
                return;
            }
            
            // Parse tasks from CSV
            const newTasks = [];
            let hasHeader = false;
            
            // Check if first line is a header (contains "task" or "description" etc.)
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('task') || firstLine.includes('description') || firstLine.includes('name')) {
                hasHeader = true;
            }
            
            const startIndex = hasHeader ? 1 : 0;
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                if (!line) continue;
                
                // Handle CSV parsing (remove quotes if present)
                let taskName = line.replace(/^"(.*)"$/, '$1').replace(/""/g, '"').trim();
                
                // Skip empty task names
                if (!taskName) continue;
                
                // Validate task name length
                if (taskName.length > 200) {
                    console.warn(`Task name too long, truncating: ${taskName.substring(0, 50)}...`);
                    taskName = taskName.substring(0, 200);
                }
                
                newTasks.push(taskName);
            }
            
            if (newTasks.length === 0) {
                alert('‚ùå No valid tasks found in the CSV file.\n\nExpected format:\n‚Ä¢ One task per line\n‚Ä¢ Optional header row\n‚Ä¢ Task names in first column');
                return;
            }
            
            // Show preview and confirm import
            const previewTasks = newTasks.slice(0, 5);
            const previewText = previewTasks.join('\n');
            const moreText = newTasks.length > 5 ? `\n... and ${newTasks.length - 5} more tasks` : '';
            
            const confirmMessage = `üìã Import ${newTasks.length} Tasks\n\nPreview:\n${previewText}${moreText}\n\n‚úÖ Default settings will be applied:\n‚Ä¢ Size: Medium (M)\n‚Ä¢ Priority: P3\n‚Ä¢ Start Date: Next Monday\n‚Ä¢ Assigned: Unassigned\n\nContinue with import?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Apply default settings for new tasks
            const defaultSize = 'M'; // Medium
            const defaultPriority = 'P3'; // Default priority
            const defaultStartDate = getNextMonday(new Date()).toISOString().split('T')[0];
            const defaultAssigned = []; // Unassigned
            
            // Add tasks to the system
            let addedCount = 0;
            let skippedCount = 0;
            
            newTasks.forEach(taskName => {
                // Check for duplicate task descriptions
                const isDuplicate = tickets.some(ticket => 
                    ticket.description.toLowerCase() === taskName.toLowerCase()
                );
                
                if (isDuplicate) {
                    skippedCount++;
                    console.warn(`Skipping duplicate task: ${taskName}`);
                    return;
                }
                
                // Add the task
                tickets.push({
                    id: currentTicketId++,
                    description: taskName,
                    startDate: defaultStartDate,
                    size: defaultSize,
                    priority: defaultPriority,
                    assigned: [...defaultAssigned]
                });
                
                addedCount++;
            });
            
            // Update the system
            if (addedCount > 0) {
                // Refresh people display if not using common start date
                if (!useCommonStartDate) {
                    renderPeople();
                }
                
                calculateProjection();
                saveToLocalStorage();
                
                // Show success message
                let message = `‚úÖ Task Import Complete!\n\n‚Ä¢ ${addedCount} tasks added successfully`;
                if (skippedCount > 0) {
                    message += `\n‚Ä¢ ${skippedCount} duplicates skipped`;
                }
                message += `\n\nüìù All tasks set to:\n‚Ä¢ Size: Medium (M)\n‚Ä¢ Priority: P3\n‚Ä¢ Start Date: ${formatDate(defaultStartDate)}\n‚Ä¢ Status: Unassigned\n\nYou can now edit individual tasks as needed.`;
                
                alert(message);
            } else {
                alert('‚ùå No tasks were added. All tasks may have been duplicates.');
            }
        }
        
        window.resetToDefaults = () => {
            if (confirm('This will reset all data to defaults with current dates. Are you sure?')) {
                localStorage.removeItem(STORAGE_KEY);
                initializeDefaultData();
                
                // Reset UI state
                useCommonStartDate = false;
                document.getElementById('use-common-start-date').checked = false;
                
                // Re-initialize
                calculateEffortMap();
                renderEffortMap();
                renderPeople();
                calculateProjection();
                
                alert('Data reset to defaults with current dates!');
            }
        }


        // --- COMMON START DATE FUNCTIONS ---
        
        window.toggleCommonStartDate = () => {
            const checkbox = document.getElementById('use-common-start-date');
            const commonDateInput = document.getElementById('common-start-date');
            const individualDateInput = document.getElementById('new-ticket-start-date');
            const startDateHelp = document.getElementById('start-date-help');
            
            useCommonStartDate = checkbox.checked;
            
            if (useCommonStartDate) {
                // Enable common start date, disable individual
                commonDateInput.disabled = false;
                commonDateInput.classList.remove('bg-gray-100');
                commonDateInput.classList.add('bg-white');
                
                // Set default to next Monday if empty
                if (!commonDateInput.value) {
                    commonDateInput.value = getDefaultTaskStartDate().toISOString().split('T')[0];
                }
                
                individualDateInput.disabled = true;
                individualDateInput.classList.add('bg-gray-100', 'text-gray-400');
                
                startDateHelp.innerHTML = 'Common start date is enabled - all tasks will use the same start date above. <strong>Team availability weeks are recalculated from this date.</strong>';
                
            } else {
                // Disable common start date, enable individual
                commonDateInput.disabled = true;
                commonDateInput.classList.add('bg-gray-100');
                commonDateInput.classList.remove('bg-white');
                
                individualDateInput.disabled = false;
                individualDateInput.classList.remove('bg-gray-100', 'text-gray-400');
                
                startDateHelp.innerHTML = 'Individual start dates enabled. <strong>Team availability weeks are calculated from the earliest task start date.</strong>';
            }
            
            // Refresh people display to show updated week dates
            renderPeople();
            
            // Recalculate projections (this will also update the table)
            calculateProjection();
            saveToLocalStorage();
        }
        
        window.updateAllTaskStartDates = () => {
            if (useCommonStartDate) {
                // Update header and refresh people display to show updated week dates
                updateAvailabilityHeader();
                renderPeople();
                
                // Recalculate when common start date changes
                calculateProjection();
                saveToLocalStorage();
            }
        }

        // --- DATA MODIFIERS (Trigger localStorage save and recalculation) ---
        
        window.updateEffortMapping = (value) => {
            const newHours = parseInt(value, 10);
            if (isNaN(newHours) || newHours < 1 || newHours > 24) return;
            
            hoursPerDay = newHours;
            
            // Update the display span
            document.getElementById('hours-per-day-display').textContent = newHours;
            
            calculateEffortMap();
            renderTaskSizeCards(); // Updated to use new function
            calculateProjection();
            saveToLocalStorage();
        }

        window.updateTicketSizeDays = (sizeKey, value) => {
            const newDays = parseInt(value, 10);
            if (isNaN(newDays) || newDays < 1) return; 

            ticketDays[sizeKey] = newDays;
            
            calculateEffortMap(); 
            renderEffortMap();
            calculateProjection();
            saveToLocalStorage();
        }
        
        // Enhanced task sizing functions
        window.updateTicketSizeDaysEnhanced = (sizeKey, value) => {
            const newDays = parseFloat(value);
            if (isNaN(newDays) || newDays < 0.1) return; 

            ticketDays[sizeKey] = newDays;
            taskSizeDefinitions[sizeKey].days = newDays;
            
            calculateEffortMap(); 
            renderTaskSizeCards();
            calculateProjection();
            saveToLocalStorage();
        }
        
        window.applyPreset = (presetName) => {
            const presets = {
                agile: {
                    XS: { name: 'Extra Small', days: 0.5, removable: true },
                    S: { name: 'Small', days: 1, removable: false },
                    M: { name: 'Medium', days: 3, removable: false },
                    L: { name: 'Large', days: 5, removable: false },
                    XL: { name: 'X-Large', days: 8, removable: false }
                },
                enterprise: {
                    S: { name: 'Small', days: 2, removable: false },
                    M: { name: 'Medium', days: 5, removable: false },
                    L: { name: 'Large', days: 10, removable: false },
                    XL: { name: 'X-Large', days: 20, removable: false },
                    XXL: { name: 'XX-Large', days: 40, removable: false }
                },
                startup: {
                    XS: { name: 'Quick Fix', days: 0.25, removable: true },
                    S: { name: 'Small', days: 1, removable: false },
                    M: { name: 'Medium', days: 2, removable: false },
                    L: { name: 'Large', days: 5, removable: false },
                    XL: { name: 'Epic', days: 10, removable: false }
                },
                conservative: {
                    S: { name: 'Small', days: 3, removable: false },
                    M: { name: 'Medium', days: 8, removable: false },
                    L: { name: 'Large', days: 15, removable: false },
                    XL: { name: 'X-Large', days: 25, removable: false },
                    XXL: { name: 'XX-Large', days: 40, removable: false }
                }
            };
            
            if (presets[presetName]) {
                if (confirm(`Apply ${presetName} preset? This will replace your current task sizes.`)) {
                    taskSizeDefinitions = { ...presets[presetName] };
                    syncTaskSizes();
                    calculateEffortMap();
                    renderTaskSizeCards();
                    calculateProjection();
                    saveToLocalStorage();
                }
            }
        }
        
        window.showCustomSizeForm = () => {
            document.getElementById('custom-size-form').classList.remove('hidden');
        }
        
        window.hideCustomSizeForm = () => {
            document.getElementById('custom-size-form').classList.add('hidden');
            // Clear form
            document.getElementById('new-size-key').value = '';
            document.getElementById('new-size-name').value = '';
            document.getElementById('new-size-days').value = '';
        }
        
        window.addCustomSize = () => {
            const key = document.getElementById('new-size-key').value.trim().toUpperCase();
            const name = document.getElementById('new-size-name').value.trim();
            const days = parseFloat(document.getElementById('new-size-days').value);
            
            if (!key || !name || isNaN(days) || days < 0.1) {
                alert('Please fill all fields with valid values.');
                return;
            }
            
            if (taskSizeDefinitions[key]) {
                alert('Size key already exists. Choose a different key.');
                return;
            }
            
            taskSizeDefinitions[key] = { name, days, removable: true };
            ticketDays[key] = days;
            
            calculateEffortMap();
            renderTaskSizeCards();
            hideCustomSizeForm();
            saveToLocalStorage();
            
            alert(`‚úÖ Added custom size: ${name} (${key}) - ${days} days`);
        }
        
        window.removeTaskSize = (sizeKey) => {
            if (!taskSizeDefinitions[sizeKey]?.removable) {
                alert('This task size cannot be removed.');
                return;
            }
            
            // Check if any tickets use this size
            const ticketsWithSize = tickets.filter(ticket => ticket.size === sizeKey);
            if (ticketsWithSize.length > 0) {
                alert(`Cannot remove size ${sizeKey}. It's used by ${ticketsWithSize.length} ticket(s).`);
                return;
            }
            
            if (confirm(`Remove task size ${sizeKey} (${taskSizeDefinitions[sizeKey].name})?`)) {
                delete taskSizeDefinitions[sizeKey];
                delete ticketDays[sizeKey];
                
                calculateEffortMap();
                renderTaskSizeCards();
                saveToLocalStorage();
            }
        }

        window.addPerson = () => {
            const nameInput = document.getElementById('new-person-name');
            const name = nameInput.value.trim();
            if (!name || people.some(p => p.name === name)) {
                // Simplified confirmation dialog for local environment
                if (name) alert("Person already exists or name is invalid.");
                return;
            }

            people.push({
                name: name,
                availability: [25, 25, 25, 25, 25, 25, 25, 25] 
            });
            
            nameInput.value = '';
            renderPeople();
            calculateProjection();
            saveToLocalStorage();
        }

        window.removePerson = (name) => {
            people = people.filter(p => p.name !== name);
            tickets.forEach(ticket => {
                ticket.assigned = ticket.assigned.filter(n => n !== name);
            });

            renderPeople();
            calculateProjection();
            saveToLocalStorage();
        }

        window.updatePersonAvailability = (name, weekIndex, value) => {
            const hours = Math.max(0, parseInt(value, 10));
            if (isNaN(hours)) return;

            const person = people.find(p => p.name === name);
            if (person) {
                person.availability[weekIndex] = hours;
                calculateProjection(); 
                saveToLocalStorage();
            }
        }

        // P1 Task Conflict Detection System
        function checkP1TaskConflicts(employeeNames, taskStartDate, taskSize, excludeTaskId = null) {
            console.log('üîç P1 Conflict Check:', { employeeNames, taskStartDate, taskSize, excludeTaskId });
            
            if (!Array.isArray(employeeNames) || employeeNames.length === 0) {
                console.log('‚ùå No employees to check or invalid input');
                return { hasConflicts: false, conflictedEmployees: [], availableEmployees: [] };
            }

            // Get fresh projection data to ensure we have current end dates
            const projectedTickets = getProjectedTickets();
            
            console.log('üìä Fresh projected tickets count:', projectedTickets.length);
            console.log('üìä Sample projected ticket:', projectedTickets[0]);
            
            // Create a temporary task to get its projected end date
            const tempTask = {
                id: -1,
                description: 'temp',
                startDate: taskStartDate,
                size: taskSize,
                priority: 'P1',
                assigned: employeeNames
            };
            
            console.log('üîß Created temp task:', tempTask);
            
            // Get projected end date for this temporary task
            const tempProjected = projectedTickets.concat([tempTask]);
            const recalculatedProjected = getProjectedTickets([tempTask]);
            let tempTaskProjected = recalculatedProjected.find(t => t.id === -1);
            
            console.log('üìà Temp task projected:', tempTaskProjected);
            
            if (!tempTaskProjected || !tempTaskProjected.rawEndDate) {
                // If we can't calculate end date, use a conservative 4-week estimate
                const estimatedEndDate = new Date(taskStartDate);
                estimatedEndDate.setDate(estimatedEndDate.getDate() + 28);
                tempTaskProjected = { rawEndDate: estimatedEndDate };
                console.log('‚ö†Ô∏è Using fallback end date calculation:', estimatedEndDate);
            }

            const newTaskStart = new Date(taskStartDate);
            const newTaskEnd = tempTaskProjected.rawEndDate;
            
            console.log('üóìÔ∏è New task date range:', {
                start: newTaskStart.toDateString(),
                end: newTaskEnd.toDateString()
            });

            const conflictedEmployees = [];
            const availableEmployees = [];

            // Check each employee for P1 conflicts
            employeeNames.forEach(employeeName => {
                console.log(`üîç Checking ${employeeName} for P1 conflicts...`);
                let hasConflict = false;
                
                // Check all existing P1 tasks for this employee
                const existingP1Tasks = tickets.filter(ticket => 
                    ticket.priority === 'P1' && 
                    ticket.assigned.includes(employeeName) &&
                    ticket.id !== excludeTaskId // Exclude current task if editing
                );
                
                console.log(`üìã Found ${existingP1Tasks.length} existing P1 tasks for ${employeeName}:`, existingP1Tasks.map(t => ({ id: t.id, desc: t.description, start: t.startDate })));

                for (const existingTask of existingP1Tasks) {
                    console.log(`üîç Checking existing task:`, { id: existingTask.id, desc: existingTask.description, start: existingTask.startDate, size: existingTask.size });
                    
                    // Get projected end date for existing task
                    const existingProjected = projectedTickets.find(pt => pt.id === existingTask.id);
                    console.log(`üìä Existing task projected:`, existingProjected);
                    console.log(`üìä Available properties:`, existingProjected ? Object.keys(existingProjected) : 'none');
                    
                    if (existingProjected && (existingProjected.rawEndDate || existingProjected.endDate)) {
                        const existingStart = new Date(existingTask.startDate);
                        const existingEndValue = existingProjected.rawEndDate || existingProjected.endDate;
                        const existingEnd = new Date(existingEndValue);

                        console.log(`üìä Date values:`, {
                            existingEndValue,
                            existingEnd,
                            isValidDate: !isNaN(existingEnd.getTime())
                        });

                        // If the projected end date is invalid, this indicates a bug in the projection system
                        if (isNaN(existingEnd.getTime()) || existingEndValue === 'N/A') {
                            console.error(`‚ùå PROJECTION SYSTEM BUG: Task ${existingTask.id} has invalid end date '${existingEndValue}'. This must be fixed!`);
                            console.log(`Task details:`, existingTask);
                            console.log(`Projected details:`, existingProjected);
                            // Skip this task for now, but log the issue
                            return;
                        }

                        // Check for date overlap
                        const hasOverlap = (newTaskStart <= existingEnd && newTaskEnd >= existingStart);
                        
                        console.log(`üìÖ Date overlap check for ${employeeName}:`, {
                            newTaskStart: newTaskStart.toDateString(),
                            newTaskEnd: newTaskEnd.toDateString(),
                            existingStart: existingStart.toDateString(),
                            existingEnd: existingEnd.toDateString(),
                            hasOverlap,
                            condition1: newTaskStart <= existingEnd,
                            condition2: newTaskEnd >= existingStart
                        });
                        
                        if (hasOverlap) {
                            console.log(`‚ö†Ô∏è CONFLICT DETECTED for ${employeeName}!`);
                            hasConflict = true;
                            if (!conflictedEmployees.find(ce => ce.name === employeeName)) {
                                conflictedEmployees.push({
                                    name: employeeName,
                                    conflictingTaskId: existingTask.id,
                                    conflictingTaskDescription: existingTask.description,
                                    conflictingTaskStart: existingTask.startDate
                                });
                            }
                            break;
                        }
                    } else {
                        console.log(`‚ùå No projected data found for existing task ${existingTask.id}, available properties:`, existingProjected ? Object.keys(existingProjected) : 'task not found');
                    }
                }

                if (!hasConflict) {
                    availableEmployees.push(employeeName);
                }
            });

            // Find all employees who are not selected but have no P1 conflicts
            const allEmployees = people.map(p => p.name);
            const unselectedEmployees = allEmployees.filter(name => !employeeNames.includes(name));
            
            unselectedEmployees.forEach(employeeName => {
                let hasConflict = false;
                
                const existingP1Tasks = tickets.filter(ticket => 
                    ticket.priority === 'P1' && 
                    ticket.assigned.includes(employeeName) &&
                    ticket.id !== excludeTaskId
                );

                for (const existingTask of existingP1Tasks) {
                    const existingProjected = projectedTickets.find(pt => pt.id === existingTask.id);
                    if (existingProjected && existingProjected.rawEndDate) {
                        const existingStart = new Date(existingTask.startDate);
                        const existingEnd = existingProjected.rawEndDate;
                        const hasOverlap = (newTaskStart <= existingEnd && newTaskEnd >= existingStart);
                        
                        if (hasOverlap) {
                            hasConflict = true;
                            break;
                        }
                    }
                }

                if (!hasConflict) {
                    availableEmployees.push(employeeName);
                }
            });

            const result = {
                hasConflicts: conflictedEmployees.length > 0,
                conflictedEmployees: conflictedEmployees,
                availableEmployees: availableEmployees
            };
            
            console.log('‚úÖ P1 Conflict Check Result:', result);
            
            return result;
        }

        function showP1ConflictWarning(conflictResult) {
            const conflictedNames = conflictResult.conflictedEmployees.map(ce => ce.name);
            const availableNames = conflictResult.availableEmployees;
            
            let message = '';
            
            if (conflictedNames.length === 1) {
                const conflict = conflictResult.conflictedEmployees[0];
                message = `Employee ${conflictedNames[0]} already has another P1 task assigned ("${conflict.conflictingTaskDescription}") starting ${formatDate(conflict.conflictingTaskStart)}.`;
            } else {
                const conflictDetails = conflictResult.conflictedEmployees.map(ce => 
                    `${ce.name} ("${ce.conflictingTaskDescription}" from ${formatDate(ce.conflictingTaskStart)})`
                ).join(', ');
                message = `Employees ${conflictDetails} already have other P1 tasks assigned.`;
            }
            
            if (availableNames.length > 0) {
                message += `\n\nFollowing employees have no P1 tasks against them during this period - ${availableNames.join(', ')}. You can pick any of them.`;
            } else {
                message += `\n\nNo employees are available for P1 tasks during this period.`;
            }
            
            message += `\n\n‚ö†Ô∏è Do you want to proceed anyway? This person will have multiple P1 tasks during overlapping periods.`;
            
            // Use confirm() instead of alert() to provide OK/Cancel options
            return confirm(message);
        }

        window.addTicket = () => {
            const descInput = document.getElementById('new-ticket-desc');
            const startDateInput = document.getElementById('new-ticket-start-date');
            const sizeSelect = document.getElementById('new-ticket-size');
            const prioritySelect = document.getElementById('new-ticket-priority');
            const assignedContainer = document.getElementById('new-ticket-assigned');

            const description = descInput.value.trim();
            
            // Handle start date based on common start date setting
            let startDate;
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date').value;
                startDate = commonDate || getDefaultTaskStartDate().toISOString().split('T')[0];
            } else {
                startDate = startDateInput.value || getDefaultTaskStartDate().toISOString().split('T')[0];
            }
            
            const size = sizeSelect.value;
            const priority = prioritySelect.value;
            const assigned = Array.from(assignedContainer.querySelectorAll('input[type="checkbox"]:checked')).map(checkbox => checkbox.value);

            if (!description) {
                alert("Ticket description cannot be empty.");
                return;
            }

            // Check for P1 task conflicts if this is a P1 task with assigned employees
            if (priority === 'P1' && assigned.length > 0) {
                const conflictResult = checkP1TaskConflicts(assigned, startDate, size);
                if (conflictResult.hasConflicts) {
                    const userWantsToProceed = showP1ConflictWarning(conflictResult);
                    if (!userWantsToProceed) {
                        // User clicked Cancel, abort the task creation
                        return;
                    }
                    // User clicked OK, continue with task creation
                }
            }

            tickets.push({
                id: currentTicketId++,
                description: description,
                startDate: startDate,
                size: size,
                priority: priority,
                assigned: assigned
            });

            descInput.value = '';
            startDateInput.value = '';
            sizeSelect.value = 'L';
            prioritySelect.value = 'P3'; // Reset to default priority
            // Clear all checkboxes
            assignedContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);

            // Refresh people display since earliest task date might have changed
            if (!useCommonStartDate) {
                renderPeople();
            }
            
            calculateProjection();
            saveToLocalStorage();
        }

        window.removeTicket = (id) => {
            tickets = tickets.filter(t => t.id !== id);
            
            // Refresh people display since earliest task date might have changed
            if (!useCommonStartDate) {
                renderPeople();
            }
            
            calculateProjection();
            saveToLocalStorage();
        }

        window.updateTicketAssignment = (id, newAssignedArray) => {
            const ticket = tickets.find(t => t.id === id);
            if (ticket) {
                ticket.assigned = newAssignedArray;
                calculateProjection();
                saveToLocalStorage();
            }
        }
        
        window.handleAssignmentChange = (selectElement, ticketId) => {
            const newAssignedArray = Array.from(selectElement.selectedOptions).map(o => o.value);
            window.updateTicketAssignment(ticketId, newAssignedArray);
        }

        window.handleAssignmentCheckboxChange = (checkboxElement, ticketId) => {
            const personName = checkboxElement.value;
            const isChecked = checkboxElement.checked;
            
            // Find the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            // Check for P1 conflicts if this is a P1 task and person is being assigned
            if (isChecked && ticket.priority === 'P1') {
                console.log('üîç Checkbox P1 check triggered for:', { personName, ticketId, priority: ticket.priority });
                const conflictResult = checkP1TaskConflicts([personName], ticket.startDate, ticket.size, ticketId);
                if (conflictResult.hasConflicts) {
                    console.log('‚ö†Ô∏è P1 conflicts found, showing warning...');
                    const userWantsToProceed = showP1ConflictWarning(conflictResult);
                    if (!userWantsToProceed) {
                        // User clicked Cancel, revert the checkbox state
                        checkboxElement.checked = false;
                        return;
                    }
                    // User clicked OK, continue with assignment
                } else {
                    console.log('‚úÖ No P1 conflicts found');
                }
            }
            
            // Update the assignment array
            if (isChecked) {
                // Add person if not already assigned
                if (!ticket.assigned.includes(personName)) {
                    ticket.assigned.push(personName);
                }
            } else {
                // Remove person from assignment
                ticket.assigned = ticket.assigned.filter(name => name !== personName);
            }
            
            // Provide visual feedback
            checkboxElement.parentElement.style.background = '#dcfce7'; // Light green background
            setTimeout(() => {
                checkboxElement.parentElement.style.background = 'transparent';
            }, 500);
            
            // Recalculate and re-render immediately
            calculateProjection();
            saveToLocalStorage();
        }

        window.handleSizeChange = (selectElement, ticketId) => {
            const newSize = selectElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldSize = ticket.size;
                ticket.size = newSize;
                
                // Provide visual feedback
                selectElement.style.background = '#dcfce7'; // Light green background
                setTimeout(() => {
                    selectElement.style.background = 'white';
                }, 500);
                
                // Recalculate and re-render immediately
                calculateProjection();
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`üìä Ticket #${ticketId} size changed from ${oldSize} to ${newSize} - recalculating...`);
            }
        }

        window.handlePriorityChange = (selectElement, ticketId) => {
            const newPriority = selectElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldPriority = ticket.priority || 'P3';
                
                // Check for P1 conflicts if changing to P1 priority and ticket has assignments
                if (newPriority === 'P1' && ticket.assigned.length > 0) {
                    console.log('üîç Priority change P1 check triggered for:', { ticketId, assigned: ticket.assigned });
                    const conflictResult = checkP1TaskConflicts(ticket.assigned, ticket.startDate, ticket.size, ticketId);
                    if (conflictResult.hasConflicts) {
                        console.log('‚ö†Ô∏è P1 conflicts found during priority change, showing warning...');
                        const userWantsToProceed = showP1ConflictWarning(conflictResult);
                        if (!userWantsToProceed) {
                            // User clicked Cancel, revert the priority change
                            selectElement.value = oldPriority;
                            return;
                        }
                        // User clicked OK, continue with priority change
                    } else {
                        console.log('‚úÖ No P1 conflicts found during priority change');
                    }
                }
                
                ticket.priority = newPriority;
                
                // Provide visual feedback
                selectElement.style.background = '#e0e7ff'; // Light purple background
                setTimeout(() => {
                    selectElement.style.background = 'white';
                }, 500);
                
                // Save to storage (no need to recalculate as priority doesn't affect timeline)
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`‚≠ê Ticket #${ticketId} priority changed from ${oldPriority} to ${newPriority}`);
            }
        }

        window.handleStartDateChange = (inputElement, ticketId) => {
            const newStartDate = inputElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldStartDate = ticket.startDate;
                ticket.startDate = newStartDate;
                
                // Provide visual feedback
                inputElement.style.background = '#dcfce7'; // Light green background
                setTimeout(() => {
                    inputElement.style.background = 'white';
                }, 500);
                
                // Refresh people display since earliest task date might have changed
                if (!useCommonStartDate) {
                    renderPeople();
                }
                
                // Recalculate and re-render immediately
                calculateProjection();
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`üìÖ Ticket #${ticketId} start date changed from ${formatDate(oldStartDate)} to ${formatDate(newStartDate)} - recalculating...`);
            }
        }

        // --- CALCULATION DETAILS MODAL FUNCTIONS ---

        window.showCalculationDetails = (ticketId) => {
            // Find the ticket and get its calculation details
            const projectedTickets = getProjectedTickets();
            const ticket = projectedTickets.find(t => t.id === ticketId);
            
            if (!ticket) {
                alert('Ticket not found.');
                return;
            }
            
            // Create enhanced content with better formatting
            const enhancedContent = `
üéØ TICKET: ${ticket.description} (ID: ${ticket.id})
üìä SIZE: ${ticket.size} 
üìÖ START DATE: ${formatDate(ticket.startDate)}
üë• ASSIGNED TO: ${ticket.assigned.join(', ')}
üéå PROJECTED END: ${ticket.endDate}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

${ticket.explanation}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üí° HOW TO READ this calculation:
‚Ä¢ Week numbers correspond to the planning horizon (8 weeks total)
‚Ä¢ Pooled Capacity = combined hours available from all assigned team members
‚Ä¢ Hours are distributed proportionally based on each person's availability
‚Ä¢ Task completes when all required hours are allocated
‚Ä¢ Any capacity constraints or delays are noted in the weekly breakdown
            `.trim();
            
            // Update modal content
            document.getElementById('modal-title').textContent = `üìä Calculation Details - Ticket #${ticket.id}`;
            document.getElementById('calculation-content').textContent = enhancedContent;
            
            // Show modal
            const modal = document.getElementById('calculation-modal');
            modal.classList.add('active');
            
            // Add event listener for clicking outside modal to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeCalculationModal();
                }
            });
        }

        window.closeCalculationModal = () => {
            const modal = document.getElementById('calculation-modal');
            modal.classList.remove('active');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeCalculationModal();
            }
        });


        // --- INITIALIZATION ---

        function initializeDefaultData() {
            console.log("Setting up default people data.");
            people = [
                { name: 'Vipul', availability: [25, 25, 25, 25, 25, 25, 25, 25] },
                { name: 'Sameet', availability: [25, 25, 25, 25, 25, 25, 25, 25] },
                { name: 'Peter', availability: [25, 25, 25, 25, 25, 25, 25, 25] },
                { name: 'Sharanya', availability: [25, 25, 25, 25, 25, 25, 25, 25] },
                { name: 'Divya', availability: [25, 25, 25, 25, 25, 25, 25, 25] },
            ];
            
            // Use realistic current dates
            const today = new Date();
            const nextMonday = getNextMonday(new Date());
            const followingMonday = new Date(nextMonday.getTime() + 7 * 24 * 60 * 60 * 1000);
            
            tickets = [
                { id: 1, description: 'Design System Migration', size: 'XL', priority: 'P1', assigned: ['Vipul', 'Peter'], startDate: nextMonday.toISOString().split('T')[0] },
                { id: 2, description: 'Fix payment gateway bug', size: 'S', priority: 'P2', assigned: ['Sameet'], startDate: nextMonday.toISOString().split('T')[0] },
                { id: 3, description: 'Build new reporting dashboard', size: 'XXL', priority: 'P3', assigned: ['Sharanya', 'Divya'], startDate: followingMonday.toISOString().split('T')[0] }
            ];
            currentTicketId = 4;
            saveToLocalStorage(); 
        }

        function initializeScheduler() {
            if (!loadFromLocalStorage()) {
                initializeDefaultData();
            }
            
            // Migration: Add priority to existing tasks that don't have it
            let migrationNeeded = false;
            tickets.forEach(ticket => {
                if (!ticket.priority) {
                    ticket.priority = 'P3'; // Default priority
                    migrationNeeded = true;
                }
            });
            
            if (migrationNeeded) {
                saveToLocalStorage();
                console.log('üìä Migrated existing tasks to include priority field');
            }
            
            // Set default start date to a sensible default
            const defaultStartDate = getDefaultTaskStartDate().toISOString().split('T')[0];
            document.getElementById('new-ticket-start-date').value = defaultStartDate;
            document.getElementById('common-start-date').value = defaultStartDate;
            
            // Restore common start date state
            const checkbox = document.getElementById('use-common-start-date');
            checkbox.checked = useCommonStartDate;
            if (useCommonStartDate) {
                toggleCommonStartDate();
            }
            
            // Initial render
            calculateEffortMap();
            renderEffortMap();
            renderPeople();
            calculateProjection(); // This now includes timeline rendering
            
            // Initialize UI components
            updateTicketSizeDropdown(); // Populate the task size dropdown
            updateFilterUI();
            
            // Update hours per day display and input
            document.getElementById('hours-per-day').value = hoursPerDay;
            document.getElementById('hours-per-day-display').textContent = hoursPerDay;
        }

        // --- TEAM WORKLOAD HEAT MAP ---
        function calculateWorkloadHeatMap() {
            const projectedTickets = getProjectedTickets();
            const heatMapData = [];
            
            // Get the start date for the heat map (earliest task or today)
            let startDate = new Date();
            if (projectedTickets.length > 0) {
                const earliestTask = projectedTickets.reduce((earliest, task) => 
                    new Date(task.startDate) < new Date(earliest.startDate) ? task : earliest
                );
                startDate = new Date(earliestTask.startDate);
            }
            
            // Ensure we start from a Monday
            while (startDate.getDay() !== 1) {
                startDate.setDate(startDate.getDate() - 1);
            }
            
            // Calculate for each person
            people.forEach(person => {
                const personData = {
                    name: person.name,
                    weeks: []
                };
                
                // Calculate for next 8 weeks
                for (let weekIndex = 0; weekIndex < 8; weekIndex++) {
                    const weekStart = new Date(startDate);
                    weekStart.setDate(startDate.getDate() + (weekIndex * 7));
                    
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekStart.getDate() + 6);
                    
                    // Get person's availability for this week
                    const availability = person.availability && person.availability[weekIndex] !== undefined 
                        ? person.availability[weekIndex] 
                        : hoursPerDay * 5; // Default to full week if not defined
                    
                    // Calculate assigned hours for this week
                    let assignedHours = 0;
                    
                    projectedTickets.forEach(ticket => {
                        if (ticket.assigned.includes(person.name)) {
                            const taskStart = new Date(ticket.startDate);
                            const taskEnd = ticket.rawEndDate ? new Date(ticket.rawEndDate) : new Date(taskStart);
                            
                            // Check if task overlaps with this week
                            if (taskStart <= weekEnd && taskEnd >= weekStart) {
                                // Calculate overlap period
                                const overlapStart = new Date(Math.max(taskStart.getTime(), weekStart.getTime()));
                                const overlapEnd = new Date(Math.min(taskEnd.getTime(), weekEnd.getTime()));
                                
                                // Calculate business days in overlap period
                                let businessDays = 0;
                                const currentDate = new Date(overlapStart);
                                while (currentDate <= overlapEnd) {
                                    const dayOfWeek = currentDate.getDay();
                                    if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                                        businessDays++;
                                    }
                                    currentDate.setDate(currentDate.getDate() + 1);
                                }
                                
                                // Calculate hours for this person for this task
                                const totalTaskDays = taskSizeDefinitions[ticket.size]?.days || ticketDays[ticket.size] || 1;
                                const hoursPerTaskDay = hoursPerDay;
                                const totalTaskHours = totalTaskDays * hoursPerTaskDay;
                                const hoursPerAssignee = totalTaskHours / Math.max(ticket.assigned.length, 1); // Prevent division by zero
                                
                                // Distribute hours across task duration
                                const taskBusinessDays = Math.max(calculateBusinessDays(taskStart, taskEnd), 1); // Prevent division by zero
                                const dailyHours = hoursPerAssignee / taskBusinessDays;
                                
                                // Ensure we have valid numbers
                                if (!isNaN(dailyHours) && !isNaN(businessDays)) {
                                    assignedHours += dailyHours * businessDays;
                                }
                            }
                        }
                    });
                    
                    // Calculate utilization percentage with proper error handling
                    let utilization = 0;
                    if (availability > 0 && !isNaN(assignedHours) && !isNaN(availability)) {
                        utilization = Math.round((assignedHours / availability) * 100);
                    } else if (assignedHours > 0 && availability === 0) {
                        utilization = 999; // Indicate overload when no capacity but has assignments
                    }
                    
                    // Ensure utilization is a valid number
                    if (isNaN(utilization) || !isFinite(utilization)) {
                        utilization = 0;
                    }
                    
                    // Determine color based on utilization
                    let colorClass = 'bg-green-100 border-green-300 text-green-800';
                    if (utilization === 999 || utilization > 90) {
                        colorClass = 'bg-red-100 border-red-300 text-red-800';
                    } else if (utilization > 60) {
                        colorClass = 'bg-yellow-100 border-yellow-300 text-yellow-800';
                    }
                    
                    personData.weeks.push({
                        weekIndex: weekIndex + 1,
                        weekStart: formatDate(weekStart),
                        weekEnd: formatDate(weekEnd),
                        availability: availability,
                        assignedHours: Math.round(assignedHours * 10) / 10,
                        utilization: utilization,
                        colorClass: colorClass
                    });
                }
                
                heatMapData.push(personData);
            });
            
            return heatMapData;
        }
        
        function calculateBusinessDays(startDate, endDate) {
            let businessDays = 0;
            const currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                const dayOfWeek = currentDate.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                    businessDays++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }
            return businessDays;
        }
        
        function addBusinessDays(startDate, businessDaysToAdd) {
            const result = new Date(startDate);
            let daysAdded = 0;
            
            while (daysAdded < businessDaysToAdd) {
                result.setDate(result.getDate() + 1);
                const dayOfWeek = result.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                    daysAdded++;
                }
            }
            
            return result;
        }
        
        function getNextBusinessDay(date) {
            const result = new Date(date);
            const dayOfWeek = result.getDay();
            
            if (dayOfWeek === 0) { // Sunday
                result.setDate(result.getDate() + 1); // Move to Monday
            } else if (dayOfWeek === 6) { // Saturday
                result.setDate(result.getDate() + 2); // Move to Monday
            }
            
            return result;
        }
        
        function renderWorkloadHeatMap() {
            const heatMapData = calculateWorkloadHeatMap();
            const container = document.getElementById('workload-heatmap');
            
            if (heatMapData.length === 0) {
                container.innerHTML = '<p class="text-center py-4 text-gray-500">No team members defined. Add team members to see workload heat map.</p>';
                return;
            }
            
            // Create table
            let html = '<table class="w-full border-collapse">';
            
            // Header row
            html += '<thead><tr class="bg-gray-50">';
            html += '<th class="border border-gray-300 px-3 py-2 text-left font-semibold">Team Member</th>';
            for (let i = 1; i <= 8; i++) {
                html += `<th class="border border-gray-300 px-3 py-2 text-center font-semibold">Week ${i}</th>`;
            }
            html += '</tr></thead>';
            
            // Data rows
            html += '<tbody>';
            heatMapData.forEach(person => {
                html += '<tr>';
                html += `<td class="border border-gray-300 px-3 py-2 font-medium">${person.name}</td>`;
                
                person.weeks.forEach(week => {
                    const tooltip = `Week ${week.weekIndex} (${week.weekStart} - ${week.weekEnd})\\nAvailable: ${week.availability}h\\nAssigned: ${week.assignedHours}h\\nUtilization: ${week.utilization === 999 ? 'Overloaded' : week.utilization + '%'}`;
                    
                    // Format display value
                    const displayValue = week.utilization === 999 ? 'OVR' : `${week.utilization}%`;
                    
                    html += `<td class="border border-gray-300 p-1">
                        <div class="${week.colorClass} rounded px-2 py-1 text-center text-sm font-medium cursor-help"
                             title="${tooltip}">
                            ${displayValue}
                        </div>
                    </td>`;
                });
                
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }

        // Start the application
        window.onload = initializeScheduler;
    </script>
</body>
</html>
