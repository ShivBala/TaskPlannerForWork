<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise Project Scheduler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Banking/Enterprise Theme */
        :root {
            --primary-color: #1e3a8a; /* Deep blue */
            --secondary-color: #374151; /* Dark gray */
            --accent-color: #059669; /* Professional green */
            --warning-color: #d97706; /* Amber */
            --danger-color: #dc2626; /* Red */
            --background-color: #f8fafc; /* Light gray */
            --card-background: #ffffff;
            --border-color: #e5e7eb;
        }
        
        /* Custom styles for enterprise feel */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            color: var(--secondary-color);
        }
        
        .enterprise-container {
            max-width: 1600px;
        }
        
        .input-card, .output-card {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }
        
        .input-card:hover, .output-card:hover {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        }
        
        .enterprise-header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            border-bottom: 3px solid var(--accent-color);
        }
        
        /* Compact Enterprise Task Sizing */
        .task-size-manager {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .task-size-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .task-size-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .size-input-enhanced {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--secondary-color);
            font-weight: 600;
            text-align: center;
            width: 70px;
            font-size: 11px;
        }
        
        .size-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .size-label-enhanced {
            font-weight: bold;
            font-size: 12px;
            min-width: 50px;
        }
        
        .size-metrics {
            font-size: 10px;
            opacity: 0.9;
            margin-top: 3px;
        }
        
        .preset-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .custom-size-form {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
        }
        
        /* Enterprise Timeline Styles */
        .timeline-container {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
        }
        
        /* Modal Styles for Banking */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(30, 58, 138, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--card-background);
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            margin: 20px;
            width: calc(100% - 40px);
            border: 2px solid var(--primary-color);
        }
        
        @media (min-width: 640px) {
            .modal-content {
                width: auto;
                margin: 0;
            }
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        
        .modal-header {
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 12px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .modal-close:hover {
            background-color: #f3f4f6;
        }
        
        .calculation-details {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            background: #f8fafc;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
            max-height: 350px;
            overflow-y: auto;
        }
        
        .details-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            margin-left: 6px;
            transition: background-color 0.2s;
        }
        
        .details-btn:hover {
            background: #1e40af;
        }
        
        /* Size Dropdown Banking Style */
        .size-dropdown {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 11px;
            font-weight: 600;
            color: var(--primary-color);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            min-width: 70px;
        }
        
        .size-dropdown:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 1px var(--primary-color);
        }
        
        .size-dropdown:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(30, 58, 138, 0.2);
        }
        
        .size-dropdown option {
            padding: 3px;
            font-weight: normal;
        }
        
        /* Timeline Styles */
        .timeline-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 1px;
        }
        
        .timeline-marker::after {
            content: attr(data-label);
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .timeline-marker:hover::after {
            opacity: 1;
        }
        
        .timeline-delayed {
            background: linear-gradient(45deg, var(--danger-color) 0%, #b91c1c 100%);
        }
        
        .timeline-ontime {
            background: linear-gradient(45deg, var(--accent-color) 0%, #047857 100%);
        }
        
        .timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 11px;
        }
        
        .timeline-legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        
        .tooltip-container {
            position: relative;
            cursor: pointer;
        }
        
        .tooltip-text {
            visibility: hidden;
            width: 280px;
            background-color: var(--secondary-color);
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -140px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            pointer-events: none;
            white-space: pre-wrap;
        }
        
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Select dropdowns */
        .select-multiple {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%236b7280'%3e%3cpath d='M7 7l3-3 3 3m0 6l-3 3-3-3' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em;
        }
        
        /* Compact spacing */
        .compact-spacing {
            gap: 12px;
        }
        
        .compact-card {
            padding: 12px;
        }
        
        /* Enterprise buttons */
        .btn-enterprise {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        
        .btn-enterprise:hover {
            background: #1e40af;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .btn-secondary {
            background: var(--secondary-color);
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }
        
        .btn-success {
            background: var(--accent-color);
        }
        
        .btn-success:hover {
            background: #047857;
        }
        
        .btn-danger {
            background: var(--danger-color);
        }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        /* Compact table styles */
        .enterprise-table {
            font-size: 12px;
        }
        
        .enterprise-table th {
            padding: 8px 12px;
            background: var(--primary-color);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }
        
        .enterprise-table td {
            padding: 6px 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .enterprise-table tr:hover {
            background: rgba(30, 58, 138, 0.03);
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="enterprise-container mx-auto">
        <div class="enterprise-header flex justify-between items-center mb-4 p-4 rounded-lg">
            <h1 class="text-2xl font-bold">Enterprise Project Delivery Console</h1>
            <div class="flex gap-2">
                <button onclick="exportConfiguration()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                    Export Config
                </button>
                <button onclick="triggerImport()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                    </svg>
                    Import Config
                </button>
                <button onclick="triggerTaskImport()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Import Tasks
                </button>
                <button onclick="exportData()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Export Schedule
                </button>
                <button onclick="resetToDefaults()" class="btn-danger flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Reset
                </button>
            </div>
        </div>
        
        <p id="auth-status" class="text-xs text-gray-600 mb-3">📊 Enterprise data management - All information stored securely in browser storage.</p>
        
        <!-- Hidden file input for configuration import -->
        <input type="file" id="import-config-file" accept=".csv" style="display: none;" onchange="handleConfigImport(event)">
        
        <!-- Hidden file input for task bulk import -->
        <input type="file" id="import-tasks-file" accept=".csv" style="display: none;" onchange="handleTaskImport(event)">
        
        <div id="loading-spinner" class="text-center p-10 hidden">
            <!-- Spinner removed as local loading is instant -->
        </div>

        <div id="main-content" class="grid lg:grid-cols-3 gap-6 mb-8">
            
            <!-- People and Availability Configuration -->
            <div class="lg:col-span-1 input-card enterprise-table p-4 rounded-lg h-full">
                <h2 class="text-lg font-semibold mb-3 text-primary-dark flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20v-2c0-.656-.126-1.283-.356-1.857M17 20H7m0 0v-2c0-.656.126-1.283.356-1.857M7 20h4m0-9a3 3 0 100 6 3 3 0 000-6zm-4 3a2 2 0 11-4 0 2 2 0 014 0zm10 0a2 2 0 11-4 0 2 2 0 014 0zm7-3a2 2 0 11-4 0 2 2 0 014 0z" />
                    </svg>
                    <span id="availability-header">Team Resources (5 Weeks)</span>
                </h2>
                <div id="people-list" class="compact-spacing">
                    <!-- People cards will be rendered here -->
                </div>
                <div class="mt-3 compact-spacing">
                    <input type="text" id="new-person-name" placeholder="Team member name" class="enterprise-input w-full">
                    <button onclick="addPerson()" class="btn-enterprise w-full mt-2">Add Member</button>
                </div>
            </div>

            <!-- Effort Mapping and Control -->
            <div class="lg:col-span-2 input-card enterprise-table p-4 rounded-lg">
                
                <!-- Enhanced Task Sizing Management -->
                <div class="task-size-manager">
                    <h2 class="text-lg font-bold mb-3 flex items-center text-primary-dark">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        📏 Task Configuration
                    </h2>
                    
                    <div class="compact-spacing">
                        <div class="mb-3 flex items-center gap-4 flex-wrap">
                            <div class="flex items-center gap-2">
                                <label class="text-sm font-medium">Hours/Day:</label>
                                <input type="number" id="hours-per-day" value="8" min="1" max="24" 
                                       onchange="updateEffortMapping(event.target.value)" 
                                       class="enterprise-input w-16">
                            </div>
                            <div class="text-sm text-gray-600">
                                Total = Days × <span id="hours-per-day-display">8</span>h
                            </div>
                        </div>
                        
                        <div id="task-size-cards" class="grid md:grid-cols-3 lg:grid-cols-5 gap-2 mb-3">
                            <!-- Enhanced task size cards will be rendered here -->
                        </div>
                        
                        <div class="flex gap-2 mb-3 flex-wrap text-xs">
                            <button onclick="applyPreset('agile')" class="btn-enterprise">🏃 Agile</button>
                            <button onclick="applyPreset('enterprise')" class="btn-enterprise">🏢 Enterprise</button>
                            <button onclick="applyPreset('startup')" class="btn-enterprise">🚀 Startup</button>
                            <button onclick="applyPreset('conservative')" class="btn-enterprise">🛡️ Conservative</button>
                            <button onclick="showCustomSizeForm()" class="btn-enterprise">➕ Custom</button>
                        </div>
                        
                        <div id="custom-size-form" class="custom-size-form hidden">
                            <h4 class="font-semibold mb-2 text-sm">Add Custom Task Size</h4>
                            <div class="flex gap-2 items-end flex-wrap">
                                <div>
                                    <label class="block text-xs mb-1">Key</label>
                                    <input type="text" id="new-size-key" placeholder="XS" maxlength="4" 
                                           class="enterprise-input w-16">
                                </div>
                                <div>
                                    <label class="block text-xs mb-1">Name</label>
                                    <input type="text" id="new-size-name" placeholder="Extra Small" 
                                           class="enterprise-input w-24">
                                </div>
                                <div>
                                    <label class="block text-xs mb-1">Days</label>
                                    <input type="number" id="new-size-days" placeholder="0.5" min="0.1" max="50" step="0.5" 
                                           class="enterprise-input w-16">
                                </div>
                                <button onclick="addCustomSize()" class="btn-enterprise">Add</button>
                                <button onclick="hideCustomSizeForm()" class="btn-danger">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Visual Timeline Display -->
                <div class="mt-4 p-3 enterprise-timeline border rounded-lg">
                    <h3 class="text-md font-semibold mb-2 text-primary-dark flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        📈 Project Timeline
                    </h3>
                    <div id="timeline-container" class="relative">
                        <div id="timeline-info" class="text-sm text-gray-600 mb-2">
                            📅 <span id="timeline-start-date">No tasks defined</span> → 
                            🏁 <span id="timeline-end-date">No tasks defined</span> 
                            (<span id="timeline-duration">0 days</span>)
                        </div>
                        <div id="timeline-bar" class="relative bg-gray-200 h-6 rounded-lg overflow-hidden">
                            <div id="timeline-progress" class="h-full bg-gradient-to-r from-blue-400 to-green-400 transition-all duration-500" style="width: 0%"></div>
                            <div id="timeline-markers" class="absolute inset-0 flex items-center px-2">
                                <!-- Task markers will be populated here -->
                            </div>
                        </div>
                        <div id="timeline-legend" class="flex flex-wrap gap-2 mt-2 text-xs">
                            <!-- Legend items will be populated here -->
                        </div>
                    </div>
                </div>
                
                <h2 class="text-lg font-semibold mb-3 text-primary-dark flex items-center mt-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Task Management
                </h2>

                <!-- Common Start Date Control -->
                <div class="mb-4 p-3 enterprise-card border rounded-lg">
                    <div class="flex items-center gap-4 mb-2">
                        <label class="flex items-center cursor-pointer">
                            <input type="checkbox" id="use-common-start-date" onchange="toggleCommonStartDate()" 
                                   class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            <span class="ml-2 text-sm font-medium text-primary-dark">📅 Unified Start Date</span>
                        </label>
                        <input type="date" id="common-start-date" disabled 
                               class="enterprise-input text-sm" 
                               title="Common start date for all tasks"
                               onchange="updateAllTaskStartDates()">
                    </div>
                    <div class="text-xs text-gray-600">
                        💡 Synchronizes all task start dates for streamlined project planning
                    </div>
                </div>

                <div class="mt-4">
                    <h3 class="font-semibold text-md mb-2">Add New Task</h3>
                    <div class="compact-spacing">
                        <div class="flex flex-col md:flex-row gap-2">
                            <input type="text" id="new-ticket-desc" placeholder="Task Description" class="enterprise-input flex-grow">
                            <input type="date" id="new-ticket-start-date" class="enterprise-input w-full md:w-36" title="Start Date">
                            <select id="new-ticket-size" class="enterprise-input w-full md:w-32">
                                <!-- Options populated dynamically by JavaScript -->
                            </select>
                            <select id="new-ticket-assigned" multiple class="enterprise-input w-full md:w-48 min-h-[35px]">
                                <!-- Options populated by JS -->
                            </select>
                            <button onclick="addTicket()" class="btn-enterprise w-full md:w-20 flex-shrink-0">Add</button>
                        </div>
                        <div class="text-xs text-gray-500 mt-1">
                            💡 <span id="start-date-help">Individual start dates enabled. Team availability calculated from earliest task.</span>
                        </div>
                    </div>
                </div>
                
                <!-- Task List and Projection -->
                <div class="mt-4">
                    <h3 class="text-lg font-semibold mb-2 text-primary-dark">Task Schedule</h3>
                    <div class="overflow-x-auto rounded-lg border">
                        <table class="enterprise-table min-w-full divide-y">
                            <thead>
                                <tr>
                                    <th class="px-2 py-2 text-left">ID</th>
                                    <th class="px-2 py-2 text-left">Description</th>
                                    <th class="px-2 py-2 text-left">
                                        <span id="start-date-column-header">Start Date</span>
                                    </th>
                                    <th class="px-2 py-2 text-left">Size</th>
                                    <th class="px-2 py-2 text-left">Assigned</th>
                                    <th class="px-2 py-2 text-left tooltip-container">End Date
                                        <div class="tooltip-text">
                                            Calculated from start date, team availability, and effort hours.
                                        </div>
                                    </th>
                                    <th class="px-2 py-2 text-left">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="ticket-table-body" class="divide-y">
                                <!-- Tickets will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                    <p id="no-tickets" class="text-center py-3 text-gray-500 hidden">No tasks defined. Add a task to begin!</p>
                </div>
            </div>
        </div>
        
    </div>

    <!-- Modal for Calculation Details -->
    <div id="calculation-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-title">Calculation Details</h3>
                <button class="modal-close" onclick="closeCalculationModal()">&times;</button>
            </div>
            <div class="calculation-details" id="calculation-content">
                <!-- Calculation details will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL CONFIG & STATE ---
        const STORAGE_KEY = 'projectSchedulerDataV2';
        let people = [];
        let tickets = [];
        let hoursPerDay = 8; 
        let ticketDays = {
            S: 1, M: 2, L: 5, XL: 10, XXL: 15
        };
        
        // Enhanced task sizing with display names and presets
        let taskSizeDefinitions = {
            S: { name: 'Small', days: 1, removable: false },
            M: { name: 'Medium', days: 2, removable: false },
            L: { name: 'Large', days: 5, removable: false },
            XL: { name: 'X-Large', days: 10, removable: false },
            XXL: { name: 'XX-Large', days: 15, removable: false }
        };
        
        let effortMap = {};
        let currentTicketId = 1;
        let useCommonStartDate = false;

        // Date constants (used as the start of Week 1)
        const startDate = getNextMonday(new Date());
        
        // Get effective start date for calculations (either default, common, or earliest task date)
        function getEffectiveStartDate() {
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                if (commonDate) {
                    const date = new Date(commonDate);
                    // Find the Monday of the week containing this date
                    return getMondayOfWeek(date);
                }
            } else {
                // Find the earliest start date among all tasks
                const earliestTaskDate = getEarliestTaskStartDate();
                if (earliestTaskDate) {
                    // Find the Monday of the week containing the earliest date
                    return getMondayOfWeek(earliestTaskDate);
                }
            }
            return startDate;
        }
        
        // Get the Monday of the week containing the given date
        function getMondayOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Sunday being 0
            const monday = new Date(d.setDate(diff));
            monday.setHours(0, 0, 0, 0);
            return monday;
        }
        
        // Get the earliest start date from all defined tasks
        function getEarliestTaskStartDate() {
            if (tickets.length === 0) return null;
            
            const taskDates = tickets
                .map(ticket => ticket.startDate ? new Date(ticket.startDate) : null)
                .filter(date => date !== null)
                .sort((a, b) => a - b);
            
            return taskDates.length > 0 ? taskDates[0] : null;
        }

        // --- LOCAL STORAGE FUNCTIONS (Persistence) ---

        function saveToLocalStorage() {
            const data = {
                people,
                tickets,
                hoursPerDay,
                ticketDays,
                taskSizeDefinitions,
                currentTicketId,
                useCommonStartDate,
                lastUpdated: new Date().toISOString()
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            } catch (e) {
                console.error("Error saving to local storage:", e);
            }
        }

        function loadFromLocalStorage() {
            try {
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    const data = JSON.parse(storedData);
                    people = data.people || [];
                    tickets = data.tickets || [];
                    hoursPerDay = data.hoursPerDay || 8;
                    ticketDays = data.ticketDays || { S: 1, M: 2, L: 5, XL: 10, XXL: 15 };
                    taskSizeDefinitions = data.taskSizeDefinitions || {
                        S: { name: 'Small', days: 1, removable: false },
                        M: { name: 'Medium', days: 2, removable: false },
                        L: { name: 'Large', days: 5, removable: false },
                        XL: { name: 'X-Large', days: 10, removable: false },
                        XXL: { name: 'XX-Large', days: 15, removable: false }
                    };
                    currentTicketId = data.currentTicketId || (tickets.length > 0 ? Math.max(...tickets.map(t => t.id)) + 1 : 1);
                    useCommonStartDate = data.useCommonStartDate || false;
                    
                    // Sync ticketDays with taskSizeDefinitions
                    syncTaskSizes();
                    return true;
                }
            } catch (e) {
                console.error("Error loading from local storage:", e);
            }
            return false;
        }
        
        function syncTaskSizes() {
            // Ensure ticketDays and taskSizeDefinitions stay in sync
            Object.keys(taskSizeDefinitions).forEach(key => {
                ticketDays[key] = taskSizeDefinitions[key].days;
            });
        }

        // --- UTILITY FUNCTIONS ---

        function getNextMonday(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            const nextMonday = new Date(d.setDate(diff));
            nextMonday.setHours(0, 0, 0, 0);
            
            if (day === 1 && d.getHours() < 9) {
                return nextMonday;
            } else if (day === 1) {
                return new Date(nextMonday.setDate(nextMonday.getDate() + 7));
            } else {
                return nextMonday;
            }
        }
        
        function formatDate(dateString) {
            if (!dateString) return 'Not set';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric'
            });
        }
        
        function formatWeekEndDate(weekIndex) {
            const effectiveStart = getEffectiveStartDate();
            const date = new Date(effectiveStart);
            date.setDate(date.getDate() + (weekIndex * 7) + 4); // +4 days for Friday
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        function getWeekDateRange(weekIndex) {
            const effectiveStart = getEffectiveStartDate();
            const startDate = new Date(effectiveStart);
            startDate.setDate(startDate.getDate() + (weekIndex * 7));
            
            const endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 4); // Friday
            
            return `${startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        }

        function formatCompletionDate(startWeekIndex, remainingHours, totalWeeklyCapacity) {
            const effectiveStart = getEffectiveStartDate();
            const completionDate = new Date(effectiveStart);
            let daysIntoWeek = 0;

            if (totalWeeklyCapacity > 0) {
                const percentageUsed = remainingHours / totalWeeklyCapacity; 
                daysIntoWeek = Math.ceil(percentageUsed * 5); 
                daysIntoWeek = Math.min(daysIntoWeek, 5);
            }

            completionDate.setDate(completionDate.getDate() + (startWeekIndex * 7) + daysIntoWeek);
            
            let dayOfWeek = completionDate.getDay();
            if (dayOfWeek === 6) { // Saturday
                completionDate.setDate(completionDate.getDate() + 2);
            } else if (dayOfWeek === 0) { // Sunday
                completionDate.setDate(completionDate.getDate() + 1);
            }

            return completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        function calculateEffortMap() {
            effortMap = {};
            Object.keys(taskSizeDefinitions).forEach(key => {
                effortMap[key] = taskSizeDefinitions[key].days * hoursPerDay;
            });
        }

        // --- CORE SCHEDULING LOGIC ---

        function getProjectedTickets() {
            if (people.length === 0 || tickets.length === 0) {
                return tickets.map(t => ({ ...t, endDate: 'N/A', explanation: 'No people or no effort.', isDelayed: false }));
            }

            calculateEffortMap();

            // Create a deep clone of availability for resource tracking
            const availabilityTracker = people.reduce((acc, p) => {
                acc[p.name] = [...p.availability];
                return acc;
            }, {});
            
            const projectedTickets = tickets.map(ticket => {
                const totalEffortHours = effortMap[ticket.size] || 0;
                const assignedCount = ticket.assigned.length;
                
                if (totalEffortHours === 0 || assignedCount === 0) {
                    return { ...ticket, endDate: 'N/A', explanation: 'No effort defined or no one assigned.', isDelayed: false };
                }

                // Calculate which week the task can start based on start date
                let taskStartDate;
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    taskStartDate = commonDate ? new Date(commonDate) : getEffectiveStartDate();
                } else {
                    taskStartDate = new Date(ticket.startDate || getEffectiveStartDate());
                }
                
                const weekStartDate = getEffectiveStartDate();
                const daysDiff = Math.max(0, Math.floor((taskStartDate - weekStartDate) / (1000 * 60 * 60 * 24)));
                const startWeekIndex = Math.max(0, Math.floor(daysDiff / 7));

                let hoursRemaining = totalEffortHours / assignedCount; 
                const initialHours = hoursRemaining;
                
                let completionWeekIndex = -1;
                let finalCapacity = 0;
                let pooledCapacityThisWeek = 0; 
                
                let explanation = `Ticket Effort: ${totalEffortHours} hours (${ticket.size}, ${ticketDays[ticket.size]} person-days).\n`;
                explanation += `Assigned: ${ticket.assigned.join(', ')} (${assignedCount} person(s)).\n`;
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    explanation += `Start Date: ${formatDate(commonDate)} (Week ${startWeekIndex + 1}) [Common Start Date].\n`;
                } else {
                    explanation += `Start Date: ${formatDate(ticket.startDate)} (Week ${startWeekIndex + 1}).\n`;
                }
                explanation += `Required Duration Hours (pooled): ${initialHours.toFixed(1)} hours.\n`;
                explanation += `Planning baseline: Week 1 starts ${formatDate(weekStartDate.toISOString().split('T')[0])}.\n\n`;

                let currentHoursToConsume = hoursRemaining;

                // Iterate through 5 weeks, starting from the appropriate week
                for (let w = startWeekIndex; w < 5; w++) {
                    pooledCapacityThisWeek = 0;
                    const capacityBreakdown = {};
                    
                    ticket.assigned.forEach(name => {
                        const personCapacity = availabilityTracker[name] ? availabilityTracker[name][w] || 0 : 0;
                        pooledCapacityThisWeek += personCapacity;
                        capacityBreakdown[name] = personCapacity;
                    });
                    
                    explanation += `--- Week ${w + 1} (${getWeekDateRange(w)}) ---\n`;
                    explanation += `Pooled Capacity: ${pooledCapacityThisWeek.toFixed(1)} hours.\n`;
                    
                    if (pooledCapacityThisWeek <= 0) {
                        explanation += 'No capacity this week from assigned team members. Moving to next week.\n';
                        continue;
                    }
                    
                    if (currentHoursToConsume <= pooledCapacityThisWeek) {
                        completionWeekIndex = w;
                        finalCapacity = currentHoursToConsume;
                        explanation += `Task completes this week, consuming ${currentHoursToConsume.toFixed(1)} hours of pooled capacity.\n`;
                        
                        let capacityUsed = currentHoursToConsume;
                        ticket.assigned.forEach(name => {
                            const personCapacity = capacityBreakdown[name];
                            if (personCapacity > 0) {
                                const proportion = personCapacity / pooledCapacityThisWeek;
                                const timeToDeduct = capacityUsed * proportion;
                                availabilityTracker[name][w] -= timeToDeduct;
                                explanation += `  - ${name} contribution: ${timeToDeduct.toFixed(1)} hours (Remaining: ${availabilityTracker[name][w].toFixed(1)}).\n`;
                            }
                        });
                        break;
                    } else {
                        currentHoursToConsume -= pooledCapacityThisWeek;
                        explanation += `Full capacity consumed (${pooledCapacityThisWeek.toFixed(1)} hours). Remaining hours for task: ${currentHoursToConsume.toFixed(1)}.\n`;

                        ticket.assigned.forEach(name => {
                            availabilityTracker[name][w] = 0;
                        });
                    }
                }

                let endDate;
                let isDelayed = false;

                if (completionWeekIndex !== -1) {
                    endDate = formatCompletionDate(completionWeekIndex, finalCapacity, pooledCapacityThisWeek);
                } else {
                    endDate = `> ${formatWeekEndDate(4)}`;
                    explanation += '\nTask is projected to finish AFTER the 5-week window.';
                    isDelayed = true;
                }
                
                return { 
                    ...ticket, 
                    endDate: endDate, 
                    explanation: explanation,
                    isDelayed: isDelayed
                };
            });
            
            return projectedTickets;
        }

        function calculateProjection() {
            const projectedTickets = getProjectedTickets();
            renderTickets(projectedTickets);
            renderTimeline(projectedTickets);
        }
        
        function renderTimeline(projectedTickets) {
            const timelineStartDateEl = document.getElementById('timeline-start-date');
            const timelineEndDateEl = document.getElementById('timeline-end-date');
            const timelineDurationEl = document.getElementById('timeline-duration');
            const timelineProgressEl = document.getElementById('timeline-progress');
            const timelineMarkersEl = document.getElementById('timeline-markers');
            const timelineLegendEl = document.getElementById('timeline-legend');
            
            if (projectedTickets.length === 0) {
                timelineStartDateEl.textContent = 'No tasks defined';
                timelineEndDateEl.textContent = 'No tasks defined';
                timelineDurationEl.textContent = '0 days';
                timelineProgressEl.style.width = '0%';
                timelineMarkersEl.innerHTML = '';
                timelineLegendEl.innerHTML = '';
                return;
            }
            
            // Calculate timeline bounds
            const projectStartDate = getEffectiveStartDate();
            let projectEndDate = new Date(projectStartDate);
            let latestEndDate = new Date(projectStartDate);
            let hasDelayedTasks = false;
            
            // Find the latest completion date
            projectedTickets.forEach(ticket => {
                if (ticket.endDate && ticket.endDate !== 'N/A' && !ticket.endDate.includes('>')) {
                    try {
                        const endDate = new Date(ticket.endDate + ', ' + new Date().getFullYear());
                        if (!isNaN(endDate.getTime()) && endDate > latestEndDate) {
                            latestEndDate = endDate;
                        }
                    } catch (e) {
                        console.warn('Could not parse end date:', ticket.endDate);
                    }
                } else if (ticket.isDelayed || ticket.endDate.includes('>')) {
                    hasDelayedTasks = true;
                    // For delayed tasks, assume they extend beyond 5 weeks
                    const delayedDate = new Date(projectStartDate);
                    delayedDate.setDate(delayedDate.getDate() + 35); // 5 weeks
                    if (delayedDate > latestEndDate) {
                        latestEndDate = delayedDate;
                    }
                }
            });
            
            projectEndDate = latestEndDate;
            
            // Calculate duration
            const durationDays = Math.ceil((projectEndDate - projectStartDate) / (1000 * 60 * 60 * 24));
            const durationWeeks = Math.ceil(durationDays / 7);
            
            // Update timeline info
            timelineStartDateEl.textContent = formatDate(projectStartDate.toISOString().split('T')[0]);
            timelineEndDateEl.textContent = formatDate(projectEndDate.toISOString().split('T')[0]);
            timelineDurationEl.textContent = `${durationDays} days (${durationWeeks} weeks)`;
            
            // Update progress bar based on timeline health
            const progressPercentage = hasDelayedTasks ? 100 : Math.min(100, (durationDays / 35) * 100); // 35 days = 5 weeks
            timelineProgressEl.style.width = `${progressPercentage}%`;
            
            if (hasDelayedTasks || durationWeeks > 5) {
                timelineProgressEl.className = 'h-full timeline-delayed transition-all duration-500';
            } else {
                timelineProgressEl.className = 'h-full timeline-ontime transition-all duration-500';
            }
            
            // Add task markers
            timelineMarkersEl.innerHTML = '';
            projectedTickets.forEach((ticket, index) => {
                if (ticket.endDate && ticket.endDate !== 'N/A' && !ticket.endDate.includes('>')) {
                    try {
                        const endDate = new Date(ticket.endDate + ', ' + new Date().getFullYear());
                        if (!isNaN(endDate.getTime())) {
                            const dayFromStart = Math.ceil((endDate - projectStartDate) / (1000 * 60 * 60 * 24));
                            const positionPercentage = Math.min(100, Math.max(0, (dayFromStart / durationDays) * 100));
                            
                            const marker = document.createElement('div');
                            marker.className = 'timeline-marker';
                            marker.style.left = `${positionPercentage}%`;
                            marker.setAttribute('data-label', `Task #${ticket.id}: ${ticket.endDate}`);
                            marker.style.background = ticket.isDelayed ? '#ef4444' : '#10b981';
                            marker.style.zIndex = '10';
                            
                            timelineMarkersEl.appendChild(marker);
                        }
                    } catch (e) {
                        console.warn('Could not parse end date for marker:', ticket.endDate);
                    }
                } else if (ticket.isDelayed || ticket.endDate.includes('>')) {
                    // Add a marker for delayed tasks at the end
                    const marker = document.createElement('div');
                    marker.className = 'timeline-marker';
                    marker.style.left = '95%';
                    marker.setAttribute('data-label', `Task #${ticket.id}: Delayed`);
                    marker.style.background = '#ef4444';
                    marker.style.zIndex = '10';
                    
                    timelineMarkersEl.appendChild(marker);
                }
            });
            
            // Update legend
            timelineLegendEl.innerHTML = `
                <div class="timeline-legend-item">
                    <div class="timeline-legend-dot bg-green-500"></div>
                    <span>On Schedule</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-dot bg-red-500"></div>
                    <span>Delayed/Over 5 weeks</span>
                </div>
                <div class="timeline-legend-item">
                    <div class="timeline-legend-dot bg-gray-400"></div>
                    <span>Hover markers for details</span>
                </div>
            `;
        }

        // --- RENDERING FUNCTIONS ---

        function renderEffortMap() {
            calculateEffortMap(); 
            
            document.getElementById('hours-per-day-display').textContent = hoursPerDay;
            document.getElementById('hours-per-day').value = hoursPerDay;

            renderTaskSizeCards();
        }
        
        function renderTaskSizeCards() {
            const container = document.getElementById('task-size-cards');
            if (!container) return;

            container.innerHTML = Object.keys(taskSizeDefinitions).map(key => {
                const size = taskSizeDefinitions[key];
                const totalHours = size.days * hoursPerDay;
                
                return `
                    <div class="task-size-card">
                        <div class="flex justify-between items-start mb-2">
                            <div class="size-label-enhanced">${size.name}</div>
                            ${size.removable ? `<button onclick="removeTaskSize('${key}')" class="text-red-300 hover:text-red-100 text-xs">✕</button>` : ''}
                        </div>
                        <div class="size-controls">
                            <input 
                                type="number" 
                                value="${size.days}" 
                                min="0.1" 
                                max="50"
                                step="0.5"
                                onchange="updateTaskSizeDaysEnhanced('${key}', this.value)" 
                                class="size-input-enhanced"
                            >
                            <span class="text-sm">days</span>
                        </div>
                        <div class="size-metrics">
                            <div>📊 <strong>${totalHours}h</strong> total</div>
                            <div>⚡ ${(totalHours/hoursPerDay).toFixed(1)} person-days</div>
                            <div class="text-xs mt-1 opacity-75">Size: <strong>${key}</strong></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Update ticket size dropdown options
            updateTicketSizeDropdown();
        }
        
        function updateTicketSizeDropdown() {
            const dropdown = document.getElementById('new-ticket-size');
            if (!dropdown) return;
            
            dropdown.innerHTML = Object.keys(taskSizeDefinitions).map(key => {
                const size = taskSizeDefinitions[key];
                return `<option value="${key}">${size.name} (${key})</option>`;
            }).join('');
        }

        function updateAvailabilityHeader() {
            const header = document.getElementById('availability-header');
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                if (commonDate) {
                    const formattedDate = formatDate(commonDate);
                    header.textContent = `Team Availability (5 weeks from ${formattedDate})`;
                } else {
                    header.textContent = 'Team Availability (5 weeks from common start date)';
                }
            } else {
                const earliestTaskDate = getEarliestTaskStartDate();
                if (earliestTaskDate) {
                    const formattedDate = formatDate(earliestTaskDate.toISOString().split('T')[0]);
                    header.textContent = `Team Availability (5 weeks from ${formattedDate})`;
                } else {
                    header.textContent = 'Team Availability (Next 5 Weeks)';
                }
            }
        }
        
        function updateStartDateColumnHeader() {
            const header = document.getElementById('start-date-column-header');
            if (useCommonStartDate) {
                header.textContent = 'Start Date (Common)';
            } else {
                header.textContent = 'Start Date (Editable)';
            }
        }

        function renderPeople() {
            // Update the header to reflect current mode
            updateAvailabilityHeader();
            
            const peopleList = document.getElementById('people-list');
            const assignDropdown = document.getElementById('new-ticket-assigned');
            peopleList.innerHTML = '';
            assignDropdown.innerHTML = '';

            people.forEach((person, pIndex) => {
                const card = document.createElement('div');
                card.className = 'p-3 mb-3 bg-indigo-50 rounded-lg border border-indigo-200';
                
                let availabilityInputs = '';
                for (let w = 0; w < 5; w++) {
                    const weekEnd = formatWeekEndDate(w);
                    availabilityInputs += `
                        <div class="flex-1 min-w-[50px]">
                            <label class="block text-xs text-gray-600 mb-1">Wk ${w+1} (${weekEnd})</label>
                            <input 
                                type="number" 
                                value="${person.availability[w] || 0}" 
                                min="0" 
                                onchange="updatePersonAvailability('${person.name}', ${w}, this.value)" 
                                class="w-full p-1 text-xs border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-center"
                            >
                        </div>
                    `;
                }

                const weekRangeInfo = useCommonStartDate ? 
                    ' (Based on common start date)' : 
                    (getEarliestTaskStartDate() ? ' (Based on earliest task start date)' : '');
                
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <span class="font-bold text-indigo-800">${person.name}</span>
                        <button onclick="removePerson('${person.name}')" class="text-red-500 hover:text-red-700 transition">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                    <div class="flex gap-2 text-xs">
                        ${availabilityInputs}
                    </div>
                    ${weekRangeInfo ? `<div class="text-xs text-blue-600 mt-1">${weekRangeInfo}</div>` : ''}
                `;
                peopleList.appendChild(card);

                const option = document.createElement('option');
                option.value = person.name;
                option.textContent = person.name;
                assignDropdown.appendChild(option);
            });
            
            const ticketAssignmentSelect = document.getElementById('new-ticket-assigned');
            if (ticketAssignmentSelect) {
                Array.from(ticketAssignmentSelect.options).forEach(opt => opt.selected = false);
            }
        }

        function renderTickets(projectedTickets) {
            const tbody = document.getElementById('ticket-table-body');
            tbody.innerHTML = '';
            
            // Update column header based on current mode
            updateStartDateColumnHeader();
            
            if (projectedTickets.length === 0) {
                document.getElementById('no-tickets').classList.remove('hidden');
                return;
            }
            document.getElementById('no-tickets').classList.add('hidden');

            projectedTickets.forEach(ticket => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50';

                // Rebuild the dropdown options to ensure current assignments are selected
                const allOptions = people.map(p => {
                    const isSelected = ticket.assigned.includes(p.name);
                    return `<option value="${p.name}" ${isSelected ? 'selected' : ''}>${p.name}</option>`;
                }).join('');

                // Create size dropdown options
                const sizeOptions = Object.keys(taskSizeDefinitions).map(key => {
                    const size = taskSizeDefinitions[key];
                    const isSelected = ticket.size === key;
                    return `<option value="${key}" ${isSelected ? 'selected' : ''}>${size.name} (${key})</option>`;
                }).join('');

                const completionDateClass = ticket.isDelayed ? 'bg-red-100 text-red-700 font-bold p-1 rounded' : 'text-green-600 font-semibold';
                
                // Determine displayed start date
                let displayStartDate;
                let startDateInput = '';
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    displayStartDate = formatDate(commonDate) + ' 🔗';
                    startDateInput = `<span class="text-gray-500 text-sm">${displayStartDate}</span>`;
                } else {
                    startDateInput = `
                        <input 
                            type="date" 
                            value="${ticket.startDate || ''}" 
                            onchange="handleStartDateChange(this, ${ticket.id})"
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white"
                            title="Change task start date"
                        >
                    `;
                }
                
                tr.innerHTML = `
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${ticket.id}</td>
                    <td class="px-3 py-2 text-sm text-gray-900 w-1/3">${ticket.description}</td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-600">${startDateInput}</td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm font-medium">
                        <select 
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white text-indigo-600 font-medium"
                            onchange="handleSizeChange(this, ${ticket.id})"
                            title="Change task size"
                        >
                            ${sizeOptions}
                        </select>
                    </td>
                    <td class="px-3 py-2 text-sm text-gray-500 w-1/4">
                        <select 
                            multiple 
                            class="select-multiple w-full p-1 border border-gray-300 rounded-lg text-xs h-auto min-h-[40px]"
                            onchange="handleAssignmentChange(this, ${ticket.id})"
                        >
                            ${allOptions}
                        </select>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">
                        <div class="flex items-center">
                            <span class="${completionDateClass}">${ticket.endDate}</span>
                            <button onclick="showCalculationDetails(${ticket.id})" class="details-btn" title="Show calculation details">
                                Details
                            </button>
                        </div>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button onclick="removeTicket(${ticket.id})" class="text-red-500 hover:text-red-700 transition">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
            });
        }

        // --- CSV EXPORT FUNCTION ---

        window.exportData = () => {
            const projectedTickets = getProjectedTickets();
            if (projectedTickets.length === 0) {
                alert("No tickets to export.");
                return;
            }

            // 1. Generate the CSV content
            let csvContent = "Ticket ID,Description,Start Date,Size,Person Days,Total Hours,Assigned Team,Projected End Date,Detailed Explanation\n";

            projectedTickets.forEach(ticket => {
                const totalHours = effortMap[ticket.size] || 0;
                const personDays = ticketDays[ticket.size] || 0;

                // Escape double quotes and ensure data is wrapped in quotes
                const escapeCSV = (value) => `"${String(value).replace(/"/g, '""')}"`;

                const row = [
                    ticket.id,
                    escapeCSV(ticket.description),
                    formatDate(ticket.startDate),
                    ticket.size,
                    personDays,
                    totalHours,
                    escapeCSV(ticket.assigned.join('; ')),
                    ticket.endDate.replace(/,/g, ''),
                    escapeCSV(ticket.explanation.replace(/\n/g, ' | ')) // Replace newlines for single-cell explanation
                ].join(',');
                csvContent += row + "\n";
            });

            // 2. Trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `project_schedule_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- COMPREHENSIVE CONFIGURATION EXPORT/IMPORT ---

        window.exportConfiguration = () => {
            const timestamp = new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
            
            // Create comprehensive configuration data
            const configData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    version: '2.0',
                    description: 'Enterprise Project Scheduler Configuration Export'
                },
                settings: {
                    hoursPerDay: hoursPerDay,
                    useCommonStartDate: useCommonStartDate,
                    commonStartDate: document.getElementById('common-start-date')?.value || '',
                    currentTicketId: currentTicketId
                },
                taskSizeDefinitions: taskSizeDefinitions,
                people: people,
                tickets: tickets
            };

            // Convert to CSV format with multiple sections
            let csvContent = '';
            
            // Metadata section
            csvContent += "SECTION,METADATA\n";
            csvContent += "Key,Value\n";
            csvContent += `Export Date,${configData.metadata.exportDate}\n`;
            csvContent += `Version,${configData.metadata.version}\n`;
            csvContent += `Description,${configData.metadata.description}\n`;
            csvContent += "\n";
            
            // Settings section
            csvContent += "SECTION,SETTINGS\n";
            csvContent += "Key,Value\n";
            csvContent += `Hours Per Day,${configData.settings.hoursPerDay}\n`;
            csvContent += `Use Common Start Date,${configData.settings.useCommonStartDate}\n`;
            csvContent += `Common Start Date,${configData.settings.commonStartDate}\n`;
            csvContent += `Current Ticket ID,${configData.settings.currentTicketId}\n`;
            csvContent += "\n";
            
            // Task Size Definitions section
            csvContent += "SECTION,TASK_SIZES\n";
            csvContent += "Size Key,Name,Days,Removable\n";
            Object.keys(configData.taskSizeDefinitions).forEach(key => {
                const size = configData.taskSizeDefinitions[key];
                csvContent += `${key},"${size.name}",${size.days},${size.removable}\n`;
            });
            csvContent += "\n";
            
            // People section
            csvContent += "SECTION,PEOPLE\n";
            csvContent += "Name,Week1,Week2,Week3,Week4,Week5\n";
            configData.people.forEach(person => {
                csvContent += `"${person.name}",${person.availability.join(',')}\n`;
            });
            csvContent += "\n";
            
            // Tickets section
            csvContent += "SECTION,TICKETS\n";
            csvContent += "ID,Description,Start Date,Size,Assigned Team\n";
            configData.tickets.forEach(ticket => {
                const assignedTeam = ticket.assigned.join(';');
                csvContent += `${ticket.id},"${ticket.description.replace(/"/g, '""')}",${ticket.startDate},${ticket.size},"${assignedTeam}"\n`;
            });
            
            // Download the configuration file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `project_config_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Show success message
            alert(`✅ Configuration exported successfully!\n\nFile: project_config_${timestamp}.csv\n\nThis file contains:\n• All team member configurations\n• Task size definitions\n• All tickets and assignments\n• System settings\n\nUse "Import Config" to restore this configuration later.`);
        }

        window.triggerImport = () => {
            const fileInput = document.getElementById('import-config-file');
            fileInput.click();
        }

        window.handleConfigImport = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                alert('❌ Please select a CSV configuration file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    importConfiguration(csvContent);
                } catch (error) {
                    alert(`❌ Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input for repeated imports
            event.target.value = '';
        }

        function importConfiguration(csvContent) {
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            let currentSection = '';
            let importedData = {
                settings: {},
                taskSizeDefinitions: {},
                people: [],
                tickets: []
            };
            
            let skipHeader = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check for section headers
                if (line.startsWith('SECTION,')) {
                    currentSection = line.split(',')[1];
                    skipHeader = true;
                    continue;
                }
                
                // Skip column headers after section declaration
                if (skipHeader) {
                    skipHeader = false;
                    continue;
                }
                
                // Skip empty lines
                if (!line) continue;
                
                // Parse based on current section
                try {
                    if (currentSection === 'SETTINGS') {
                        const [key, value] = parseCSVLine(line);
                        if (key === 'Hours Per Day') importedData.settings.hoursPerDay = parseInt(value);
                        else if (key === 'Use Common Start Date') importedData.settings.useCommonStartDate = value === 'true';
                        else if (key === 'Common Start Date') importedData.settings.commonStartDate = value;
                        else if (key === 'Current Ticket ID') importedData.settings.currentTicketId = parseInt(value);
                    }
                    else if (currentSection === 'TASK_SIZES') {
                        const [sizeKey, name, days, removable] = parseCSVLine(line);
                        importedData.taskSizeDefinitions[sizeKey] = {
                            name: name,
                            days: parseFloat(days),
                            removable: removable === 'true'
                        };
                    }
                    else if (currentSection === 'PEOPLE') {
                        const [name, w1, w2, w3, w4, w5] = parseCSVLine(line);
                        importedData.people.push({
                            name: name,
                            availability: [parseInt(w1), parseInt(w2), parseInt(w3), parseInt(w4), parseInt(w5)]
                        });
                    }
                    else if (currentSection === 'TICKETS') {
                        const [id, description, startDate, size, assignedTeam] = parseCSVLine(line);
                        const assigned = assignedTeam ? assignedTeam.split(';').filter(name => name.trim()) : [];
                        importedData.tickets.push({
                            id: parseInt(id),
                            description: description,
                            startDate: startDate,
                            size: size,
                            assigned: assigned
                        });
                    }
                } catch (error) {
                    console.warn(`Skipping invalid line in ${currentSection}: ${line}`);
                }
            }
            
            // Validate imported data
            if (!validateImportedData(importedData)) {
                alert('❌ Invalid configuration file. Please check the file format and try again.');
                return;
            }
            
            // Confirm import
            const confirmMessage = `📋 Import Configuration\n\nFound:\n• ${Object.keys(importedData.taskSizeDefinitions).length} task size definitions\n• ${importedData.people.length} team members\n• ${importedData.tickets.length} tickets\n\n⚠️ This will replace ALL current data!\n\nContinue with import?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Apply imported configuration
            try {
                // Apply settings
                hoursPerDay = importedData.settings.hoursPerDay || 8;
                useCommonStartDate = importedData.settings.useCommonStartDate || false;
                currentTicketId = importedData.settings.currentTicketId || 1;
                
                // Apply configurations
                taskSizeDefinitions = importedData.taskSizeDefinitions;
                people = importedData.people;
                tickets = importedData.tickets;
                
                // Update UI
                document.getElementById('hours-per-day').value = hoursPerDay;
                document.getElementById('use-common-start-date').checked = useCommonStartDate;
                if (importedData.settings.commonStartDate) {
                    document.getElementById('common-start-date').value = importedData.settings.commonStartDate;
                }
                
                // Apply common start date logic
                if (useCommonStartDate) {
                    toggleCommonStartDate();
                }
                
                // Sync and recalculate everything
                syncTaskSizes();
                calculateEffortMap();
                renderEffortMap();
                renderPeople();
                calculateProjection();
                saveToLocalStorage();
                
                alert(`✅ Configuration imported successfully!\n\n• ${Object.keys(taskSizeDefinitions).length} task sizes loaded\n• ${people.length} team members configured\n• ${tickets.length} tickets imported\n\nAll data has been restored and calculations updated.`);
                
            } catch (error) {
                alert(`❌ Error applying configuration: ${error.message}\n\nPlease check your file and try again.`);
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"' && (i === 0 || line[i-1] === ',')) {
                    inQuotes = true;
                } else if (char === '"' && inQuotes && (i === line.length - 1 || line[i+1] === ',')) {
                    inQuotes = false;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result;
        }

        function validateImportedData(data) {
            // Basic validation
            if (!data.settings || !data.taskSizeDefinitions || !data.people || !data.tickets) {
                return false;
            }
            
            // Validate people have required fields
            for (const person of data.people) {
                if (!person.name || !Array.isArray(person.availability) || person.availability.length !== 5) {
                    return false;
                }
            }
            
            // Validate tickets have required fields
            for (const ticket of data.tickets) {
                if (!ticket.id || !ticket.description || !ticket.size || !Array.isArray(ticket.assigned)) {
                    return false;
                }
            }
            
            return true;
        }

        // --- BULK TASK IMPORT ---

        window.triggerTaskImport = () => {
            const fileInput = document.getElementById('import-tasks-file');
            fileInput.click();
        }

        window.handleTaskImport = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                alert('❌ Please select a CSV file with tasks.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    importTasksFromCSV(csvContent);
                } catch (error) {
                    alert(`❌ Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input for repeated imports
            event.target.value = '';
        }

        function importTasksFromCSV(csvContent) {
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            if (lines.length === 0) {
                alert('❌ The CSV file appears to be empty.');
                return;
            }
            
            // Parse tasks from CSV
            const newTasks = [];
            let hasHeader = false;
            
            // Check if first line is a header (contains "task" or "description" etc.)
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('task') || firstLine.includes('description') || firstLine.includes('name')) {
                hasHeader = true;
            }
            
            const startIndex = hasHeader ? 1 : 0;
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                if (!line) continue;
                
                // Handle CSV parsing (remove quotes if present)
                let taskName = line.replace(/^"(.*)"$/, '$1').replace(/""/g, '"').trim();
                
                // Skip empty task names
                if (!taskName) continue;
                
                // Validate task name length
                if (taskName.length > 200) {
                    console.warn(`Task name too long, truncating: ${taskName.substring(0, 50)}...`);
                    taskName = taskName.substring(0, 200);
                }
                
                newTasks.push(taskName);
            }
            
            if (newTasks.length === 0) {
                alert('❌ No valid tasks found in the CSV file.\n\nExpected format:\n• One task per line\n• Optional header row\n• Task names in first column');
                return;
            }
            
            // Show preview and confirm import
            const previewTasks = newTasks.slice(0, 5);
            const previewText = previewTasks.join('\n');
            const moreText = newTasks.length > 5 ? `\n... and ${newTasks.length - 5} more tasks` : '';
            
            const confirmMessage = `📋 Import ${newTasks.length} Tasks\n\nPreview:\n${previewText}${moreText}\n\n✅ Default settings will be applied:\n• Size: Medium (M)\n• Start Date: Next Monday\n• Assigned: Unassigned\n\nContinue with import?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Apply default settings for new tasks
            const defaultSize = 'M'; // Medium
            const defaultStartDate = getNextMonday(new Date()).toISOString().split('T')[0];
            const defaultAssigned = []; // Unassigned
            
            // Add tasks to the system
            let addedCount = 0;
            let skippedCount = 0;
            
            newTasks.forEach(taskName => {
                // Check for duplicate task descriptions
                const isDuplicate = tickets.some(ticket => 
                    ticket.description.toLowerCase() === taskName.toLowerCase()
                );
                
                if (isDuplicate) {
                    skippedCount++;
                    console.warn(`Skipping duplicate task: ${taskName}`);
                    return;
                }
                
                // Add the task
                tickets.push({
                    id: currentTicketId++,
                    description: taskName,
                    startDate: defaultStartDate,
                    size: defaultSize,
                    assigned: [...defaultAssigned]
                });
                
                addedCount++;
            });
            
            // Update the system
            if (addedCount > 0) {
                // Refresh people display if not using common start date
                if (!useCommonStartDate) {
                    renderPeople();
                }
                
                calculateProjection();
                saveToLocalStorage();
                
                // Show success message
                let message = `✅ Task Import Complete!\n\n• ${addedCount} tasks added successfully`;
                if (skippedCount > 0) {
                    message += `\n• ${skippedCount} duplicates skipped`;
                }
                message += `\n\n📝 All tasks set to:\n• Size: Medium (M)\n• Start Date: ${formatDate(defaultStartDate)}\n• Status: Unassigned\n\nYou can now edit individual tasks as needed.`;
                
                alert(message);
            } else {
                alert('❌ No tasks were added. All tasks may have been duplicates.');
            }
        }
        
        window.resetToDefaults = () => {
            if (confirm('This will reset all data to defaults with current dates. Are you sure?')) {
                localStorage.removeItem(STORAGE_KEY);
                initializeDefaultData();
                
                // Reset UI state
                useCommonStartDate = false;
                document.getElementById('use-common-start-date').checked = false;
                
                // Re-initialize
                calculateEffortMap();
                renderEffortMap();
                renderPeople();
                calculateProjection();
                
                alert('Data reset to defaults with current dates!');
            }
        }


        // --- COMMON START DATE FUNCTIONS ---
        
        window.toggleCommonStartDate = () => {
            const checkbox = document.getElementById('use-common-start-date');
            const commonDateInput = document.getElementById('common-start-date');
            const individualDateInput = document.getElementById('new-ticket-start-date');
            const startDateHelp = document.getElementById('start-date-help');
            
            useCommonStartDate = checkbox.checked;
            
            if (useCommonStartDate) {
                // Enable common start date, disable individual
                commonDateInput.disabled = false;
                commonDateInput.classList.remove('bg-gray-100');
                commonDateInput.classList.add('bg-white');
                
                // Set default to next Monday if empty
                if (!commonDateInput.value) {
                    commonDateInput.value = getNextMonday(new Date()).toISOString().split('T')[0];
                }
                
                individualDateInput.disabled = true;
                individualDateInput.classList.add('bg-gray-100', 'text-gray-400');
                
                startDateHelp.innerHTML = 'Common start date is enabled - all tasks will use the same start date above. <strong>Team availability weeks are recalculated from this date.</strong>';
                
            } else {
                // Disable common start date, enable individual
                commonDateInput.disabled = true;
                commonDateInput.classList.add('bg-gray-100');
                commonDateInput.classList.remove('bg-white');
                
                individualDateInput.disabled = false;
                individualDateInput.classList.remove('bg-gray-100', 'text-gray-400');
                
                startDateHelp.innerHTML = 'Individual start dates enabled. <strong>Team availability weeks are calculated from the earliest task start date.</strong>';
            }
            
            // Refresh people display to show updated week dates
            renderPeople();
            
            // Recalculate projections (this will also update the table)
            calculateProjection();
            saveToLocalStorage();
        }
        
        window.updateAllTaskStartDates = () => {
            if (useCommonStartDate) {
                // Update header and refresh people display to show updated week dates
                updateAvailabilityHeader();
                renderPeople();
                
                // Recalculate when common start date changes
                calculateProjection();
                saveToLocalStorage();
            }
        }

        // --- DATA MODIFIERS (Trigger localStorage save and recalculation) ---
        
        window.updateEffortMapping = (value) => {
            const newHours = parseInt(value, 10);
            if (isNaN(newHours) || newHours < 1 || newHours > 24) return;
            
            hoursPerDay = newHours;
            
            calculateEffortMap();
            renderTaskSizeCards(); // Updated to use new function
            calculateProjection();
            saveToLocalStorage();
        }

        window.updateTicketSizeDays = (sizeKey, value) => {
            const newDays = parseInt(value, 10);
            if (isNaN(newDays) || newDays < 1) return; 

            ticketDays[sizeKey] = newDays;
            
            calculateEffortMap(); 
            renderEffortMap();
            calculateProjection();
            saveToLocalStorage();
        }
        
        // Enhanced task sizing functions
        window.updateTicketSizeDaysEnhanced = (sizeKey, value) => {
            const newDays = parseFloat(value);
            if (isNaN(newDays) || newDays < 0.1) return; 

            ticketDays[sizeKey] = newDays;
            taskSizeDefinitions[sizeKey].days = newDays;
            
            calculateEffortMap(); 
            renderTaskSizeCards();
            calculateProjection();
            saveToLocalStorage();
        }
        
        window.applyPreset = (presetName) => {
            const presets = {
                agile: {
                    XS: { name: 'Extra Small', days: 0.5, removable: true },
                    S: { name: 'Small', days: 1, removable: false },
                    M: { name: 'Medium', days: 3, removable: false },
                    L: { name: 'Large', days: 5, removable: false },
                    XL: { name: 'X-Large', days: 8, removable: false }
                },
                enterprise: {
                    S: { name: 'Small', days: 2, removable: false },
                    M: { name: 'Medium', days: 5, removable: false },
                    L: { name: 'Large', days: 10, removable: false },
                    XL: { name: 'X-Large', days: 20, removable: false },
                    XXL: { name: 'XX-Large', days: 40, removable: false }
                },
                startup: {
                    XS: { name: 'Quick Fix', days: 0.25, removable: true },
                    S: { name: 'Small', days: 1, removable: false },
                    M: { name: 'Medium', days: 2, removable: false },
                    L: { name: 'Large', days: 5, removable: false },
                    XL: { name: 'Epic', days: 10, removable: false }
                },
                conservative: {
                    S: { name: 'Small', days: 3, removable: false },
                    M: { name: 'Medium', days: 8, removable: false },
                    L: { name: 'Large', days: 15, removable: false },
                    XL: { name: 'X-Large', days: 25, removable: false },
                    XXL: { name: 'XX-Large', days: 40, removable: false }
                }
            };
            
            if (presets[presetName]) {
                if (confirm(`Apply ${presetName} preset? This will replace your current task sizes.`)) {
                    taskSizeDefinitions = { ...presets[presetName] };
                    syncTaskSizes();
                    calculateEffortMap();
                    renderTaskSizeCards();
                    calculateProjection();
                    saveToLocalStorage();
                }
            }
        }
        
        window.showCustomSizeForm = () => {
            document.getElementById('custom-size-form').classList.remove('hidden');
        }
        
        window.hideCustomSizeForm = () => {
            document.getElementById('custom-size-form').classList.add('hidden');
            // Clear form
            document.getElementById('new-size-key').value = '';
            document.getElementById('new-size-name').value = '';
            document.getElementById('new-size-days').value = '';
        }
        
        window.addCustomSize = () => {
            const key = document.getElementById('new-size-key').value.trim().toUpperCase();
            const name = document.getElementById('new-size-name').value.trim();
            const days = parseFloat(document.getElementById('new-size-days').value);
            
            if (!key || !name || isNaN(days) || days < 0.1) {
                alert('Please fill all fields with valid values.');
                return;
            }
            
            if (taskSizeDefinitions[key]) {
                alert('Size key already exists. Choose a different key.');
                return;
            }
            
            taskSizeDefinitions[key] = { name, days, removable: true };
            ticketDays[key] = days;
            
            calculateEffortMap();
            renderTaskSizeCards();
            hideCustomSizeForm();
            saveToLocalStorage();
            
            alert(`✅ Added custom size: ${name} (${key}) - ${days} days`);
        }
        
        window.removeTaskSize = (sizeKey) => {
            if (!taskSizeDefinitions[sizeKey]?.removable) {
                alert('This task size cannot be removed.');
                return;
            }
            
            // Check if any tickets use this size
            const ticketsWithSize = tickets.filter(ticket => ticket.size === sizeKey);
            if (ticketsWithSize.length > 0) {
                alert(`Cannot remove size ${sizeKey}. It's used by ${ticketsWithSize.length} ticket(s).`);
                return;
            }
            
            if (confirm(`Remove task size ${sizeKey} (${taskSizeDefinitions[sizeKey].name})?`)) {
                delete taskSizeDefinitions[sizeKey];
                delete ticketDays[sizeKey];
                
                calculateEffortMap();
                renderTaskSizeCards();
                saveToLocalStorage();
            }
        }

        window.addPerson = () => {
            const nameInput = document.getElementById('new-person-name');
            const name = nameInput.value.trim();
            if (!name || people.some(p => p.name === name)) {
                // Simplified confirmation dialog for local environment
                if (name) alert("Person already exists or name is invalid.");
                return;
            }

            people.push({
                name: name,
                availability: [25, 25, 25, 25, 25] 
            });
            
            nameInput.value = '';
            renderPeople();
            calculateProjection();
            saveToLocalStorage();
        }

        window.removePerson = (name) => {
            people = people.filter(p => p.name !== name);
            tickets.forEach(ticket => {
                ticket.assigned = ticket.assigned.filter(n => n !== name);
            });

            renderPeople();
            calculateProjection();
            saveToLocalStorage();
        }

        window.updatePersonAvailability = (name, weekIndex, value) => {
            const hours = Math.max(0, parseInt(value, 10));
            if (isNaN(hours)) return;

            const person = people.find(p => p.name === name);
            if (person) {
                person.availability[weekIndex] = hours;
                calculateProjection(); 
                saveToLocalStorage();
            }
        }

        window.addTicket = () => {
            const descInput = document.getElementById('new-ticket-desc');
            const startDateInput = document.getElementById('new-ticket-start-date');
            const sizeSelect = document.getElementById('new-ticket-size');
            const assignedSelect = document.getElementById('new-ticket-assigned');

            const description = descInput.value.trim();
            
            // Handle start date based on common start date setting
            let startDate;
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date').value;
                startDate = commonDate || getNextMonday(new Date()).toISOString().split('T')[0];
            } else {
                startDate = startDateInput.value || getNextMonday(new Date()).toISOString().split('T')[0];
            }
            
            const size = sizeSelect.value;
            const assigned = Array.from(assignedSelect.selectedOptions).map(option => option.value);

            if (!description) {
                alert("Ticket description cannot be empty.");
                return;
            }

            tickets.push({
                id: currentTicketId++,
                description: description,
                startDate: startDate,
                size: size,
                assigned: assigned
            });

            descInput.value = '';
            startDateInput.value = '';
            sizeSelect.value = 'L';
            Array.from(assignedSelect.options).forEach(opt => opt.selected = false);

            // Refresh people display since earliest task date might have changed
            if (!useCommonStartDate) {
                renderPeople();
            }
            
            calculateProjection();
            saveToLocalStorage();
        }

        window.removeTicket = (id) => {
            tickets = tickets.filter(t => t.id !== id);
            
            // Refresh people display since earliest task date might have changed
            if (!useCommonStartDate) {
                renderPeople();
            }
            
            calculateProjection();
            saveToLocalStorage();
        }

        window.updateTicketAssignment = (id, newAssignedArray) => {
            const ticket = tickets.find(t => t.id === id);
            if (ticket) {
                ticket.assigned = newAssignedArray;
                calculateProjection();
                saveToLocalStorage();
            }
        }
        
        window.handleAssignmentChange = (selectElement, ticketId) => {
            const newAssignedArray = Array.from(selectElement.selectedOptions).map(o => o.value);
            window.updateTicketAssignment(ticketId, newAssignedArray);
        }

        window.handleSizeChange = (selectElement, ticketId) => {
            const newSize = selectElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldSize = ticket.size;
                ticket.size = newSize;
                
                // Provide visual feedback
                selectElement.style.background = '#dcfce7'; // Light green background
                setTimeout(() => {
                    selectElement.style.background = 'white';
                }, 500);
                
                // Recalculate and re-render immediately
                calculateProjection();
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`📊 Ticket #${ticketId} size changed from ${oldSize} to ${newSize} - recalculating...`);
            }
        }

        window.handleStartDateChange = (inputElement, ticketId) => {
            const newStartDate = inputElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldStartDate = ticket.startDate;
                ticket.startDate = newStartDate;
                
                // Provide visual feedback
                inputElement.style.background = '#dcfce7'; // Light green background
                setTimeout(() => {
                    inputElement.style.background = 'white';
                }, 500);
                
                // Refresh people display since earliest task date might have changed
                if (!useCommonStartDate) {
                    renderPeople();
                }
                
                // Recalculate and re-render immediately
                calculateProjection();
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`📅 Ticket #${ticketId} start date changed from ${formatDate(oldStartDate)} to ${formatDate(newStartDate)} - recalculating...`);
            }
        }

        // --- CALCULATION DETAILS MODAL FUNCTIONS ---

        window.showCalculationDetails = (ticketId) => {
            // Find the ticket and get its calculation details
            const projectedTickets = getProjectedTickets();
            const ticket = projectedTickets.find(t => t.id === ticketId);
            
            if (!ticket) {
                alert('Ticket not found.');
                return;
            }
            
            // Create enhanced content with better formatting
            const enhancedContent = `
🎯 TICKET: ${ticket.description} (ID: ${ticket.id})
📊 SIZE: ${ticket.size} 
📅 START DATE: ${formatDate(ticket.startDate)}
👥 ASSIGNED TO: ${ticket.assigned.join(', ')}
🎌 PROJECTED END: ${ticket.endDate}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

${ticket.explanation}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 HOW TO READ this calculation:
• Week numbers correspond to the planning horizon (5 weeks total)
• Pooled Capacity = combined hours available from all assigned team members
• Hours are distributed proportionally based on each person's availability
• Task completes when all required hours are allocated
• Any capacity constraints or delays are noted in the weekly breakdown
            `.trim();
            
            // Update modal content
            document.getElementById('modal-title').textContent = `📊 Calculation Details - Ticket #${ticket.id}`;
            document.getElementById('calculation-content').textContent = enhancedContent;
            
            // Show modal
            const modal = document.getElementById('calculation-modal');
            modal.classList.add('active');
            
            // Add event listener for clicking outside modal to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeCalculationModal();
                }
            });
        }

        window.closeCalculationModal = () => {
            const modal = document.getElementById('calculation-modal');
            modal.classList.remove('active');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeCalculationModal();
            }
        });


        // --- INITIALIZATION ---

        function initializeDefaultData() {
            console.log("Setting up default people data.");
            people = [
                { name: 'Vipul', availability: [25, 25, 25, 25, 25] },
                { name: 'Sameet', availability: [25, 25, 25, 25, 25] },
                { name: 'Peter', availability: [25, 25, 25, 25, 25] },
                { name: 'Sharanya', availability: [25, 25, 25, 25, 25] },
                { name: 'Divya', availability: [25, 25, 25, 25, 25] },
            ];
            
            // Use realistic current dates
            const today = new Date();
            const nextMonday = getNextMonday(new Date());
            const followingMonday = new Date(nextMonday.getTime() + 7 * 24 * 60 * 60 * 1000);
            
            tickets = [
                { id: 1, description: 'Design System Migration', size: 'XL', assigned: ['Vipul', 'Peter'], startDate: nextMonday.toISOString().split('T')[0] },
                { id: 2, description: 'Fix payment gateway bug', size: 'S', assigned: ['Sameet'], startDate: nextMonday.toISOString().split('T')[0] },
                { id: 3, description: 'Build new reporting dashboard', size: 'XXL', assigned: ['Sharanya', 'Divya'], startDate: followingMonday.toISOString().split('T')[0] }
            ];
            currentTicketId = 4;
            saveToLocalStorage(); 
        }

        function initializeScheduler() {
            if (!loadFromLocalStorage()) {
                initializeDefaultData();
            }
            
            // Set default start date to next Monday
            const defaultStartDate = getNextMonday(new Date()).toISOString().split('T')[0];
            document.getElementById('new-ticket-start-date').value = defaultStartDate;
            document.getElementById('common-start-date').value = defaultStartDate;
            
            // Restore common start date state
            const checkbox = document.getElementById('use-common-start-date');
            checkbox.checked = useCommonStartDate;
            if (useCommonStartDate) {
                toggleCommonStartDate();
            }
            
            // Initial render
            calculateEffortMap();
            renderEffortMap();
            renderPeople();
            calculateProjection(); // This now includes timeline rendering
        }

        // Start the application
        window.onload = initializeScheduler;
    </script>
</body>
</html>
