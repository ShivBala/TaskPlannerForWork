<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enterprise Project Scheduler with Task Tracking</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Banking/Enterprise Theme */
        :root {
            --primary-color: #1e3a8a; /* Deep blue */
            --secondary-color: #374151; /* Dark gray */
            --accent-color: #059669; /* Professional green */
            --warning-color: #d97706; /* Amber */
            --danger-color: #dc2626; /* Red */
            --background-color: #f8fafc; /* Light gray */
            --card-background: #ffffff;
            --border-color: #e5e7eb;
        }
        
        /* Custom styles for enterprise feel */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
            color: var(--secondary-color);
        }
        
        .enterprise-container {
            max-width: 1600px;
        }
        
        .input-card, .output-card {
            background: var(--card-background);
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }
        
        /* Dirty state - unsaved changes indicator */
        .input-card.dirty, .output-card.dirty, div.card.dirty {
            background: #f0fdfa !important; /* Light teal background */
            border: 1px solid #5eead4 !important; /* Teal border */
            box-shadow: 0 2px 4px rgba(45, 212, 191, 0.1) !important;
        }
        
        /* Force override any Tailwind background classes */
        .dirty {
            background-color: #f0fdfa !important;
            border-color: #5eead4 !important;
        }
        
        .input-card:hover, .output-card:hover {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07);
        }
        
        .input-card.dirty:hover, .output-card.dirty:hover, .card.dirty:hover {
            box-shadow: 0 4px 6px rgba(45, 212, 191, 0.15);
        }
        
        .enterprise-header {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            border-bottom: 3px solid var(--accent-color);
        }
        
        /* Compact Enterprise Task Sizing */
        .task-size-manager {
            background: linear-gradient(135deg, var(--primary-color) 0%, #1e40af 100%);
            color: white;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .task-size-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 8px;
            margin-bottom: 8px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .task-size-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }
        
        .size-input-enhanced {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--secondary-color);
            font-weight: 600;
            text-align: center;
            width: 70px;
            font-size: 11px;
        }
        
        .size-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .size-label-enhanced {
            font-weight: bold;
            font-size: 12px;
            min-width: 50px;
        }
        
        .size-metrics {
            font-size: 10px;
            opacity: 0.9;
            margin-top: 3px;
        }
        
        .preset-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }
        
        .custom-size-form {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            padding: 12px;
            margin-top: 12px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
        }
        
        /* Enterprise Timeline Styles */
        .timeline-container {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #bae6fd;
        }
        
        /* Custom scrollbar styles for timeline */
        .timeline-scroll-container {
            scrollbar-width: thin;
            scrollbar-color: #6b7280 #f3f4f6;
        }
        
        .timeline-scroll-container::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-track {
            background: #f3f4f6;
            border-radius: 6px;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-thumb {
            background: #6b7280;
            border-radius: 6px;
            border: 2px solid #f3f4f6;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-thumb:hover {
            background: #4b5563;
        }
        
        .timeline-scroll-container::-webkit-scrollbar-corner {
            background: #f3f4f6;
        }
        
        /* Modal Styles for Banking */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(30, 58, 138, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .modal-content {
            background: var(--card-background);
            border-radius: 8px;
            padding: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            transform: scale(0.9);
            transition: transform 0.3s ease;
            margin: 20px;
            width: calc(100% - 40px);
            border: 2px solid var(--primary-color);
        }
        
        @media (min-width: 640px) {
            .modal-content {
                width: auto;
                margin: 0;
            }
        }
        
        .modal-overlay.active .modal-content {
            transform: scale(1);
        }
        
        .modal-header {
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 12px;
            margin-bottom: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 4px;
            border-radius: 4px;
            transition: background-color 0.2s;
        }
        
        .modal-close:hover {
            background-color: #f3f4f6;
        }
        
        .calculation-details {
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.5;
            white-space: pre-wrap;
            background: #f8fafc;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid var(--primary-color);
            max-height: 350px;
            overflow-y: auto;
        }
        
        .details-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            margin-left: 6px;
            transition: background-color 0.2s;
        }
        
        .details-btn:hover {
            background: #1e40af;
        }
        
        /* Size Dropdown Banking Style */
        .size-dropdown {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 11px;
            font-weight: 600;
            color: var(--primary-color);
            background: white;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            min-width: 70px;
        }
        
        .size-dropdown:hover {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 1px var(--primary-color);
        }
        
        .size-dropdown:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(30, 58, 138, 0.2);
        }
        
        .size-dropdown option {
            padding: 3px;
            font-weight: normal;
        }
        
        /* Timeline Styles */
        .timeline-marker {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
        }
        
        .timeline-marker:hover {
            transform: translateY(-50%) scale(1.2);
            z-index: 101;
        }
        
        .timeline-marker.active {
            transform: translateY(-50%) scale(1.4);
            z-index: 102;
        }
        
        /* Timeline Tooltip */
        .timeline-tooltip {
            position: absolute;
            bottom: 150%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            white-space: normal;
            pointer-events: none;
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            margin-bottom: 12px;
            min-width: 350px;
            max-width: 450px;
            width: 400px;
            text-align: left;
            line-height: 1.4;
        }
        
        .timeline-tooltip.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-8px);
        }
        
        .timeline-tooltip.tooltip-left.visible {
            opacity: 1;
            transform: translateX(0) translateY(-8px);
        }
        
        .timeline-tooltip.tooltip-right.visible {
            opacity: 1;
            transform: translateX(0) translateY(-8px);
        }
        
        .timeline-tooltip.tooltip-center.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-8px);
        }
        
        .timeline-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 8px solid transparent;
            border-top-color: rgba(0, 0, 0, 0.9);
        }
        
        .timeline-tooltip.tooltip-left::after {
            left: 20px;
            transform: translateX(0);
        }
        
        .timeline-tooltip.tooltip-right::after {
            left: auto;
            right: 20px;
            transform: translateX(0);
        }
        
        .timeline-delayed {
            background: linear-gradient(45deg, var(--danger-color) 0%, #b91c1c 100%);
        }
        
        .timeline-ontime {
            background: linear-gradient(45deg, var(--accent-color) 0%, #047857 100%);
        }
        
        .timeline-legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            font-size: 11px;
        }
        
        .timeline-legend-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }
        
        .tooltip-container {
            position: relative;
            cursor: pointer;
        }
        
        .tooltip-text {
            visibility: hidden;
            width: 280px;
            background-color: var(--secondary-color);
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 10;
            bottom: 125%;
            left: 50%;
            margin-left: -140px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            pointer-events: none;
            white-space: pre-wrap;
        }
        
        .tooltip-container:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Select dropdowns */
        .select-multiple {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 20 20' fill='none' stroke='%236b7280'%3e%3cpath d='M7 7l3-3 3 3m0 6l-3 3-3-3' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em;
        }
        
        /* Compact spacing */
        .compact-spacing {
            gap: 12px;
        }
        
        .compact-card {
            padding: 12px;
        }
        
        /* Enterprise buttons */
        .btn-enterprise {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }
        
        .btn-enterprise:hover {
            background: #1e40af;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .btn-secondary {
            background: var(--secondary-color);
        }
        
        .btn-secondary:hover {
            background: #4b5563;
        }
        
        .btn-success {
            background: var(--accent-color);
        }
        
        .btn-success:hover {
            background: #047857;
        }
        
        .btn-danger {
            background: var(--danger-color);
        }
        
        .btn-danger:hover {
            background: #b91c1c;
        }
        
        /* Main layout override for better control */
        #main-content {
            display: block !important;
            margin-bottom: 2rem !important;
        }
        
        @media (max-width: 1024px) {
            #main-content {
                display: block !important;
            }
            
            .task-config-container {
                width: 100% !important;
                float: none !important;
                margin-right: 0 !important;
                margin-bottom: 20px !important;
            }
        }
        
        /* Task Configuration on the left - fixed sizing */
        .task-config-container {
            width: 350px !important;
            max-width: 350px !important;
            float: left !important;
            margin-right: 20px !important;
            margin-bottom: 20px !important;
        }
        
        /* Task management area - clear the float */
        .task-management-area {
            overflow: hidden !important;
        }
        
        /* Vertical arrangement for task size cards */
        #task-size-cards.space-y-2 > * + * {
            margin-top: 0.5rem !important;
        }
        
        /* Team Availability Scrollable Area Styles */
        .team-availability-scroll {
            scrollbar-width: thin;
            scrollbar-color: #cbd5e1 #f1f5f9;
            position: relative;
        }
        
        .team-availability-scroll::-webkit-scrollbar {
            width: 6px;
        }
        
        .team-availability-scroll::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 3px;
        }
        
        .team-availability-scroll::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }
        
        .team-availability-scroll::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        
        /* Scroll fade indicator */
        .team-availability-scroll::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(transparent, rgba(248, 250, 252, 0.8));
            pointer-events: none;
            border-radius: 0 0 8px 8px;
        }
        
        /* Enhanced hover effects for people cards in scroll area */
        .team-availability-scroll .person-card {
            transition: all 0.2s ease;
        }
        
        .team-availability-scroll .person-card:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        /* Compact table styles */
        .enterprise-table {
            font-size: 12px;
        }
        
        .enterprise-table th {
            padding: 8px 12px;
            background: var(--primary-color);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 10px;
            letter-spacing: 0.5px;
        }
        
        .enterprise-table td {
            padding: 6px 12px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .enterprise-table tr:hover {
            background: rgba(30, 58, 138, 0.03);
        }
        
        /* Enterprise Input Styling */
        .enterprise-input {
            background: var(--card-background);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 12px;
            color: var(--secondary-color);
            font-weight: 500;
            transition: all 0.2s ease;
            outline: none;
        }
        
        .enterprise-input:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(30, 58, 138, 0.1);
        }
        
        .enterprise-input:hover {
            border-color: var(--primary-color);
        }
        
        /* Enhanced Form Styling */
        .form-section {
            transition: all 0.3s ease;
        }
        
        .form-section:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }
        
        /* Compact spacing utilities */
        .compact-grid {
            gap: 0.75rem;
        }
        
        .compact-grid input,
        .compact-grid select {
            height: 36px;
        }
        
        /* Enhanced button styling */
        .btn-enterprise {
            position: relative;
            overflow: hidden;
        }
        
        .btn-enterprise::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }
        
        .btn-enterprise:hover::before {
            left: 100%;
        }
        
        /* Improved section headers */
        .section-header {
            border-bottom: 2px solid #e5e7eb;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
        }
        
        /* Smooth transitions for all interactive elements */
        input, select, button, .card {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Reduced margin utilities */
        .mb-tight { margin-bottom: 0.5rem; }
        .mt-tight { margin-top: 0.5rem; }
        .space-y-tight > * + * { margin-top: 0.75rem; }
        
        /* Status Badge Styles */
        .status-badge {
            display: inline-flex;
            align-items: center;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
            white-space: nowrap;
            user-select: none;
        }
        
        .status-badge:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .status-badge.status-todo {
            background: #dbeafe;
            color: #1e40af;
            border-color: #93c5fd;
        }
        
        .status-badge.status-todo:hover {
            background: #bfdbfe;
        }
        
        .status-badge.status-inprogress {
            background: #fef3c7;
            color: #d97706;
            border-color: #fcd34d;
        }
        
        .status-badge.status-inprogress:hover {
            background: #fde68a;
        }
        
        .status-badge.status-paused {
            background: #fed7aa;
            color: #ea580c;
            border-color: #fdba74;
        }
        
        .status-badge.status-paused:hover {
            background: #fec996;
        }
        
        .status-badge.status-done {
            background: #dcfce7;
            color: #166534;
            border-color: #86efac;
        }
        
        .status-badge.status-done:hover {
            background: #bbf7d0;
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div id="app" class="enterprise-container mx-auto">
        <div class="enterprise-header flex justify-between items-center mb-4 p-4 rounded-lg">
            <h1 class="text-2xl font-bold">Enterprise Project Tracking Console</h1>
            <div class="flex gap-2">
                <button onclick="exportConfiguration()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                    </svg>
                    Export Config
                </button>
                <button onclick="triggerImport()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                    </svg>
                    Import Config
                </button>
                <button onclick="triggerTaskImport()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Import Tasks
                </button>
                <button onclick="exportData()" class="btn-enterprise flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                    </svg>
                    Export Schedule
                </button>
                <button onclick="resetToDefaults()" class="btn-danger flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                    Reset
                </button>
            </div>
        </div>
        
        <p id="auth-status" class="text-xs text-gray-600 mb-3">📊 Enterprise data management - All information stored securely in browser storage.</p>
        
        <!-- Hidden file input for configuration import -->
        <input type="file" id="import-config-file" accept=".csv" style="display: none;" onchange="handleConfigImport(event)">
        
        <!-- Hidden file input for task bulk import -->
        <input type="file" id="import-tasks-file" accept=".csv" style="display: none;" onchange="handleTaskImport(event)">
        
        <div id="loading-spinner" class="text-center p-10 hidden">
            <!-- Spinner removed as local loading is instant -->
        </div>

        <div id="main-content" class="mb-8">
            
            <!-- Task Configuration - Now on the left with fixed width -->
            <div class="task-config-container input-card enterprise-table p-4 rounded-lg">
                
                <!-- Enhanced Task Sizing Management -->
                <div class="task-size-manager">
                    <h2 class="text-lg font-bold mb-3 flex items-center text-primary-dark">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" />
                        </svg>
                        📏 Task Configuration
                    </h2>
                    
                    <div class="compact-spacing">
                        <div class="mb-3 space-y-3">
                            <!-- Estimation Base Rate -->
                            <div class="flex items-center gap-4 flex-wrap">
                                <div class="flex items-center gap-2">
                                    <label class="text-base font-semibold text-white">Estimation Base (hrs/day):</label>
                                    <input type="number" id="estimation-base-hours" value="5" min="1" max="12" 
                                           onchange="updateEstimationBase(event.target.value)" 
                                           class="enterprise-input w-20 text-lg font-bold">
                                </div>
                                <div class="text-sm font-medium text-blue-100 bg-blue-800 bg-opacity-50 px-2 py-1 rounded">
                                    ℹ️ Productive hours used for task estimation (after meetings, interruptions)
                                </div>
                            </div>
                            
                            <!-- Project Context Hours -->
                            <div class="flex items-center gap-4 flex-wrap">
                                <div class="flex items-center gap-2">
                                    <label class="text-base font-semibold text-white">Project Hours/Day:</label>
                                    <input type="number" id="project-hours-per-day" value="8" min="1" max="24" 
                                           onchange="updateProjectHours(event.target.value)" 
                                           class="enterprise-input w-20 text-lg font-bold">
                                </div>
                                <div class="text-base font-medium text-blue-100 bg-blue-800 bg-opacity-50 px-2 py-1 rounded">
                                    Task Effort = Days × <span id="estimation-base-display" class="font-bold text-yellow-300">5</span>h
                                </div>
                            </div>
                        </div>
                        
                        <!-- Vertical arrangement of task size cards -->
                        <div id="task-size-cards" class="space-y-2 mb-3">
                            <!-- Enhanced task size cards will be rendered here vertically -->
                        </div>
                        
                        <div class="flex gap-2 mb-3 flex-wrap text-xs">
                            <button onclick="applyPreset('agile')" class="btn-enterprise">🏃 Agile</button>
                            <button onclick="applyPreset('enterprise')" class="btn-enterprise">🏢 Enterprise</button>
                            <button onclick="applyPreset('startup')" class="btn-enterprise">🚀 Startup</button>
                            <button onclick="applyPreset('conservative')" class="btn-enterprise">🛡️ Conservative</button>
                            <button onclick="showCustomSizeForm()" class="btn-enterprise">➕ Custom</button>
                        </div>
                        
                        <div id="custom-size-form" class="custom-size-form hidden">
                            <h4 class="font-semibold mb-2 text-sm">Add Custom Task Size</h4>
                            <div class="flex gap-2 items-end flex-wrap">
                                <div>
                                    <label class="block text-xs mb-1">Key</label>
                                    <input type="text" id="new-size-key" placeholder="XS" maxlength="4" 
                                           class="enterprise-input w-16">
                                </div>
                                <div>
                                    <label class="block text-xs mb-1">Name</label>
                                    <input type="text" id="new-size-name" placeholder="Extra Small" 
                                           class="enterprise-input w-24">
                                </div>
                                <div>
                                    <label class="block text-xs mb-1">Days</label>
                                    <input type="number" id="new-size-days" placeholder="0.5" min="0.1" max="50" step="0.5" 
                                           class="enterprise-input w-16">
                                </div>
                                <button onclick="addCustomSize()" class="btn-enterprise">Add</button>
                                <button onclick="hideCustomSizeForm()" class="btn-danger">Cancel</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Task Management - Takes remaining space -->
            <div class="task-management-area input-card enterprise-table p-4 rounded-lg">
                
                <h2 class="text-lg font-semibold mb-3 text-primary-dark flex items-center mt-4">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Task Management
                </h2>

                <!-- Common Start Date Control -->
                <!-- Enhanced Control Panel -->
                <div class="mb-3 p-4 enterprise-card border rounded-lg bg-gradient-to-r from-blue-50 to-indigo-50">
                    <div class="flex items-center justify-between gap-6">
                        <!-- Left Side: Unified Start Date Controls -->
                        <div class="flex items-center gap-4">
                            <label class="flex items-center cursor-pointer group">
                                <input type="checkbox" id="use-common-start-date" onchange="toggleCommonStartDate()" 
                                       class="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500 transition-all">
                                <span class="ml-2 text-sm font-semibold text-primary-dark group-hover:text-blue-700 transition-colors">📅 Unified Start Date</span>
                            </label>
                            <input type="date" id="common-start-date" disabled 
                                   class="enterprise-input text-sm w-36 transition-all duration-200" 
                                   title="Common start date for all tasks"
                                   onchange="updateAllTaskStartDates()">
                        </div>
                        
                        <!-- Right Side: Project Completion Info -->
                        <div class="text-right bg-white/70 backdrop-blur-sm rounded-lg p-3 border border-blue-200/50">
                            <div class="flex items-center gap-2 mb-1">
                                <span class="text-xs font-medium text-gray-600">🏁 PROJECT COMPLETION</span>
                            </div>
                            <div class="flex items-center justify-end gap-2">
                                <div class="text-sm font-bold text-blue-800" id="furthest-completion-date">No tasks</div>
                                <div class="text-xs font-medium text-white bg-blue-600 px-2 py-1 rounded-full" id="furthest-completion-week">—</div>
                            </div>
                        </div>
                    </div>
                    <div class="text-xs text-gray-600 mt-2 italic">
                        💡 Synchronizes all task start dates for streamlined project planning
                    </div>
                </div>

                <!-- Compact Task Creation Form -->
                <div class="mb-4 p-4 bg-white border rounded-lg shadow-sm">
                    <div class="flex items-center gap-2 mb-3">
                        <h3 class="font-bold text-md text-primary-dark">➕ Add New Task</h3>
                        <div class="flex-1 border-t border-gray-200"></div>
                    </div>
                    
                    <div class="grid grid-cols-1 lg:grid-cols-12 gap-3 items-end">
                        <!-- Task Description -->
                        <div class="lg:col-span-4">
                            <label class="block text-xs font-medium text-gray-700 mb-1">Task Description</label>
                            <input type="text" id="new-ticket-desc" placeholder="Enter task description..." 
                                   class="enterprise-input w-full focus:ring-2 focus:ring-blue-500 transition-all">
                        </div>
                        
                        <!-- Start Date -->
                        <div class="lg:col-span-2">
                            <label class="block text-xs font-medium text-gray-700 mb-1">Start Date</label>
                            <input type="date" id="new-ticket-start-date" 
                                   class="enterprise-input w-full focus:ring-2 focus:ring-blue-500 transition-all" title="Start Date">
                        </div>
                        
                        <!-- Size & Priority in compact layout -->
                        <div class="lg:col-span-2 grid grid-cols-2 gap-2">
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Size</label>
                                <select id="new-ticket-size" class="enterprise-input w-full focus:ring-2 focus:ring-blue-500 transition-all">
                                    <!-- Options populated dynamically by JavaScript -->
                                </select>
                            </div>
                            <div>
                                <label class="block text-xs font-medium text-gray-700 mb-1">Priority</label>
                                <select id="new-ticket-priority" class="enterprise-input w-full focus:ring-2 focus:ring-blue-500 transition-all" title="Priority">
                                    <option value="P3">P3</option>
                                    <option value="P1">P1</option>
                                    <option value="P2">P2</option>
                                    <option value="P4">P4</option>
                                    <option value="P5">P5</option>
                                </select>
                            </div>
                        </div>
                        
                        <!-- Assignment -->
                        <div class="lg:col-span-3">
                            <label class="block text-xs font-medium text-gray-700 mb-1">Assign to:</label>
                            <div id="new-ticket-assigned" class="flex flex-wrap gap-1 p-2 border border-gray-300 rounded-md bg-gray-50 min-h-[36px] items-center transition-all hover:bg-white focus-within:bg-white focus-within:border-blue-500">
                                <!-- Checkboxes populated by JS -->
                            </div>
                        </div>
                        
                        <!-- Add Button -->
                        <div class="lg:col-span-1">
                            <button onclick="addTicket()" class="btn-enterprise w-full h-[36px] font-semibold shadow-md hover:shadow-lg transition-all duration-200 transform hover:scale-105">
                                Add Task
                            </button>
                        </div>
                    </div>
                    
                    <!-- Compact Help Text -->
                    <div class="text-xs text-gray-500 mt-2 bg-gray-50 rounded p-2">
                        💡 <span id="start-date-help">Individual start dates enabled. Team availability calculated from earliest task.</span>
                    </div>
                </div>
                
                <!-- Task Schedule Section -->
                <div class="space-y-3">
                    <div class="flex items-center gap-2">
                        <h3 class="text-lg font-bold text-primary-dark">📋 Task Schedule</h3>
                        <div class="flex-1 border-t border-gray-300"></div>
                    </div>
                    
                    <!-- Compact Task Filtering Controls -->
                    <div id="task-filter-section" class="p-3 bg-gradient-to-r from-blue-50 to-blue-100 border border-blue-200 rounded-lg">
                        <div class="flex items-center gap-3">
                            <span class="text-sm font-semibold text-gray-700 whitespace-nowrap">🔍 Filter by person:</span>
                            <div id="person-filter-buttons" class="flex flex-wrap gap-2 flex-1">
                                <!-- Person filter buttons will be populated by JavaScript -->
                            </div>
                            <button id="clear-filter-btn" onclick="clearPersonFilter()" 
                                    class="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600 transition-colors flex-shrink-0" 
                                    style="display: none;">
                                Clear
                            </button>
                        </div>
                        <div class="flex items-center gap-3 mt-2">
                            <span class="text-sm font-semibold text-gray-700 whitespace-nowrap">📊 Filter by status:</span>
                            <div id="status-filter-buttons" class="flex flex-wrap gap-2 flex-1">
                                <!-- Status filter buttons will be populated by JavaScript -->
                            </div>
                            <button id="clear-status-filter-btn" onclick="clearStatusFilter()" 
                                    class="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600 transition-colors flex-shrink-0" 
                                    style="display: none;">
                                Clear
                            </button>
                        </div>
                        <div class="flex items-center gap-3 mt-2">
                            <span class="text-sm font-semibold text-gray-700 whitespace-nowrap">📅 Filter by date:</span>
                            <div id="date-filter-buttons" class="flex flex-wrap gap-2 flex-1">
                                <!-- Date filter buttons will be populated by JavaScript -->
                            </div>
                            <button id="clear-date-filter-btn" onclick="clearDateFilter()" 
                                    class="px-2 py-1 bg-red-500 text-white rounded text-xs hover:bg-red-600 transition-colors flex-shrink-0" 
                                    style="display: none;">
                                Clear
                            </button>
                        </div>
                        <div id="filter-status" class="text-xs text-gray-600 mt-2" style="display: none;">
                            <!-- Filter status will be shown here -->
                        </div>
                    </div>
                    
                    <div class="overflow-x-auto rounded-lg border">
                        <table class="enterprise-table min-w-full divide-y">
                            <thead>
                                <tr>
                                    <th class="px-3 py-2 text-left w-16">ID</th>
                                    <th class="px-3 py-2 text-left min-w-0 flex-1">Description</th>
                                    <th class="px-3 py-2 text-left w-32">
                                        <span id="start-date-column-header">Start Date</span>
                                    </th>
                                    <th class="px-3 py-2 text-left w-20">Size</th>
                                    <th class="px-3 py-2 text-left w-20">Priority</th>
                                    <th class="px-3 py-2 text-left w-24">Status</th>
                                    <th class="px-3 py-2 text-left w-48">Assigned</th>
                                    <th class="px-3 py-2 text-left w-32 tooltip-container">End Date
                                        <div class="tooltip-text">
                                            Calculated from start date, team availability, and effort hours.
                                        </div>
                                    </th>
                                    <th class="px-3 py-2 text-left w-24">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="ticket-table-body" class="divide-y">
                                <!-- Tickets will be rendered here -->
                            </tbody>
                        </table>
                    </div>
                    <p id="no-tickets" class="text-center py-3 text-gray-500 hidden">No tasks defined. Add a task to begin!</p>
                </div>
                </div>
                <!-- End task-management-area -->
                
            </div>
            <!-- End right-side-container -->
            
        </div>
        <!-- End main-content -->
        
    </div>

    <!-- Modal for Calculation Details -->
    <div id="calculation-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-title">Calculation Details</h3>
                <button class="modal-close" onclick="closeCalculationModal()">&times;</button>
            </div>
            <div class="calculation-details" id="calculation-content">
                <!-- Calculation details will be populated here -->
            </div>
        </div>
    </div>

    <!-- Team Workload Heat Map Section -->
    <div class="container mx-auto px-4 py-6">
        <div class="card">
            <div class="card-header">
                <div class="flex justify-between items-center">
                    <div>
                        <h2 class="card-title">📊 Team Workload Heat Map (Next 8 Weeks)</h2>
                        <p class="text-sm text-gray-600 mt-1">Visual overview of team capacity utilization based on individual availability</p>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="openBulkTaskResolution()" class="btn-enterprise flex items-center gap-2">
                            <span>✅</span>
                            Resolve Completed
                        </button>
                        <button onclick="generateDelayAnalysis()" class="btn-enterprise flex items-center gap-2">
                            <span>⏰</span>
                            Analyze Start Date Delays
                        </button>
                        <button onclick="generateCompletionGraph()" class="btn-enterprise flex items-center gap-2">
                            <span>📈</span>
                            Generate Completion Graph
                        </button>
                        <button onclick="exportTaskMapCSV()" class="btn-enterprise flex items-center gap-2">
                            <span>📊</span>
                            Export Task Map CSV
                        </button>
                    </div>
                </div>
            </div>
            <div class="card-content">
                <div id="workload-heatmap" class="overflow-x-auto">
                    <!-- Heat map will be rendered here -->
                </div>
                <div class="mt-4 flex flex-wrap gap-4 text-sm">
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-green-100 border border-green-300 rounded"></div>
                        <span>0-60% Capacity (Available)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-yellow-100 border border-yellow-300 rounded"></div>
                        <span>61-90% Capacity (Busy)</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <div class="w-4 h-4 bg-red-100 border border-red-300 rounded"></div>
                        <span>91%+ Capacity (Overloaded)</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Completion Graph Modal -->
    <div id="completionGraphModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-6xl w-full mx-4 max-h-[90vh] overflow-auto">
            <div class="flex justify-between items-center p-6 border-b">
                <h2 class="text-2xl font-bold text-gray-800">📈 Task Completion Projection</h2>
                <button onclick="closeCompletionGraph()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div class="p-6">
                <div id="completionGraphContent" class="w-full h-96">
                    <!-- Graph will be rendered here -->
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <p><strong>📊 Chart Explanation:</strong> This graph shows the projected completion dates for all tasks based on current scheduling and team capacity.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Delay Analysis Modal -->
    <div id="delayAnalysisModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-6xl w-full mx-4 max-h-[90vh] overflow-auto">
            <div class="flex justify-between items-center p-6 border-b">
                <h2 class="text-2xl font-bold text-gray-800">⏰ Start Date Delay Analysis</h2>
                <button onclick="closeDelayAnalysis()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div class="p-6">
                <div id="delayAnalysisContent" class="w-full">
                    <!-- Analysis will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Bulk Task Resolution Modal -->
    <div id="bulkTaskResolutionModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg shadow-xl max-w-5xl w-full mx-4 max-h-[90vh] overflow-auto">
            <div class="flex justify-between items-center p-6 border-b">
                <h2 class="text-2xl font-bold text-gray-800">✅ Resolve Completed Tasks</h2>
                <button onclick="closeBulkTaskResolution()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
            </div>
            <div class="p-6">
                <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <p class="text-sm text-blue-800">
                        <strong>📋 Tasks shown:</strong> "In Progress" tasks with calculated end dates in the past (overdue).
                        Use the actions below to resolve each task or extend deadlines as needed.
                    </p>
                </div>
                <div id="bulkTaskResolutionContent" class="w-full">
                    <!-- Task resolution content will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Team Configuration Section -->
    <div class="container mx-auto px-4 py-6">
        <div class="card">
            <div class="card-header">
                <h2 class="card-title">👥 Team Configuration</h2>
                <p id="availability-header" class="text-sm text-gray-600 mt-1">Team Availability (Next 8 Weeks)</p>
            </div>
            <div class="card-content">
                <!-- People list with larger cards for configuration -->
                <div id="people-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 mb-6">
                    <!-- People cards will be rendered here in grid -->
                </div>
                
                <!-- Add member section -->
                <div class="border-t pt-4">
                    <h3 class="text-lg font-semibold mb-3">Add New Team Member</h3>
                    <div class="flex gap-3 items-center max-w-md">
                        <input type="text" id="new-person-name" placeholder="Enter team member name" class="enterprise-input flex-grow">
                        <button onclick="addPerson()" class="btn-enterprise">Add Member</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Week Task Details Modal -->
    <div id="week-task-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
        <div class="bg-white rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[80vh] overflow-hidden">
            <div class="bg-blue-600 text-white px-6 py-4 flex justify-between items-center">
                <h3 id="modal-title" class="text-xl font-semibold">Week Task Details</h3>
                <button onclick="closeWeekTaskModal()" class="text-white hover:text-gray-200 text-2xl">&times;</button>
            </div>
            <div class="p-6 overflow-y-auto max-h-[60vh]">
                <div id="modal-content">
                    <!-- Task details will be loaded here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL CONFIG & STATE ---
        const STORAGE_KEY = 'projectSchedulerDataV2';
        let people = [];
        let tickets = [];
        let estimationBaseHours = 5; // Hours per day used for initial task estimation (after meetings, etc.)
        let projectHoursPerDay = 8; // Actual available hours per day in current project context 
        let ticketDays = {
            S: 1, M: 2, L: 5, XL: 10, XXL: 15
        };
        
        // Enhanced task sizing with display names and presets
        let taskSizeDefinitions = {
            S: { name: 'Small', days: 1, removable: false },
            M: { name: 'Medium', days: 2, removable: false },
            L: { name: 'Large', days: 5, removable: false },
            XL: { name: 'X-Large', days: 10, removable: false },
            XXL: { name: 'XX-Large', days: 15, removable: false }
        };

        // --- UTILITY FUNCTIONS ---
        
        // Get local date string in YYYY-MM-DD format (avoids timezone issues with toISOString)
        function getLocalDateString(date) {
            return date.getFullYear() + '-' + 
                String(date.getMonth() + 1).padStart(2, '0') + '-' + 
                String(date.getDate()).padStart(2, '0');
        }

        // Initialize start date history for backward compatibility
        function initializeStartDateHistory(ticket) {
            if (!ticket.startDateHistory) {
                ticket.startDateHistory = [];
                // Add current start date as the initial entry if it exists
                if (ticket.startDate) {
                    ticket.startDateHistory.push({
                        date: ticket.startDate,
                        timestamp: new Date().toISOString(),
                        reason: 'Initial planning'
                    });
                }
            }
            return ticket;
        }

        // Track start date changes
        function trackStartDateChange(ticket, oldDate, newDate, reason = 'Manual update') {
            initializeStartDateHistory(ticket);
            
            // Only track if the date actually changed
            if (oldDate !== newDate) {
                ticket.startDateHistory.push({
                    date: newDate,
                    timestamp: new Date().toISOString(),
                    reason: reason,
                    previousDate: oldDate
                });
                
                console.log(`📅 Start date changed for "${ticket.description}": ${oldDate} → ${newDate} (${reason})`);
            }
        }

        // Initialize end date history for backward compatibility
        function initializeEndDateHistory(ticket) {
            if (!ticket.endDateHistory) {
                ticket.endDateHistory = [];
            }
            return ticket;
        }

        // Track end date changes
        function trackEndDateChange(ticket, oldDate, newDate, reason = 'Date extension') {
            initializeEndDateHistory(ticket);
            
            // Only track if the date actually changed
            if (oldDate !== newDate) {
                ticket.endDateHistory.push({
                    date: newDate,
                    timestamp: new Date().toISOString(),
                    reason: reason,
                    previousDate: oldDate
                });
                
                console.log(`📅 End date changed for "${ticket.description}": ${oldDate} → ${newDate} (${reason})`);
            }
        }

        // Initialize size history for backward compatibility
        function initializeSizeHistory(ticket) {
            if (!ticket.sizeHistory) {
                ticket.sizeHistory = [];
                // Add current size as the initial entry if it exists
                if (ticket.size) {
                    ticket.sizeHistory.push({
                        size: ticket.size,
                        days: taskSizeDefinitions[ticket.size]?.days || 0,
                        timestamp: new Date().toISOString(),
                        reason: 'Initial sizing'
                    });
                }
            }
            return ticket;
        }

        // Track size changes
        function trackSizeChange(ticket, oldSize, newSize, reason = 'Manual update') {
            initializeSizeHistory(ticket);
            
            // Only track if the size actually changed
            if (oldSize !== newSize) {
                ticket.sizeHistory.push({
                    size: newSize,
                    days: taskSizeDefinitions[newSize]?.days || 0,
                    timestamp: new Date().toISOString(),
                    reason: reason,
                    previousSize: oldSize,
                    previousDays: taskSizeDefinitions[oldSize]?.days || 0
                });
                
                console.log(`📊 Size changed for "${ticket.description}": ${oldSize} → ${newSize} (${reason})`);
            }
        }
        
        let effortMap = {};
        let currentTicketId = 1;
        let useCommonStartDate = false;

        // Task filtering variables
        let selectedPersonFilters = []; // Array to track which people are selected for filtering
        let selectedStatusFilters = []; // Array to track which statuses are selected for filtering
        let selectedDateFilters = []; // Array to track which date ranges are selected for filtering
        
        // --- DIRTY STATE MANAGEMENT ---
        let isDirty = false; // Track if there are unsaved changes
        
        function setDirtyState(dirty = true) {
            isDirty = dirty;
            const cards = document.querySelectorAll('.input-card, .output-card, .card');
            
            if (dirty) {
                cards.forEach(card => card.classList.add('dirty'));
                // Update page title to show unsaved changes
                document.title = '💾 Enterprise Project Tracking Console (Unsaved Changes)';
                console.log('💾 Unsaved changes detected - export configuration to save');
            } else {
                cards.forEach(card => card.classList.remove('dirty'));
                // Reset page title
                document.title = 'Enterprise Project Tracking Console';
                console.log('✅ Configuration saved - all changes exported');
            }
        }
        
        function markDirty() {
            if (!isDirty) {
                setDirtyState(true);
            }
        }
        
        function markClean() {
            setDirtyState(false);
        }

        // Date constants (used as the start of Week 1)
        const startDate = getNextMonday(new Date());
        
        // Get effective start date for calculations (either default, common, or earliest task date)
        function getEffectiveStartDate() {
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                if (commonDate) {
                    const date = new Date(commonDate);
                    // Find the Monday of the week containing this date
                    return getMondayOfWeek(date);
                }
            }
            
            // Always try to find the earliest start date among all tasks first
            const earliestTaskDate = getEarliestTaskStartDate();
            if (earliestTaskDate) {
                // Find the Monday of the week containing the earliest date
                return getMondayOfWeek(earliestTaskDate);
            }
            
            // Only fall back to default startDate if no tasks exist
            return startDate;
        }
        
        // Get the Monday of the week containing the given date
        function getMondayOfWeek(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Sunday being 0
            const monday = new Date(d.setDate(diff));
            monday.setHours(0, 0, 0, 0);
            return monday;
        }
        
        // Get the earliest start date from all defined tasks
        function getEarliestTaskStartDate() {
            if (tickets.length === 0) return null;
            
            const taskDates = tickets
                .map(ticket => ticket.startDate ? new Date(ticket.startDate) : null)
                .filter(date => date !== null)
                .sort((a, b) => a - b);
            
            return taskDates.length > 0 ? taskDates[0] : null;
        }

        // --- LOCAL STORAGE FUNCTIONS (Persistence) ---

        function saveToLocalStorage() {
            console.log('💾 Saving to localStorage...');
            console.log('📊 taskSizeDefinitions being saved:', taskSizeDefinitions);
            
            const data = {
                people,
                tickets,
                estimationBaseHours,
                projectHoursPerDay,
                ticketDays,
                taskSizeDefinitions,
                currentTicketId,
                useCommonStartDate,
                lastUpdated: new Date().toISOString()
            };
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
                console.log('✅ Save successful');
            } catch (e) {
                console.error("Error saving to local storage:", e);
            }
        }

        function loadFromLocalStorage() {
            try {
                console.log('🔧 Loading from localStorage...');
                const storedData = localStorage.getItem(STORAGE_KEY);
                if (storedData) {
                    console.log('📦 Found stored data, parsing...');
                    const data = JSON.parse(storedData);
                    people = data.people || [];
                    
                    // Add backwards compatibility for isProjectReady field
                    people.forEach(person => {
                        if (person.isProjectReady === undefined) {
                            person.isProjectReady = true; // Default to true for existing data
                        }
                    });
                    
                    tickets = data.tickets || [];
                    
                    // Initialize all history for backward compatibility
                    tickets = tickets.map(ticket => {
                        ticket = initializeStartDateHistory(ticket);
                        ticket = initializeEndDateHistory(ticket);
                        ticket = initializeSizeHistory(ticket);
                        return ticket;
                    });
                    estimationBaseHours = data.estimationBaseHours || 5;
                    projectHoursPerDay = data.projectHoursPerDay || data.hoursPerDay || 8; // Migration from old hoursPerDay
                    ticketDays = data.ticketDays || { S: 1, M: 2, L: 5, XL: 10, XXL: 15 };
                    
                    console.log('📊 Loaded taskSizeDefinitions from storage:', data.taskSizeDefinitions);
                    taskSizeDefinitions = data.taskSizeDefinitions || {
                        S: { name: 'Small', days: 1, removable: false },
                        M: { name: 'Medium', days: 2, removable: false },
                        L: { name: 'Large', days: 5, removable: false },
                        XL: { name: 'X-Large', days: 10, removable: false },
                        XXL: { name: 'XX-Large', days: 15, removable: false }
                    };
                    console.log('📊 Final taskSizeDefinitions after loading:', taskSizeDefinitions);
                    
                    // Backup the loaded task size definitions
                    backupTaskSizeDefinitions();
                    
                    currentTicketId = data.currentTicketId || (tickets.length > 0 ? Math.max(...tickets.map(t => t.id)) + 1 : 1);
                    useCommonStartDate = data.useCommonStartDate || false;
                    
                    // Sync ticketDays with taskSizeDefinitions
                    console.log('🔄 About to sync task sizes...');
                    syncTaskSizes();
                    console.log('📊 taskSizeDefinitions after sync:', taskSizeDefinitions);
                    
                    // Migrate people availability arrays to 8 weeks if needed
                    migratePeopleToEightWeeks();
                    
                    // Mark as clean since we just loaded existing data
                    markClean();
                    
                    return true;
                }
            } catch (e) {
                console.error("Error loading from local storage:", e);
            }
            return false;
        }
        
        function syncTaskSizes() {
            // Ensure ticketDays and taskSizeDefinitions stay in sync
            Object.keys(taskSizeDefinitions).forEach(key => {
                ticketDays[key] = taskSizeDefinitions[key].days;
            });
        }
        
        function migratePeopleToEightWeeks() {
            // Migrate existing people data to 8-week availability arrays
            people.forEach(person => {
                if (!person.availability) {
                    // If no availability array, create default 8-week array
                    person.availability = [25, 25, 25, 25, 25, 25, 25, 25];
                } else if (person.availability.length < 8) {
                    // If availability array is shorter than 8 weeks, extend it
                    const lastValue = person.availability[person.availability.length - 1] || 25;
                    while (person.availability.length < 8) {
                        person.availability.push(lastValue); // Use last known value as default
                    }
                } else if (person.availability.length > 8) {
                    // If somehow longer than 8, truncate (shouldn't happen but just in case)
                    person.availability = person.availability.slice(0, 8);
                }
            });
            
            // Save the migrated data
            saveToLocalStorage();
        }

        // --- UTILITY FUNCTIONS ---

        function getNextMonday(date) {
            const d = new Date(date);
            const currentDay = d.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            // Calculate days until next Monday
            let daysUntilMonday;
            if (currentDay === 0) { // Sunday
                daysUntilMonday = 1;
            } else if (currentDay === 1) { // Monday
                // If it's Monday and it's still early (before 9 AM), use today
                // Otherwise, use next Monday
                daysUntilMonday = (d.getHours() < 9) ? 0 : 7;
            } else { // Tuesday to Saturday
                daysUntilMonday = 8 - currentDay; // Days to next Monday
            }
            
            const nextMonday = new Date(d);
            nextMonday.setDate(d.getDate() + daysUntilMonday);
            nextMonday.setHours(0, 0, 0, 0);
            
            return nextMonday;
        }

        // --- TASK FILTERING FUNCTIONS ---

        function generatePersonFilterButtons() {
            const container = document.getElementById('person-filter-buttons');
            if (!container) return;
            
            container.innerHTML = '';
            
            people.forEach(person => {
                const button = document.createElement('button');
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border';
                button.textContent = person.name;
                button.onclick = () => togglePersonFilter(person.name);
                button.setAttribute('data-person', person.name);
                
                // Set initial state
                updatePersonFilterButtonState(button, person.name);
                
                container.appendChild(button);
            });
        }

        function updatePersonFilterButtonState(button, personName) {
            const isSelected = selectedPersonFilters.includes(personName);
            
            if (isSelected) {
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-blue-600 text-white border-blue-600 font-medium';
                button.title = `✓ Showing ${personName}'s tasks (click to remove filter)`;
            } else if (selectedPersonFilters.length > 0) {
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-gray-100 text-gray-500 border-gray-300';
                button.title = `Click to show ${personName}'s tasks`;
            } else {
                button.className = 'person-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-white text-gray-700 border-gray-300 hover:bg-gray-50';
                button.title = `Click to filter ${personName}'s tasks`;
            }
        }

        function togglePersonFilter(personName) {
            if (selectedPersonFilters.includes(personName)) {
                // Remove from filter
                selectedPersonFilters = selectedPersonFilters.filter(name => name !== personName);
            } else {
                // Add to filter
                selectedPersonFilters.push(personName);
            }
            
            updateFilterUI();
            updateTable(); // Re-render the table with filtering applied
        }

        function clearPersonFilter() {
            selectedPersonFilters = [];
            updateFilterUI();
            updateTable(); // Re-render the table
        }

        function updateFilterUI() {
            try {
                // Update all person filter button states
                document.querySelectorAll('.person-filter-btn').forEach(button => {
                    const personName = button.getAttribute('data-person');
                    updatePersonFilterButtonState(button, personName);
                });
                
                // Update all status filter button states
                document.querySelectorAll('.status-filter-btn').forEach(button => {
                    const status = button.getAttribute('data-status');
                    updateStatusFilterButtonState(button, status);
                });
                
                // Update all date filter button states
                document.querySelectorAll('.date-filter-btn').forEach(button => {
                    const dateRange = button.getAttribute('data-date');
                    updateDateFilterButtonState(button, dateRange);
                });
                
                // Update filter status and clear buttons
                const filterStatus = document.getElementById('filter-status');
                const clearBtn = document.getElementById('clear-filter-btn');
                const clearStatusBtn = document.getElementById('clear-status-filter-btn');
                const clearDateBtn = document.getElementById('clear-date-filter-btn');
                
                if (!filterStatus) {
                    console.warn('Filter status element not found');
                    return;
                }
                
                // Show/hide person clear button
                if (clearBtn) {
                    clearBtn.style.display = selectedPersonFilters.length > 0 ? 'inline-block' : 'none';
                }
                
                // Show/hide status clear button
                if (clearStatusBtn) {
                    clearStatusBtn.style.display = selectedStatusFilters.length > 0 ? 'inline-block' : 'none';
                }
                
                // Show/hide date clear button
                if (clearDateBtn) {
                    clearDateBtn.style.display = selectedDateFilters.length > 0 ? 'inline-block' : 'none';
                }
                
                // Update filter status message
                if (selectedPersonFilters.length === 0 && selectedStatusFilters.length === 0 && selectedDateFilters.length === 0) {
                    filterStatus.style.display = 'none';
                } else {
                    filterStatus.style.display = 'block';
                    
                    const filteredTaskCount = getFilteredTickets().length;
                    let statusMessage = 'Showing tasks';
                    
                    if (selectedPersonFilters.length > 0) {
                        statusMessage += ` assigned to: <strong>${selectedPersonFilters.join(', ')}</strong>`;
                    }
                    
                    if (selectedStatusFilters.length > 0) {
                        if (selectedPersonFilters.length > 0) statusMessage += ' and';
                        statusMessage += ` with status: <strong>${selectedStatusFilters.join(', ')}</strong>`;
                    }
                    
                    if (selectedDateFilters.length > 0) {
                        if (selectedPersonFilters.length > 0 || selectedStatusFilters.length > 0) statusMessage += ' and';
                        statusMessage += ` active in: <strong>${selectedDateFilters.join(', ')}</strong>`;
                    }
                    
                    statusMessage += ` (${filteredTaskCount} task${filteredTaskCount !== 1 ? 's' : ''} visible)`;
                    
                    filterStatus.innerHTML = statusMessage;
                }
            } catch (error) {
                console.error('Error updating filter UI:', error);
            }
        }

        // --- STATUS FILTERING FUNCTIONS ---

        function generateStatusFilterButtons() {
            const container = document.getElementById('status-filter-buttons');
            if (!container) return;
            
            container.innerHTML = '';
            
            const statuses = ['To Do', 'In Progress', 'Paused', 'Done'];
            const statusIcons = {
                'To Do': '📋',
                'In Progress': '🚀',
                'Paused': '⏸️',
                'Done': '✅'
            };
            
            statuses.forEach(status => {
                const button = document.createElement('button');
                button.className = 'status-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border';
                button.innerHTML = `${statusIcons[status]} ${status}`;
                button.onclick = () => toggleStatusFilter(status);
                button.setAttribute('data-status', status);
                
                // Set initial state
                updateStatusFilterButtonState(button, status);
                
                container.appendChild(button);
            });
        }

        function updateStatusFilterButtonState(button, status) {
            const isSelected = selectedStatusFilters.includes(status);
            
            if (isSelected) {
                button.className = 'status-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-green-600 text-white border-green-600 font-medium';
                button.title = `✓ Showing "${status}" tasks (click to remove filter)`;
            } else if (selectedStatusFilters.length > 0) {
                button.className = 'status-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-gray-100 text-gray-500 border-gray-300';
                button.title = `Click to show "${status}" tasks`;
            } else {
                button.className = 'status-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-white text-gray-700 border-gray-300 hover:border-green-400';
                button.title = `Click to filter by "${status}" tasks`;
            }
        }

        function toggleStatusFilter(status) {
            if (selectedStatusFilters.includes(status)) {
                // Remove from filter
                selectedStatusFilters = selectedStatusFilters.filter(s => s !== status);
            } else {
                // Add to filter
                selectedStatusFilters.push(status);
            }
            
            updateFilterUI();
            updateTable(); // Re-render the table
        }

        function clearStatusFilter() {
            selectedStatusFilters = [];
            updateFilterUI();
            updateTable(); // Re-render the table
        }

        // --- DATE FILTERING FUNCTIONS ---

        function generateDateFilterButtons() {
            const container = document.getElementById('date-filter-buttons');
            if (!container) return;
            
            container.innerHTML = '';
            
            const dateRanges = ['Today', 'This Week', 'Next Week'];
            const dateIcons = {
                'Today': '📅',
                'This Week': '📆',
                'Next Week': '🗓️'
            };
            
            dateRanges.forEach(dateRange => {
                const button = document.createElement('button');
                button.className = 'date-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border';
                button.innerHTML = `${dateIcons[dateRange]} ${dateRange}`;
                button.onclick = () => toggleDateFilter(dateRange);
                button.setAttribute('data-date', dateRange);
                
                updateDateFilterButtonState(button, dateRange);
                
                container.appendChild(button);
            });
        }

        function updateDateFilterButtonState(button, dateRange) {
            const isSelected = selectedDateFilters.includes(dateRange);
            
            if (isSelected) {
                button.className = 'date-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-blue-600 text-white border-blue-600 font-medium';
                button.title = `✓ Showing tasks active "${dateRange}" (click to remove filter)`;
            } else if (selectedDateFilters.length > 0) {
                button.className = 'date-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-gray-100 text-gray-500 border-gray-300';
                button.title = `Click to show tasks active "${dateRange}"`;
            } else {
                button.className = 'date-filter-btn px-3 py-1 rounded-md text-xs transition-all duration-200 border bg-white text-gray-700 border-gray-300 hover:border-blue-400';
                button.title = `Click to filter by tasks active "${dateRange}"`;
            }
        }

        function toggleDateFilter(dateRange) {
            if (selectedDateFilters.includes(dateRange)) {
                // Remove filter if already selected
                selectedDateFilters = selectedDateFilters.filter(d => d !== dateRange);
            } else {
                // Add filter
                selectedDateFilters.push(dateRange);
            }
            
            updateFilterUI();
            updateTable(); // Re-render the table
        }

        function clearDateFilter() {
            selectedDateFilters = [];
            updateFilterUI();
            updateTable(); // Re-render the table
        }

        function isTaskActiveInDateRange(ticket, dateRange) {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            let rangeStart, rangeEnd;
            
            if (dateRange === 'Today') {
                rangeStart = new Date(today);
                rangeEnd = new Date(today);
            } else if (dateRange === 'This Week') {
                // Get start of current week (Monday)
                rangeStart = new Date(today);
                const dayOfWeek = rangeStart.getDay();
                const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; // Sunday = 0, Monday = 1
                rangeStart.setDate(rangeStart.getDate() + mondayOffset);
                
                // Get end of current week (Friday)
                rangeEnd = new Date(rangeStart);
                rangeEnd.setDate(rangeStart.getDate() + 4); // Friday
            } else if (dateRange === 'Next Week') {
                // Get start of next week (Monday)
                rangeStart = new Date(today);
                const dayOfWeek = rangeStart.getDay();
                const nextMondayOffset = dayOfWeek === 0 ? 1 : 8 - dayOfWeek; // Sunday = 0, Monday = 1
                rangeStart.setDate(rangeStart.getDate() + nextMondayOffset);
                
                // Get end of next week (Friday)
                rangeEnd = new Date(rangeStart);
                rangeEnd.setDate(rangeStart.getDate() + 4); // Friday
            }
            
            // Get task's date range
            const taskStartDate = new Date(ticket.startDate);
            taskStartDate.setHours(0, 0, 0, 0);
            
            // Get projected end date
            const projectedTickets = getProjectedTickets();
            const projectedTicket = projectedTickets.find(pt => pt.id === ticket.id);
            let taskEndDate = taskStartDate; // Default to start date if no projection
            
            if (projectedTicket && projectedTicket.rawEndDate) {
                taskEndDate = new Date(projectedTicket.rawEndDate);
                taskEndDate.setHours(0, 0, 0, 0);
            }
            
            // Check if date ranges overlap
            return taskStartDate <= rangeEnd && taskEndDate >= rangeStart;
        }

        function shouldShowTicket(ticket) {
            // Check person filter
            const personFilterPassed = selectedPersonFilters.length === 0 || 
                selectedPersonFilters.some(filterPerson => 
                    ticket.assigned.some(assignedPerson => 
                        assignedPerson.toLowerCase() === filterPerson.toLowerCase()
                    )
                );
            
            // Check status filter
            const statusFilterPassed = selectedStatusFilters.length === 0 || 
                selectedStatusFilters.includes(ticket.status || 'To Do');
            
            // Check date filter
            const dateFilterPassed = selectedDateFilters.length === 0 || 
                selectedDateFilters.some(dateRange => isTaskActiveInDateRange(ticket, dateRange));
            
            // All filters must pass
            return personFilterPassed && statusFilterPassed && dateFilterPassed;
        }

        function getFilteredTickets() {
            return tickets.filter(ticket => shouldShowTicket(ticket));
        }

        // Alias for compatibility with the filtering functions
        function updateTable() {
            calculateProjection();
        }

        function getDefaultTaskStartDate() {
            const today = new Date();
            const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            const currentHour = today.getHours();
            
            // If it's a weekday (Monday-Thursday) and before 5 PM, use today
            if (currentDay >= 1 && currentDay <= 4 && currentHour < 17) {
                return today;
            }
            
            // If it's Friday and before noon, use today
            if (currentDay === 5 && currentHour < 12) {
                return today;
            }
            
            // If it's a weekday after hours, use tomorrow
            if (currentDay >= 1 && currentDay <= 4) {
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                return tomorrow;
            }
            
            // For Friday afternoon, weekend, use next Monday
            return getNextMonday(today);
        }
        
        function formatDate(dateString) {
            if (!dateString) return 'Not set';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                month: 'short', 
                day: 'numeric',
                year: 'numeric'
            });
        }
        
        function formatWeekEndDate(weekIndex) {
            const effectiveStart = getEffectiveStartDate();
            const date = new Date(effectiveStart);
            date.setDate(date.getDate() + (weekIndex * 7) + 4); // +4 days for Friday
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        function getWeekDateRange(weekIndex) {
            // Use the same baseline as the heat map for consistency
            let startDate = new Date();
            
            // Find earliest task start date from tickets array (not projected tickets to avoid recursion)
            if (tickets.length > 0) {
                const earliestTask = tickets.reduce((earliest, task) => 
                    new Date(task.startDate) < new Date(earliest.startDate) ? task : earliest
                );
                startDate = new Date(earliestTask.startDate);
            }
            
            // Ensure we start from a Monday (same logic as heat map)
            while (startDate.getDay() !== 1) {
                startDate.setDate(startDate.getDate() - 1);
            }
            
            const weekStartDate = new Date(startDate);
            weekStartDate.setDate(startDate.getDate() + (weekIndex * 7));
            
            const weekEndDate = new Date(weekStartDate);
            weekEndDate.setDate(weekEndDate.getDate() + 4); // Friday
            
            return `${weekStartDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${weekEndDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
        }

        function formatCompletionDate(startWeekIndex, remainingHours, totalWeeklyCapacity) {
            const effectiveStart = getEffectiveStartDate();
            const completionDate = new Date(effectiveStart);
            let daysIntoWeek = 0;

            if (totalWeeklyCapacity > 0) {
                // Calculate how many calendar days are needed to complete the remaining hours
                // at the current project work pace
                const daysNeeded = remainingHours / projectHoursPerDay;
                daysIntoWeek = Math.ceil(daysNeeded);
                daysIntoWeek = Math.min(daysIntoWeek, 5); // Cap at 5 working days per week
            }

            completionDate.setDate(completionDate.getDate() + (startWeekIndex * 7) + daysIntoWeek);
            
            let dayOfWeek = completionDate.getDay();
            if (dayOfWeek === 6) { // Saturday
                completionDate.setDate(completionDate.getDate() + 2);
            } else if (dayOfWeek === 0) { // Sunday
                completionDate.setDate(completionDate.getDate() + 1);
            }

            return completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }
        
        function getCompletionDateDetails(startWeekIndex, remainingHours, totalWeeklyCapacity) {
            const effectiveStart = getEffectiveStartDate();
            const weekStartDate = new Date(effectiveStart);
            weekStartDate.setDate(weekStartDate.getDate() + (startWeekIndex * 7));
            
            // Ensure we start on a business day
            const actualStartDate = getNextBusinessDay(weekStartDate);
            
            if (totalWeeklyCapacity > 0) {
                // Calculate business days needed based on the task size definition
                const daysNeeded = Math.ceil(remainingHours / projectHoursPerDay);
                const completionDate = addBusinessDays(actualStartDate, Math.max(1, daysNeeded - 1));
                
                return {
                    formatted: completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    rawDate: new Date(completionDate)
                };
            }

            // Fallback if no capacity
            return {
                formatted: actualStartDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                rawDate: new Date(actualStartDate)
            };
        }
        
        // Function to get default task size definitions
        function getDefaultTaskSizeDefinitions() {
            return {
                S: { name: 'Small', days: 1, removable: false },
                M: { name: 'Medium', days: 2, removable: false },
                L: { name: 'Large', days: 5, removable: false },
                XL: { name: 'X-Large', days: 10, removable: false },
                XXL: { name: 'XX-Large', days: 15, removable: false }
            };
        }

        // Function to backup current task size definitions (only if changed)
        function backupTaskSizeDefinitions() {
            if (!taskSizeDefinitions || Object.keys(taskSizeDefinitions).length === 0) {
                return;
            }
            
            try {
                // Check if backup already exists and is the same
                const existingBackup = localStorage.getItem('taskSizeDefinitions_backup');
                const currentData = JSON.stringify(taskSizeDefinitions);
                
                if (existingBackup === currentData) {
                    // No changes, skip backup
                    return;
                }
                
                // Only backup if data has actually changed
                localStorage.setItem('taskSizeDefinitions_backup', currentData);
                const timestamp = new Date().toISOString();
                localStorage.setItem('taskSizeDefinitions_backup_timestamp', timestamp);
                console.log('📁 Backed up taskSizeDefinitions (changed data detected)');
                
                // Optional: Clean up old backups (keep only the latest)
                cleanupOldBackups();
                
            } catch (e) {
                console.log('⚠️ Could not create backup:', e.message);
            }
        }

        // Function to clean up old backup data
        function cleanupOldBackups() {
            try {
                // Remove any old backup keys that might exist
                const keysToCheck = ['taskSizeDefinitions_backup_1', 'taskSizeDefinitions_backup_2', 'taskSizeDefinitions_backup_old'];
                keysToCheck.forEach(key => {
                    if (localStorage.getItem(key)) {
                        localStorage.removeItem(key);
                        console.log(`🧹 Cleaned up old backup: ${key}`);
                    }
                });
            } catch (e) {
                console.log('⚠️ Could not clean up old backups:', e.message);
            }
        }

        // Function to restore from backup or defaults
        function restoreTaskSizeDefinitions() {
            console.log('🔧 Attempting to restore taskSizeDefinitions...');
            
            // First try to restore from backup
            try {
                const backup = localStorage.getItem('taskSizeDefinitions_backup');
                const backupTimestamp = localStorage.getItem('taskSizeDefinitions_backup_timestamp');
                
                if (backup) {
                    const restored = JSON.parse(backup);
                    if (restored && Object.keys(restored).length > 0) {
                        console.log('✅ Restored from backup:', restored);
                        if (backupTimestamp) {
                            console.log('📅 Backup created:', new Date(backupTimestamp).toLocaleString());
                        }
                        return restored;
                    }
                }
            } catch (e) {
                console.log('⚠️ Could not restore from backup:', e.message);
            }
            
            // Fall back to defaults
            const defaults = getDefaultTaskSizeDefinitions();
            console.log('✅ Restored from defaults:', defaults);
            return defaults;
        }
        
        function calculateEffortMap() {
            console.log('🔧 calculateEffortMap called');
            console.log('📊 taskSizeDefinitions keys count:', Object.keys(taskSizeDefinitions).length);
            console.log('📊 taskSizeDefinitions:', taskSizeDefinitions);
            
            // Add a check to see if it's unexpectedly empty
            if (Object.keys(taskSizeDefinitions).length === 0) {
                console.error('❌ CRITICAL: taskSizeDefinitions is empty! Stack trace:');
                console.trace();
                
                // Restore from backup or defaults
                taskSizeDefinitions = restoreTaskSizeDefinitions();
            }
            
            effortMap = {};
            Object.keys(taskSizeDefinitions).forEach(key => {
                // Task effort based on estimation base hours (productive work after meetings, etc.)
                const days = taskSizeDefinitions[key].days;
                const effort = days * estimationBaseHours;
                effortMap[key] = effort;
                console.log(`📊 Size ${key}: ${days} days × ${estimationBaseHours} hours = ${effort} hours`);
            });
            console.log('📊 Final effort map:', effortMap);
        }

        // --- CORE SCHEDULING LOGIC ---

        function getProjectedTickets() {
            console.log('🔧 getProjectedTickets called');
            console.log('📊 People count:', people.length);
            console.log('📊 Tickets count:', tickets.length);
            
            if (people.length === 0 || tickets.length === 0) {
                console.log('❌ No people or tickets, returning N/A end dates');
                return tickets.map(t => ({ ...t, endDate: 'N/A', explanation: 'No people or no effort.', isDelayed: false }));
            }

            calculateEffortMap();
            console.log('📊 Effort map:', effortMap);
            console.log('📊 Task size definitions:', taskSizeDefinitions);

            // Create a deep clone of availability for resource tracking
            const availabilityTracker = people.reduce((acc, p) => {
                acc[p.name] = [...p.availability];
                return acc;
            }, {});
            
            // Sort tickets by start date to ensure proper capacity allocation
            const sortedTickets = [...tickets].sort((a, b) => {
                const dateA = new Date(a.startDate || getEffectiveStartDate());
                const dateB = new Date(b.startDate || getEffectiveStartDate());
                return dateA - dateB;
            });
            
            console.log('📅 Processing tickets in chronological order:');
            sortedTickets.forEach(ticket => {
                console.log(`  - Ticket ${ticket.id}: ${ticket.description}, Start: ${ticket.startDate}, Size: ${ticket.size}`);
            });
            
            const projectedTickets = sortedTickets.map(ticket => {
                console.log(`🎫 Processing ticket ${ticket.id}: ${ticket.description}`);
                
                // Check if ticket has a custom end date that overrides calculations
                if (ticket.customEndDate) {
                    console.log(`📅 Using custom end date for ticket ${ticket.id}: ${ticket.customEndDate}`);
                    const customDate = new Date(ticket.customEndDate);
                    const result = {
                        ...ticket,
                        endDate: customDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                        rawEndDate: customDate,
                        explanation: `Custom deadline set via bulk resolution: ${customDate.toLocaleDateString()}`,
                        isDelayed: false
                    };
                    console.log(`📅 Custom end date result for ticket ${ticket.id}:`, result);
                    return result;
                }
                
                const totalEffortHours = effortMap[ticket.size] || 0;
                const assignedCount = ticket.assigned.length;
                
                console.log(`📊 Ticket ${ticket.id} - Size: ${ticket.size}, Effort: ${totalEffortHours}h, Assigned: ${assignedCount} people`);
                
                // Categorize assigned people by project readiness
                const projectReadyPeople = ticket.assigned.filter(name => {
                    const person = people.find(p => p.name === name);
                    return person && person.isProjectReady;
                });
                
                const notProjectReadyPeople = ticket.assigned.filter(name => {
                    const person = people.find(p => p.name === name);
                    return person && !person.isProjectReady;
                });
                
                console.log(`👥 Assigned to: ${ticket.assigned.join(', ')}`);
                if (projectReadyPeople.length > 0) {
                    console.log(`🎯 Project Ready (Contributing): ${projectReadyPeople.join(', ')}`);
                }
                if (notProjectReadyPeople.length > 0) {
                    console.log(`📋 Tracked Only (Not Contributing): ${notProjectReadyPeople.join(', ')}`);
                }

                // Create fresh availability tracker for this task based on its start date
                // This ensures each task starts with full availability from its start date onwards
                const taskAvailabilityTracker = people.reduce((acc, p) => {
                    acc[p.name] = [...p.availability];
                    return acc;
                }, {});
                
                // Debug: Log availability for assigned people
                ticket.assigned.forEach(personName => {
                    console.log(`🔍 ${personName} availability:`, taskAvailabilityTracker[personName]);
                });

                // Apply capacity consumption from previous tasks that might overlap with this task
                const thisTaskStartDate = new Date(ticket.startDate || getEffectiveStartDate());
                
                // Only apply consumption from previous tasks that actually overlap with this task's timeline
                sortedTickets.forEach(prevTicket => {
                    if (prevTicket.id === ticket.id) return; // Skip self
                    
                    const prevStartDate = new Date(prevTicket.startDate || getEffectiveStartDate());
                    if (prevStartDate >= thisTaskStartDate) return; // Skip future tasks
                    
                    // Check if this previous task overlaps with current task's timeline
                    // For now, we'll simplify and let each task have fresh availability
                    // This may need refinement for true overlapping task support
                });
                
                if (totalEffortHours === 0 || assignedCount === 0) {
                    console.log(`❌ Ticket ${ticket.id} - No effort defined or no one assigned`);
                    return { ...ticket, endDate: 'N/A', explanation: 'No effort defined or no one assigned.', isDelayed: false };
                }

                // Calculate which week the task can start based on start date
                let taskStartDate;
                
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    taskStartDate = commonDate ? new Date(commonDate) : getEffectiveStartDate();
                } else {
                    taskStartDate = new Date(ticket.startDate || getEffectiveStartDate());
                }
                
                // Ensure task starts on a business day
                taskStartDate = getNextBusinessDay(taskStartDate);
                
                // Use the same baseline as heat map for consistency
                let heatMapBaselineDate = new Date();
                if (tickets.length > 0) {
                    const earliestTask = tickets.reduce((earliest, task) => 
                        new Date(task.startDate) < new Date(earliest.startDate) ? task : earliest
                    );
                    heatMapBaselineDate = new Date(earliestTask.startDate);
                }
                
                // Ensure baseline starts from a Monday (same logic as heat map)
                while (heatMapBaselineDate.getDay() !== 1) {
                    heatMapBaselineDate.setDate(heatMapBaselineDate.getDate() - 1);
                }
                
                // Use UTC date construction to avoid timezone issues completely
                const normalizedTaskStart = new Date(Date.UTC(taskStartDate.getFullYear(), taskStartDate.getMonth(), taskStartDate.getDate()));
                const normalizedBaseline = new Date(Date.UTC(heatMapBaselineDate.getFullYear(), heatMapBaselineDate.getMonth(), heatMapBaselineDate.getDate()));
                
                const daysDiff = Math.max(0, Math.round((normalizedTaskStart - normalizedBaseline) / (1000 * 60 * 60 * 24)));
                console.log(`🔍 Debug date calculation (UTC normalization):`);
                console.log(`  - Original task start: ${taskStartDate.toDateString()}`);
                console.log(`  - Original baseline: ${heatMapBaselineDate.toDateString()}`);
                console.log(`  - UTC task start: ${normalizedTaskStart.toISOString()}`);
                console.log(`  - UTC baseline: ${normalizedBaseline.toISOString()}`);
                console.log(`  - Raw difference (ms): ${normalizedTaskStart - normalizedBaseline}`);
                console.log(`  - Calculated days: ${(normalizedTaskStart - normalizedBaseline) / (1000 * 60 * 60 * 24)}`);
                console.log(`  - Days difference (rounded): ${daysDiff}`);
                
                // Now the calculation should be correct: Oct 6 vs Sep 29 = 7 days = Week 2 (index 1)
                const startWeekIndex = Math.floor(daysDiff / 7);

                console.log(`📅 Task ${ticket.id} week calculation:`);
                console.log(`  - Task start date: ${taskStartDate.toDateString()}`);
                console.log(`  - Heat map baseline (Monday): ${heatMapBaselineDate.toDateString()}`);
                console.log(`  - Days difference: ${daysDiff}`);
                console.log(`  - Calculated week index: ${startWeekIndex} (Week ${startWeekIndex + 1})`);
                console.log(`  - Week range: ${getWeekDateRange(startWeekIndex)}`);

                let hoursRemaining = totalEffortHours; // Total effort stays the same regardless of team size
                const initialHours = hoursRemaining;
                
                let completionWeekIndex = -1;
                let finalCapacity = 0;
                let pooledCapacityThisWeek = 0; 
                
                let explanation = `Ticket Effort: ${totalEffortHours} hours (${ticket.size}, ${taskSizeDefinitions[ticket.size].days} person-days).\n`;
                explanation += `Assigned: ${ticket.assigned.join(', ')} (${assignedCount} person(s)).\n`;
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    explanation += `Start Date: ${formatDate(taskStartDate.toISOString().split('T')[0])} (Week ${startWeekIndex + 1}) [Common Start Date].\n`;
                } else {
                    explanation += `Start Date: ${formatDate(taskStartDate.toISOString().split('T')[0])} (Week ${startWeekIndex + 1}).\n`;
                }
                explanation += `Required Duration Hours (pooled): ${initialHours.toFixed(1)} hours.\n`;
                explanation += `Planning baseline: Week 1 starts ${formatDate(heatMapBaselineDate.toISOString().split('T')[0])}.\n\n`;

                let currentHoursToConsume = hoursRemaining;

                // Iterate through 8 weeks, starting from the appropriate week
                for (let w = startWeekIndex; w < 8; w++) {
                    pooledCapacityThisWeek = 0;
                    const capacityBreakdown = {};
                    
                    // Filter assigned people to only include project-ready resources for capacity calculations
                    const projectReadyAssigned = ticket.assigned.filter(name => {
                        const person = people.find(p => p.name === name);
                        return person && person.isProjectReady;
                    });
                    
                    const notProjectReadyAssigned = ticket.assigned.filter(name => {
                        const person = people.find(p => p.name === name);
                        return person && !person.isProjectReady;
                    });
                    
                    // Only count capacity from project-ready resources
                    projectReadyAssigned.forEach(name => {
                        const personCapacity = taskAvailabilityTracker[name] ? taskAvailabilityTracker[name][w] || 0 : 0;
                        pooledCapacityThisWeek += personCapacity;
                        capacityBreakdown[name] = personCapacity;
                        console.log(`👤 ${name} Week ${w + 1}: ${personCapacity} hours available (Project Ready)`);
                    });
                    
                    // Log non-project-ready resources for tracking but don't include in capacity
                    notProjectReadyAssigned.forEach(name => {
                        const personCapacity = taskAvailabilityTracker[name] ? taskAvailabilityTracker[name][w] || 0 : 0;
                        capacityBreakdown[name] = `${personCapacity} (Not Contributing)`;
                        console.log(`👤 ${name} Week ${w + 1}: ${personCapacity} hours available (Not Project Ready - Tracked Only)`);
                    });
                    
                    explanation += `--- Week ${w + 1} (${getWeekDateRange(w)}) ---\n`;
                    if (projectReadyAssigned.length > 0) {
                        explanation += `Project Ready Resources: ${projectReadyAssigned.join(', ')}\n`;
                    }
                    if (notProjectReadyAssigned.length > 0) {
                        explanation += `Tracked Only (Not Contributing): ${notProjectReadyAssigned.join(', ')}\n`;
                    }
                    explanation += `Pooled Capacity: ${pooledCapacityThisWeek.toFixed(1)} hours.\n`;
                    console.log(`📊 Week ${w + 1} Total Pooled Capacity: ${pooledCapacityThisWeek} hours, Need: ${currentHoursToConsume} hours`);
                    
                    if (pooledCapacityThisWeek <= 0) {
                        explanation += 'No capacity this week from assigned team members. Moving to next week.\n';
                        console.log(`⏭️ Week ${w + 1}: No capacity, moving to next week`);
                        continue;
                    }
                    
                    if (currentHoursToConsume <= pooledCapacityThisWeek) {
                        completionWeekIndex = w;
                        finalCapacity = currentHoursToConsume;
                        explanation += `Task completes this week, consuming ${currentHoursToConsume.toFixed(1)} hours of pooled capacity.\n`;
                        console.log(`✅ Task completes in Week ${w + 1}, using ${currentHoursToConsume} hours of ${pooledCapacityThisWeek} available`);
                        
                        let capacityUsed = currentHoursToConsume;
                        ticket.assigned.forEach(name => {
                            const personCapacity = capacityBreakdown[name];
                            if (personCapacity > 0) {
                                const proportion = personCapacity / pooledCapacityThisWeek;
                                const timeToDeduct = capacityUsed * proportion;
                                taskAvailabilityTracker[name][w] -= timeToDeduct;
                                explanation += `  - ${name} contribution: ${timeToDeduct.toFixed(1)} hours (Remaining: ${taskAvailabilityTracker[name][w].toFixed(1)}).\n`;
                            }
                        });
                        break;
                    } else {
                        currentHoursToConsume -= pooledCapacityThisWeek;
                        explanation += `Full capacity consumed (${pooledCapacityThisWeek.toFixed(1)} hours). Remaining hours for task: ${currentHoursToConsume.toFixed(1)}.\n`;
                        console.log(`🔄 Week ${w + 1}: Used all ${pooledCapacityThisWeek} hours, ${currentHoursToConsume} hours remaining`);

                        ticket.assigned.forEach(name => {
                            taskAvailabilityTracker[name][w] = 0;
                        });
                    }
                }

                let endDate;
                let rawEndDate = null;
                let isDelayed = false;

                // Use capacity-based calculation for end date
                if (completionWeekIndex !== -1) {
                    // Calculate completion date based on actual task progress through weeks
                    const baseWeekDate = new Date(taskStartDate);
                    const weekOffset = completionWeekIndex - startWeekIndex;
                    baseWeekDate.setDate(baseWeekDate.getDate() + (weekOffset * 7));
                    
                    // The task completes within this week, estimate specific day based on capacity consumption
                    if (pooledCapacityThisWeek > 0 && finalCapacity > 0) {
                        // Calculate the daily pooled capacity from the assigned team members
                        const dailyPooledCapacity = pooledCapacityThisWeek / 5; // Divide weekly capacity by 5 business days
                        // Calculate how many business days are needed to finish the remaining work
                        const businessDaysNeeded = Math.ceil(finalCapacity / dailyPooledCapacity);
                        // Use addBusinessDays to ensure we land on a business day
                        const completionDate = addBusinessDays(baseWeekDate, businessDaysNeeded - 1);
                        
                        endDate = completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        rawEndDate = completionDate;
                    } else {
                        // Fallback to week start if we can't determine specific completion day  
                        const businessDayStart = getNextBusinessDay(baseWeekDate);
                        endDate = businessDayStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        rawEndDate = businessDayStart;
                    }
                    
                    explanation += `\nTask completes in Week ${completionWeekIndex + 1}: ${endDate}\n`;
                } else {
                    explanation += '\nTask cannot complete within the 8-week planning window based on available capacity.';
                    isDelayed = true;
                    // Use a reasonable estimate based on current task start
                    const estimatedDate = new Date(taskStartDate);
                    estimatedDate.setDate(estimatedDate.getDate() + 56); // 8 weeks from start
                    endDate = estimatedDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    rawEndDate = estimatedDate;
                }
                
                return { 
                    ...ticket, 
                    endDate: endDate,
                    rawEndDate: rawEndDate,
                    explanation: explanation,
                    isDelayed: isDelayed
                };
            });
            
            // Restore original order for UI display
            const orderedResults = tickets.map(originalTicket => 
                projectedTickets.find(pt => pt.id === originalTicket.id) || originalTicket
            );
            
            return orderedResults;
        }

        function calculateProjection() {
            const projectedTickets = getProjectedTickets();
            renderTickets(projectedTickets);
            // Timeline removed - will be replaced with new timeline system
            renderWorkloadHeatMap();
            updateFurthestCompletionDate(projectedTickets);
        }
        
        // --- PERSON AVAILABILITY CALCULATION ---
        function getPersonNextAvailableDate(personName) {
            const projectedTickets = getProjectedTickets();
            const today = new Date();
            
            // Find all tasks assigned to this person
            const personTasks = projectedTickets.filter(ticket => 
                ticket.assigned && ticket.assigned.includes(personName)
            );
            
            if (personTasks.length === 0) {
                // Person has no tasks, available from next business day
                const nextBusinessDay = getNextBusinessDay(today);
                return {
                    nextAvailable: nextBusinessDay,
                    status: 'Available immediately',
                    lastTaskEnd: null
                };
            }
            
            // Find the latest end date among their tasks
            let latestEndDate = new Date(today);
            let latestTaskDescription = '';
            
            personTasks.forEach(task => {
                if (task.rawEndDate) {
                    const taskEndDate = new Date(task.rawEndDate);
                    if (taskEndDate > latestEndDate) {
                        latestEndDate = taskEndDate;
                        latestTaskDescription = task.description;
                    }
                }
            });
            
            // Find next business day after their last task
            const nextAvailable = new Date(latestEndDate);
            nextAvailable.setDate(nextAvailable.getDate() + 1);
            const nextBusinessDay = getNextBusinessDay(nextAvailable);
            
            return {
                nextAvailable: nextBusinessDay,
                status: `Busy until ${latestEndDate.toLocaleDateString('en-US', { 
                    weekday: 'short', 
                    month: 'short', 
                    day: 'numeric' 
                })}`,
                lastTaskEnd: latestEndDate,
                lastTaskDescription: latestTaskDescription
            };
        }
        
        function showPersonAvailability(personName) {
            const availability = getPersonNextAvailableDate(personName);
            const nextAvailableFormatted = availability.nextAvailable.toLocaleDateString('en-US', { 
                weekday: 'long', 
                month: 'short', 
                day: 'numeric',
                year: 'numeric'
            });
            
            // Calculate days from today
            const today = new Date();
            const daysFromToday = Math.ceil((availability.nextAvailable - today) / (1000 * 60 * 60 * 24));
            const daysText = daysFromToday <= 0 ? 'Available now' : 
                            daysFromToday === 1 ? 'Available tomorrow' : 
                            `Available in ${daysFromToday} days`;
            
            let message = `👤 ${personName} - Availability Status\n`;
            message += `${'='.repeat(40)}\n\n`;
            message += `📅 Next Available: ${nextAvailableFormatted}\n`;
            message += `⏰ Timeline: ${daysText}\n\n`;
            message += `📊 Current Status: ${availability.status}\n`;
            
            if (availability.lastTaskDescription) {
                message += `🔗 Last Task: "${availability.lastTaskDescription}"\n`;
            }
            
            message += `\n💡 Tip: Use this date as the start date when assigning new tasks to avoid overallocation.`;
            
            // Show in a nice alert dialog
            alert(message);
        }
        
        function updateFurthestCompletionDate(projectedTickets) {
            const furthestDateEl = document.getElementById('furthest-completion-date');
            const furthestWeekEl = document.getElementById('furthest-completion-week');
            
            if (!projectedTickets || projectedTickets.length === 0) {
                furthestDateEl.textContent = 'No tasks';
                furthestWeekEl.textContent = '—';
                return;
            }
            
            let furthestDate = null;
            let furthestTaskId = null;
            
            // Find the task with the latest completion date
            projectedTickets.forEach(ticket => {
                if (ticket.rawEndDate && !ticket.isDelayed) {
                    if (!furthestDate || ticket.rawEndDate > furthestDate) {
                        furthestDate = ticket.rawEndDate;
                        furthestTaskId = ticket.id;
                    }
                }
            });
            
            if (furthestDate) {
                // Format the date
                const formattedDate = formatDate(furthestDate.toLocaleDateString('en-CA'));
                furthestDateEl.textContent = formattedDate;
                
                // Calculate which week this is from the effective start date
                const effectiveStartDate = getEffectiveStartDate();
                const daysDifference = Math.ceil((furthestDate - effectiveStartDate) / (1000 * 60 * 60 * 24));
                const weekNumber = Math.ceil(daysDifference / 7);
                
                furthestWeekEl.textContent = `Week ${weekNumber}`;
                furthestWeekEl.title = `Task #${furthestTaskId} completes in week ${weekNumber}`;
            } else {
                // Check if there are any delayed tasks
                const hasDelayedTasks = projectedTickets.some(ticket => ticket.isDelayed || (ticket.endDate && ticket.endDate.includes('>')));
                if (hasDelayedTasks) {
                    furthestDateEl.textContent = 'Beyond 8 weeks';
                    furthestWeekEl.textContent = 'Week 8+';
                    furthestWeekEl.title = 'Some tasks extend beyond the 8-week planning horizon';
                } else {
                    furthestDateEl.textContent = 'No valid dates';
                    furthestWeekEl.textContent = '—';
                }
            }
        }
        
        
        /* ===== TIMELINE FUNCTIONS REMOVED =====
           The old timeline system has been removed and will be replaced
           with a new, more effective timeline visualization.
           
           Original functions removed:
           - renderTimeline(projectedTickets)  
           - toggleTimelineTooltip(marker)
           - Timeline click handlers
           
           Timeline HTML elements were also removed from the main interface.
        */

        // --- RENDERING FUNCTIONS ---

        function renderEffortMap() {
            calculateEffortMap(); 
            
            document.getElementById('estimation-base-display').textContent = estimationBaseHours;
            document.getElementById('estimation-base-hours').value = estimationBaseHours;
            document.getElementById('project-hours-per-day').value = projectHoursPerDay;

            renderTaskSizeCards();
        }
        
        function renderTaskSizeCards() {
            const container = document.getElementById('task-size-cards');
            if (!container) return;

            container.innerHTML = Object.keys(taskSizeDefinitions).map(key => {
                const size = taskSizeDefinitions[key];
                const totalHours = size.days * estimationBaseHours;
                
                return `
                    <div class="task-size-card">
                        <div class="flex justify-between items-start mb-2">
                            <div class="size-label-enhanced">${size.name}</div>
                            ${size.removable ? `<button onclick="removeTaskSize('${key}')" class="text-red-300 hover:text-red-100 text-xs">✕</button>` : ''}
                        </div>
                        <div class="size-controls">
                            <input 
                                type="number" 
                                value="${size.days}" 
                                min="0.1" 
                                max="50"
                                step="0.5"
                                onchange="updateTaskSizeDaysEnhanced('${key}', this.value)" 
                                class="size-input-enhanced"
                            >
                            <span class="text-sm">days</span>
                        </div>
                        <div class="size-metrics">
                            <div>📊 <strong>${totalHours}h</strong> total</div>
                            <div>⚡ ${(totalHours/estimationBaseHours).toFixed(1)} person-days</div>
                            <div class="text-xs mt-1 opacity-75">Size: <strong>${key}</strong></div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Update ticket size dropdown options
            updateTicketSizeDropdown();
        }
        
        function updateEstimationBase(newHours) {
            estimationBaseHours = parseFloat(newHours);
            document.getElementById('estimation-base-display').textContent = estimationBaseHours;
            console.log('📊 Estimation Base Hours updated to:', estimationBaseHours);
            
            markDirty(); // Mark as having unsaved changes
            
            // Recalculate effort map with new base hours
            calculateEffortMap();
            renderTaskSizeCards();
            calculateProjection();
        }
        
        function updateProjectHours(newHours) {
            projectHoursPerDay = parseFloat(newHours);
            console.log('📊 Project Hours/Day updated to:', projectHoursPerDay);
            
            markDirty(); // Mark as having unsaved changes
            
            // Recalculate projections with new project hours
            calculateProjection();
        }
        
        function updateTaskSizeDaysEnhanced(sizeKey, newDays) {
            const days = parseFloat(newDays);
            if (isNaN(days) || days <= 0) {
                alert('Please enter a valid number of days');
                return;
            }
            
            // Backup current configuration before making changes
            backupTaskSizeDefinitions();
            
            // Update the task size definition
            taskSizeDefinitions[sizeKey].days = days;
            
            // Sync with the old ticketDays object for compatibility
            syncTaskSizes();
            
            // Recalculate effort map
            calculateEffortMap();
            
            // Re-render the task size cards to update the display
            renderTaskSizeCards();
            
            // Update projections and displays
            updateTable();
            
            // Save to localStorage
            saveData();
            
            console.log(`✅ Updated ${sizeKey} to ${days} days and backed up configuration`);
        }
        
        function updateTicketSizeDropdown() {
            const dropdown = document.getElementById('new-ticket-size');
            if (!dropdown) return;
            
            dropdown.innerHTML = Object.keys(taskSizeDefinitions).map(key => {
                const size = taskSizeDefinitions[key];
                return `<option value="${key}">${size.name} (${key})</option>`;
            }).join('');
        }

        function updateAvailabilityHeader() {
            const header = document.getElementById('availability-header');
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date')?.value;
                if (commonDate) {
                    const formattedDate = formatDate(commonDate);
                    header.textContent = `Team Availability (8 weeks from ${formattedDate})`;
                } else {
                    header.textContent = 'Team Availability (8 weeks from common start date)';
                }
            } else {
                const earliestTaskDate = getEarliestTaskStartDate();
                if (earliestTaskDate) {
                    const formattedDate = formatDate(earliestTaskDate.toISOString().split('T')[0]);
                    header.textContent = `Team Availability (8 weeks from ${formattedDate})`;
                } else {
                    header.textContent = 'Team Availability (Next 8 Weeks)';
                }
            }
        }
        
        function updateStartDateColumnHeader() {
            const header = document.getElementById('start-date-column-header');
            if (useCommonStartDate) {
                header.textContent = 'Start Date (Common)';
            } else {
                header.textContent = 'Start Date (Editable)';
            }
        }

        function renderPeople() {
            // Update the header to reflect current mode
            updateAvailabilityHeader();
            
            const peopleList = document.getElementById('people-list');
            const assignContainer = document.getElementById('new-ticket-assigned');
            peopleList.innerHTML = '';
            assignContainer.innerHTML = '';

            people.forEach((person, pIndex) => {
                const card = document.createElement('div');
                card.className = 'p-4 bg-indigo-50 rounded-lg border border-indigo-200 hover:bg-indigo-100 transition-colors';
                
                let availabilityInputs = '';
                for (let w = 0; w < 8; w++) {
                    const weekEnd = formatWeekEndDate(w);
                    availabilityInputs += `
                        <div class="flex flex-col items-center min-w-[40px]">
                            <label class="text-xs text-gray-600 mb-1">W${w+1}</label>
                            <label class="text-xs text-gray-500 mb-1">${weekEnd}</label>
                            <input 
                                type="number" 
                                value="${person.availability[w] || 0}" 
                                min="0" 
                                onchange="updatePersonAvailability('${person.name}', ${w}, this.value)" 
                                class="w-10 p-1 text-xs border border-gray-300 rounded text-center focus:border-blue-500 focus:ring-1 focus:ring-blue-200"
                            >
                        </div>
                    `;
                }

                const weekRangeInfo = useCommonStartDate ? 
                    ' (Based on common start date)' : 
                    (getEarliestTaskStartDate() ? ' (Based on earliest task start date)' : '');
                
                card.innerHTML = `
                    <div class="flex justify-between items-start mb-3">
                        <span class="font-bold text-indigo-800 text-base cursor-pointer hover:text-blue-600 hover:underline transition-colors" 
                              onclick="showPersonAvailability('${person.name}')" 
                              title="Click to see availability">
                            📅 ${person.name}
                        </span>
                        <button onclick="removePerson('${person.name}')" class="text-red-500 hover:text-red-700 transition p-1 rounded hover:bg-red-50">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </div>
                    <div class="flex items-center gap-2 mb-3 px-1">
                        <label class="flex items-center gap-1 text-sm cursor-pointer">
                            <input 
                                type="checkbox" 
                                ${person.isProjectReady ? 'checked' : ''} 
                                onchange="updatePersonProjectReady('${person.name}', this.checked)"
                                class="w-3 h-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500 focus:ring-1"
                            >
                            <span class="text-blue-700 font-medium" title="When checked, this person contributes to project delivery timelines. When unchecked, their capacity is tracked but doesn't affect completion dates.">
                                🎯 Project Ready Resource
                            </span>
                        </label>
                    </div>
                    <div class="overflow-x-auto">
                        <div class="flex gap-1 text-xs min-w-max">
                            ${availabilityInputs}
                        </div>
                    </div>
                    ${weekRangeInfo ? `<div class="text-xs text-blue-600 mt-2">${weekRangeInfo}</div>` : ''}
                `;
                peopleList.appendChild(card);

                // Create checkbox for "Add New Task" form
                const checkboxWrapper = document.createElement('label');
                checkboxWrapper.className = 'flex items-center space-x-1 px-2 py-1 hover:bg-gray-100 rounded cursor-pointer';
                const projectReadyIndicator = person.isProjectReady ? '🎯' : '📋';
                const projectReadyTitle = person.isProjectReady ? 'Project Ready - Contributes to delivery timelines' : 'Tracked Only - Does not affect delivery dates';
                checkboxWrapper.innerHTML = `
                    <input type="checkbox" value="${person.name}" class="w-3 h-3 text-blue-600 border-gray-300 rounded focus:ring-blue-500 focus:ring-1">
                    <span class="text-sm cursor-pointer hover:text-blue-600 ${person.isProjectReady ? 'text-gray-700' : 'text-gray-500'}" 
                          onclick="event.preventDefault(); showPersonAvailability('${person.name}')" 
                          title="Click to see availability - ${projectReadyTitle}">
                        ${projectReadyIndicator} ${person.name}
                    </span>
                `;
                assignContainer.appendChild(checkboxWrapper);
            });
            
            // Generate person filter buttons whenever people are updated
            generatePersonFilterButtons();
            
            // Generate status filter buttons
            generateStatusFilterButtons();
            
            // Generate date filter buttons
            generateDateFilterButtons();
        }

        function renderTickets(projectedTickets) {
            const tbody = document.getElementById('ticket-table-body');
            tbody.innerHTML = '';
            
            // Update column header based on current mode
            updateStartDateColumnHeader();
            
            // Apply person filtering
            const filteredTickets = projectedTickets.filter(ticket => shouldShowTicket(ticket));
            
            if (filteredTickets.length === 0) {
                document.getElementById('no-tickets').classList.remove('hidden');
                // Update the no-tickets message based on whether filtering is active
                const noTicketsMsg = document.getElementById('no-tickets');
                if (selectedPersonFilters.length > 0 || selectedStatusFilters.length > 0 || selectedDateFilters.length > 0) {
                    let filterMessage = 'No tasks found';
                    if (selectedPersonFilters.length > 0) {
                        filterMessage += ` for ${selectedPersonFilters.join(', ')}`;
                    }
                    if (selectedStatusFilters.length > 0) {
                        if (selectedPersonFilters.length > 0) filterMessage += ' and';
                        filterMessage += ` with status ${selectedStatusFilters.join(', ')}`;
                    }
                    if (selectedDateFilters.length > 0) {
                        if (selectedPersonFilters.length > 0 || selectedStatusFilters.length > 0) filterMessage += ' and';
                        filterMessage += ` active in ${selectedDateFilters.join(', ')}`;
                    }
                    filterMessage += '.';
                    noTicketsMsg.textContent = filterMessage;
                } else {
                    noTicketsMsg.textContent = 'No tasks defined. Add a task to begin!';
                }
                return;
            }
            document.getElementById('no-tickets').classList.add('hidden');

            filteredTickets.forEach(ticket => {
                const tr = document.createElement('tr');
                tr.className = 'hover:bg-gray-50';

                // Rebuild the assignment checkboxes
                const assignmentCheckboxes = people.map(p => {
                    const isChecked = ticket.assigned.includes(p.name);
                    return `
                        <label class="flex items-center space-x-1 text-xs whitespace-nowrap">
                            <input 
                                type="checkbox" 
                                value="${p.name}" 
                                ${isChecked ? 'checked' : ''}
                                onchange="handleAssignmentCheckboxChange(this, ${ticket.id})"
                                class="w-3 h-3 text-blue-600 bg-gray-100 border-gray-300 rounded focus:ring-blue-500"
                            >
                            <span class="text-gray-700 cursor-pointer hover:text-blue-600" 
                                  onclick="event.preventDefault(); showPersonAvailability('${p.name}')"
                                  title="Click to see availability">
                                📅 ${p.name}
                            </span>
                        </label>
                    `;
                }).join('');

                // Create size dropdown options
                const sizeOptions = Object.keys(taskSizeDefinitions).map(key => {
                    const size = taskSizeDefinitions[key];
                    const isSelected = ticket.size === key;
                    return `<option value="${key}" ${isSelected ? 'selected' : ''}>${size.name} (${key})</option>`;
                }).join('');

                // Create priority dropdown options
                const priorityOptions = ['P1', 'P2', 'P3', 'P4', 'P5'].map(priority => {
                    const isSelected = (ticket.priority || 'P3') === priority;
                    return `<option value="${priority}" ${isSelected ? 'selected' : ''}>${priority}</option>`;
                }).join('');

                const completionDateClass = ticket.isDelayed ? 'bg-red-100 text-red-700 font-bold p-1 rounded' : 'text-green-600 font-semibold';
                
                // Determine displayed start date
                let displayStartDate;
                let startDateInput = '';
                if (useCommonStartDate) {
                    const commonDate = document.getElementById('common-start-date').value;
                    displayStartDate = formatDate(commonDate) + ' 🔗';
                    startDateInput = `<span class="text-gray-500 text-sm">${displayStartDate}</span>`;
                } else {
                    startDateInput = `
                        <input 
                            type="date" 
                            value="${ticket.startDate || ''}" 
                            onchange="handleStartDateChange(this, ${ticket.id})"
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white"
                            title="Change task start date"
                        >
                    `;
                }
                
                tr.innerHTML = `
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-500">${ticket.id}</td>
                    <td class="px-3 py-2 text-sm text-gray-900 w-1/3">${ticket.description}</td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-600">${startDateInput}</td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm font-medium">
                        <select 
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white text-indigo-600 font-medium"
                            onchange="handleSizeChange(this, ${ticket.id})"
                            title="Change task size"
                        >
                            ${sizeOptions}
                        </select>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm font-medium">
                        <select 
                            class="w-full p-1 border border-gray-300 rounded-lg text-xs bg-white text-purple-600 font-medium"
                            onchange="handlePriorityChange(this, ${ticket.id})"
                            title="Change task priority"
                        >
                            ${priorityOptions}
                        </select>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm font-medium">
                        <span 
                            class="status-badge ${getStatusClass(ticket.status || 'To Do')}" 
                            onclick="cycleTaskStatus(${ticket.id})"
                            oncontextmenu="handleStatusRightClick(event, ${ticket.id})"
                            data-ticket-id="${ticket.id}"
                            title="Click to change status"
                        >
                            ${getStatusDisplayWithComments(ticket)}
                        </span>
                    </td>
                    <td class="px-3 py-2 text-sm text-gray-500 w-1/4">
                        <div class="flex flex-wrap gap-1 min-h-[40px] items-center">
                            ${assignmentCheckboxes}
                        </div>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-sm text-gray-900">
                        <div class="flex items-center">
                            <span class="${completionDateClass}">${ticket.endDate}</span>
                            ${ticket.customEndDate ? '<span class="ml-1 text-xs text-blue-600" title="Custom deadline set">📅</span>' : ''}
                            <button onclick="showCalculationDetails(${ticket.id})" class="details-btn" title="Show calculation details">
                                Details
                            </button>
                        </div>
                    </td>
                    <td class="px-3 py-2 whitespace-nowrap text-right text-sm font-medium">
                        <button onclick="removeTicket(${ticket.id})" class="text-red-500 hover:text-red-700 transition">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    </td>
                `;
                tbody.appendChild(tr);
                
                // Set up the tooltip for the status badge after the row is added
                const statusBadge = tr.querySelector('.status-badge');
                if (statusBadge && ticket.status === 'Paused' && ticket.pauseComments && ticket.pauseComments.length > 0) {
                    const latestComment = ticket.pauseComments[ticket.pauseComments.length - 1];
                    let tooltip = 'Left click: Change status\nRight click: Edit latest comment\n\nLatest pause reason:\n"' + latestComment.comment + '"\n(' + latestComment.timestamp + ')';
                    
                    if (ticket.pauseComments.length > 1) {
                        tooltip += '\n\n' + ticket.pauseComments.length + ' total pause comments';
                    }
                    
                    statusBadge.title = tooltip;
                    console.log(`🏷️ Set tooltip for ticket ${ticket.id}:`, tooltip);
                } else if (statusBadge && ticket.status === 'Paused') {
                    // Paused task without comments
                    statusBadge.title = 'Left click: Change status\nRight click: Add pause comment';
                }
            });
        }

        // --- CSV EXPORT FUNCTION ---

        window.exportData = () => {
            const projectedTickets = getProjectedTickets();
            if (projectedTickets.length === 0) {
                alert("No tickets to export.");
                return;
            }

            // 1. Generate the CSV content
            let csvContent = "Ticket ID,Description,Start Date,Size,Priority,Status,Pause Comments,Person Days,Total Hours,Assigned Team,Projected End Date,Detailed Explanation\n";

            projectedTickets.forEach(ticket => {
                const totalHours = effortMap[ticket.size] || 0;
                const personDays = taskSizeDefinitions[ticket.size]?.days || 0;

                // Escape double quotes and ensure data is wrapped in quotes
                const escapeCSV = (value) => `"${String(value).replace(/"/g, '""')}"`;

                // Format pause comments for CSV
                const pauseCommentsText = ticket.pauseComments && ticket.pauseComments.length > 0 
                    ? ticket.pauseComments.map(pc => `[${pc.timestamp}] ${pc.comment}`).join(' | ')
                    : '';

                const row = [
                    ticket.id,
                    escapeCSV(ticket.description),
                    formatDate(ticket.startDate),
                    ticket.size,
                    ticket.priority || 'P3',
                    escapeCSV(ticket.status || 'To Do'),
                    escapeCSV(pauseCommentsText),
                    personDays,
                    totalHours,
                    escapeCSV(ticket.assigned.join('; ')),
                    ticket.endDate.replace(/,/g, ''),
                    escapeCSV(ticket.explanation.replace(/\n/g, ' | ')) // Replace newlines for single-cell explanation
                ].join(',');
                csvContent += row + "\n";
            });

            // 2. Trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `project_schedule_${new Date().toISOString().slice(0, 10)}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // --- COMPREHENSIVE CONFIGURATION EXPORT/IMPORT ---

        window.exportConfiguration = () => {
            const timestamp = new Date().toISOString().slice(0, 19).replace('T', '_').replace(/:/g, '-');
            
            // Create comprehensive configuration data
            const configData = {
                metadata: {
                    exportDate: new Date().toISOString(),
                    version: '2.0',
                    description: 'Enterprise Project Tracking Console Configuration Export'
                },
                settings: {
                    estimationBaseHours: estimationBaseHours,
                    projectHoursPerDay: projectHoursPerDay,
                    useCommonStartDate: useCommonStartDate,
                    commonStartDate: document.getElementById('common-start-date')?.value || '',
                    currentTicketId: currentTicketId
                },
                taskSizeDefinitions: taskSizeDefinitions,
                people: people,
                tickets: tickets
            };

            // Convert to CSV format with multiple sections
            let csvContent = '';
            
            // Metadata section
            csvContent += "SECTION,METADATA\n";
            csvContent += "Key,Value\n";
            csvContent += `Export Date,${configData.metadata.exportDate}\n`;
            csvContent += `Version,${configData.metadata.version}\n`;
            csvContent += `Description,${configData.metadata.description}\n`;
            csvContent += "\n";
            
            // Settings section
            csvContent += "SECTION,SETTINGS\n";
            csvContent += "Key,Value\n";
            csvContent += `Estimation Base Hours,${configData.settings.estimationBaseHours}\n`;
            csvContent += `Project Hours Per Day,${configData.settings.projectHoursPerDay}\n`;
            csvContent += `Use Common Start Date,${configData.settings.useCommonStartDate}\n`;
            csvContent += `Common Start Date,${configData.settings.commonStartDate}\n`;
            csvContent += `Current Ticket ID,${configData.settings.currentTicketId}\n`;
            csvContent += "\n";
            
            // Task Size Definitions section
            csvContent += "SECTION,TASK_SIZES\n";
            csvContent += "Size Key,Name,Days,Removable\n";
            Object.keys(configData.taskSizeDefinitions).forEach(key => {
                const size = configData.taskSizeDefinitions[key];
                csvContent += `${key},"${size.name}",${size.days},${size.removable}\n`;
            });
            csvContent += "\n";
            
            // People section
            csvContent += "SECTION,PEOPLE\n";
            csvContent += "Name,Week1,Week2,Week3,Week4,Week5,Week6,Week7,Week8,Project Ready\n";
            configData.people.forEach(person => {
                // Ensure person has 8-week availability
                const availability = [...person.availability];
                while (availability.length < 8) {
                    availability.push(25);
                }
                const isProjectReady = person.isProjectReady !== undefined ? person.isProjectReady : true;
                csvContent += `"${person.name}",${availability.slice(0, 8).join(',')},${isProjectReady ? 'Yes' : 'No'}\n`;
            });
            csvContent += "\n";
            
            // Tickets section
            csvContent += "SECTION,TICKETS\n";
            csvContent += "ID,Description,Start Date,Size,Priority,Assigned Team,Status,Pause Comments,Start Date History,End Date History,Size History,Custom End Date\n";
            configData.tickets.forEach(ticket => {
                const assignedTeam = ticket.assigned.join(';');
                const priority = ticket.priority || 'P3';
                const status = ticket.status || 'To Do';
                
                // Format pause comments for CSV
                const pauseCommentsText = ticket.pauseComments && ticket.pauseComments.length > 0 
                    ? ticket.pauseComments.map(pc => `[${pc.timestamp}] ${pc.comment}`).join(' | ')
                    : '';
                
                // Format start date history for CSV
                const startDateHistoryText = ticket.startDateHistory && ticket.startDateHistory.length > 0
                    ? ticket.startDateHistory.map(entry => 
                        `${entry.date}(${entry.reason}@${entry.timestamp})`
                    ).join(' | ')
                    : '';
                
                // Format end date history for CSV
                const endDateHistoryText = ticket.endDateHistory && ticket.endDateHistory.length > 0
                    ? ticket.endDateHistory.map(entry => 
                        `${entry.date}(${entry.reason}@${entry.timestamp})`
                    ).join(' | ')
                    : '';
                
                // Format size history for CSV
                const sizeHistoryText = ticket.sizeHistory && ticket.sizeHistory.length > 0
                    ? ticket.sizeHistory.map(entry => 
                        `${entry.size}:${entry.days}d(${entry.reason}@${entry.timestamp})`
                    ).join(' | ')
                    : '';
                
                // Custom end date (if set)
                const customEndDate = ticket.customEndDate || '';
                
                csvContent += `${ticket.id},"${ticket.description.replace(/"/g, '""')}",${ticket.startDate},${ticket.size},${priority},"${assignedTeam}","${status}","${pauseCommentsText}","${startDateHistoryText}","${endDateHistoryText}","${sizeHistoryText}","${customEndDate}"\n`;
            });
            
            // Download the configuration file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", `project_config_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            // Mark as clean since configuration has been exported
            markClean();
            
            // Show success message
            alert(`✅ Configuration exported successfully!\n\nFile: project_config_${timestamp}.csv\n\nThis file contains:\n• All team member configurations\n• Task size definitions\n• All tickets and assignments\n• System settings\n\nUse "Import Config" to restore this configuration later.`);
        }

        window.triggerImport = () => {
            const fileInput = document.getElementById('import-config-file');
            fileInput.click();
        }

        window.handleConfigImport = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                alert('❌ Please select a CSV configuration file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    importConfiguration(csvContent);
                } catch (error) {
                    alert(`❌ Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input for repeated imports
            event.target.value = '';
        }

        function importConfiguration(csvContent) {
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            let currentSection = '';
            let importedData = {
                settings: {},
                taskSizeDefinitions: {},
                people: [],
                tickets: []
            };
            
            let skipHeader = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                // Check for section headers
                if (line.startsWith('SECTION,')) {
                    currentSection = line.split(',')[1];
                    skipHeader = true;
                    continue;
                }
                
                // Skip column headers after section declaration
                if (skipHeader) {
                    skipHeader = false;
                    continue;
                }
                
                // Skip empty lines
                if (!line) continue;
                
                // Parse based on current section
                try {
                    if (currentSection === 'SETTINGS') {
                        const [key, value] = parseCSVLine(line);
                        if (key === 'Estimation Base Hours') importedData.settings.estimationBaseHours = parseInt(value);
                        else if (key === 'Project Hours Per Day') importedData.settings.projectHoursPerDay = parseInt(value);
                        else if (key === 'Hours Per Day') importedData.settings.projectHoursPerDay = parseInt(value); // Legacy support
                        else if (key === 'Use Common Start Date') importedData.settings.useCommonStartDate = value === 'true';
                        else if (key === 'Common Start Date') importedData.settings.commonStartDate = value;
                        else if (key === 'Current Ticket ID') importedData.settings.currentTicketId = parseInt(value);
                    }
                    else if (currentSection === 'TASK_SIZES') {
                        const [sizeKey, name, days, removable] = parseCSVLine(line);
                        importedData.taskSizeDefinitions[sizeKey] = {
                            name: name,
                            days: parseFloat(days),
                            removable: removable === 'true'
                        };
                    }
                    else if (currentSection === 'PEOPLE') {
                        const parsed = parseCSVLine(line);
                        const name = parsed[0];
                        
                        // Handle both old 5-week and new 8-week format
                        const availabilityValues = parsed.slice(1, -1).map(val => parseInt(val) || 0); // Exclude last column for project ready flag
                        
                        // Get project ready flag (last column, default to true for backwards compatibility)
                        const isProjectReady = parsed.length > 9 ? (parsed[parsed.length - 1] === 'true' || parsed[parsed.length - 1] === 'Yes') : true;
                        
                        // Ensure we have exactly 8 weeks
                        while (availabilityValues.length < 8) {
                            // If missing weeks, use the last available value or 25 as default
                            const lastValue = availabilityValues[availabilityValues.length - 1] || 25;
                            availabilityValues.push(lastValue);
                        }
                        
                        // If somehow more than 8, truncate
                        if (availabilityValues.length > 8) {
                            availabilityValues.length = 8;
                        }
                        
                        importedData.people.push({
                            name: name,
                            availability: availabilityValues,
                            isProjectReady: isProjectReady
                        });
                    }
                    else if (currentSection === 'TICKETS') {
                        const columns = parseCSVLine(line);
                        
                        // Handle backward compatibility - older CSV files may not have customEndDate column
                        const [id, description, startDate, size, priority, assignedTeam, status, pauseComments, startDateHistory, endDateHistory, sizeHistory, customEndDate] = columns;
                        
                        const assigned = assignedTeam ? assignedTeam.split(';').filter(name => name.trim()) : [];
                        
                        // Parse pause comments
                        const parsedPauseComments = [];
                        if (pauseComments && pauseComments.trim()) {
                            const commentEntries = pauseComments.split(' | ');
                            commentEntries.forEach(entry => {
                                const match = entry.match(/^\[([^\]]+)\] (.+)$/);
                                if (match) {
                                    parsedPauseComments.push({
                                        timestamp: match[1],
                                        comment: match[2]
                                    });
                                }
                            });
                        }
                        
                        // Parse start date history
                        const parsedStartDateHistory = [];
                        if (startDateHistory && startDateHistory.trim()) {
                            const historyEntries = startDateHistory.split(' | ');
                            historyEntries.forEach(entry => {
                                const match = entry.match(/^([^(]+)\(([^@]+)@([^)]+)\)$/);
                                if (match) {
                                    parsedStartDateHistory.push({
                                        date: match[1],
                                        reason: match[2],
                                        timestamp: match[3]
                                    });
                                }
                            });
                        }
                        
                        // Parse end date history
                        const parsedEndDateHistory = [];
                        if (endDateHistory && endDateHistory.trim()) {
                            const historyEntries = endDateHistory.split(' | ');
                            historyEntries.forEach(entry => {
                                const match = entry.match(/^([^(]+)\(([^@]+)@([^)]+)\)$/);
                                if (match) {
                                    parsedEndDateHistory.push({
                                        date: match[1],
                                        reason: match[2],
                                        timestamp: match[3]
                                    });
                                }
                            });
                        }
                        
                        // Parse size history
                        const parsedSizeHistory = [];
                        if (sizeHistory && sizeHistory.trim()) {
                            const historyEntries = sizeHistory.split(' | ');
                            historyEntries.forEach(entry => {
                                const match = entry.match(/^([^:]+):(\d+)d\(([^@]+)@([^)]+)\)$/);
                                if (match) {
                                    parsedSizeHistory.push({
                                        size: match[1],
                                        days: parseInt(match[2]),
                                        reason: match[3],
                                        timestamp: match[4]
                                    });
                                }
                            });
                        }
                        
                        const ticket = {
                            id: parseInt(id),
                            description: description,
                            startDate: startDate,
                            size: size,
                            priority: priority || 'P3',
                            assigned: assigned,
                            status: status || 'To Do',
                            pauseComments: parsedPauseComments,
                            startDateHistory: parsedStartDateHistory,
                            endDateHistory: parsedEndDateHistory,
                            sizeHistory: parsedSizeHistory,
                            customEndDate: (customEndDate && customEndDate.trim()) ? customEndDate : undefined
                        };
                        
                        importedData.tickets.push(ticket);
                    }
                } catch (error) {
                    console.warn(`Skipping invalid line in ${currentSection}: ${line}`);
                }
            }
            
            // Validate imported data
            if (!validateImportedData(importedData)) {
                alert('❌ Invalid configuration file. Please check the file format and try again.');
                return;
            }
            
            // Confirm import
            const confirmMessage = `📋 Import Configuration\n\nFound:\n• ${Object.keys(importedData.taskSizeDefinitions).length} task size definitions\n• ${importedData.people.length} team members\n• ${importedData.tickets.length} tickets\n\n⚠️ This will replace ALL current data!\n\nContinue with import?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Apply imported configuration
            try {
                // Apply settings
                estimationBaseHours = importedData.settings.estimationBaseHours || 5;
                projectHoursPerDay = importedData.settings.projectHoursPerDay || importedData.settings.hoursPerDay || 8; // Legacy support
                useCommonStartDate = importedData.settings.useCommonStartDate || false;
                currentTicketId = importedData.settings.currentTicketId || 1;
                
                // Apply configurations
                console.log('🔄 IMPORT: About to replace taskSizeDefinitions');
                console.log('🔄 IMPORT: Current taskSizeDefinitions:', taskSizeDefinitions);
                console.log('🔄 IMPORT: Incoming taskSizeDefinitions:', importedData.taskSizeDefinitions);
                taskSizeDefinitions = importedData.taskSizeDefinitions;
                console.log('🔄 IMPORT: After replacement:', taskSizeDefinitions);
                people = importedData.people;
                
                // Add backwards compatibility for isProjectReady field
                people.forEach(person => {
                    if (person.isProjectReady === undefined) {
                        person.isProjectReady = true; // Default to true for existing data
                    }
                });
                
                tickets = importedData.tickets;
                
                // Initialize all history for backward compatibility
                tickets = tickets.map(ticket => {
                    ticket = initializeStartDateHistory(ticket);
                    ticket = initializeEndDateHistory(ticket);
                    ticket = initializeSizeHistory(ticket);
                    return ticket;
                });
                
                // Reset filtering state after import
                selectedPersonFilters = [];
                selectedStatusFilters = [];
                selectedDateFilters = [];
                
                // Update UI
                document.getElementById('estimation-base-hours').value = estimationBaseHours;
                document.getElementById('project-hours-per-day').value = projectHoursPerDay;
                document.getElementById('estimation-base-display').textContent = estimationBaseHours;
                document.getElementById('use-common-start-date').checked = useCommonStartDate;
                if (importedData.settings.commonStartDate) {
                    document.getElementById('common-start-date').value = importedData.settings.commonStartDate;
                }
                
                // Apply common start date logic
                if (useCommonStartDate) {
                    toggleCommonStartDate();
                }
                
                // Sync and recalculate everything
                syncTaskSizes();
                calculateEffortMap();
                renderEffortMap();
                renderPeople();
                calculateProjection();
                
                // Update filter UI to ensure clean state
                updateFilterUI();
                
                saveToLocalStorage();
                
                // Mark as clean since we just imported a saved configuration
                markClean();
                
                alert(`✅ Configuration imported successfully!\n\n• ${Object.keys(taskSizeDefinitions).length} task sizes loaded\n• ${people.length} team members configured\n• ${tickets.length} tickets imported\n\nAll data has been restored and calculations updated.`);
                
            } catch (error) {
                alert(`❌ Error applying configuration: ${error.message}\n\nPlease check your file and try again.`);
            }
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"' && (i === 0 || line[i-1] === ',')) {
                    inQuotes = true;
                } else if (char === '"' && inQuotes && (i === line.length - 1 || line[i+1] === ',')) {
                    inQuotes = false;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            result.push(current.trim());
            
            return result;
        }

        function validateImportedData(data) {
            // Basic validation
            if (!data.settings || !data.taskSizeDefinitions || !data.people || !data.tickets) {
                return false;
            }
            
            // Validate people have required fields
            for (const person of data.people) {
                if (!person.name || !Array.isArray(person.availability) || person.availability.length !== 8) {
                    return false;
                }
            }
            
            // Validate tickets have required fields
            for (const ticket of data.tickets) {
                if (!ticket.id || !ticket.description || !ticket.size || !Array.isArray(ticket.assigned)) {
                    return false;
                }
            }
            
            return true;
        }

        // --- BULK TASK IMPORT ---

        window.triggerTaskImport = () => {
            const fileInput = document.getElementById('import-tasks-file');
            fileInput.click();
        }

        window.handleTaskImport = (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            if (!file.name.endsWith('.csv')) {
                alert('❌ Please select a CSV file with tasks.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csvContent = e.target.result;
                    importTasksFromCSV(csvContent);
                } catch (error) {
                    alert(`❌ Error reading file: ${error.message}`);
                }
            };
            reader.readAsText(file);
            
            // Clear the file input for repeated imports
            event.target.value = '';
        }

        function importTasksFromCSV(csvContent) {
            const lines = csvContent.split('\n').map(line => line.trim()).filter(line => line);
            
            if (lines.length === 0) {
                alert('❌ The CSV file appears to be empty.');
                return;
            }
            
            // Parse tasks from CSV
            const newTasks = [];
            let hasHeader = false;
            
            // Check if first line is a header (contains "task" or "description" etc.)
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('task') || firstLine.includes('description') || firstLine.includes('name')) {
                hasHeader = true;
            }
            
            const startIndex = hasHeader ? 1 : 0;
            
            for (let i = startIndex; i < lines.length; i++) {
                const line = lines[i];
                if (!line) continue;
                
                // Handle CSV parsing (remove quotes if present)
                let taskName = line.replace(/^"(.*)"$/, '$1').replace(/""/g, '"').trim();
                
                // Skip empty task names
                if (!taskName) continue;
                
                // Validate task name length
                if (taskName.length > 200) {
                    console.warn(`Task name too long, truncating: ${taskName.substring(0, 50)}...`);
                    taskName = taskName.substring(0, 200);
                }
                
                newTasks.push(taskName);
            }
            
            if (newTasks.length === 0) {
                alert('❌ No valid tasks found in the CSV file.\n\nExpected format:\n• One task per line\n• Optional header row\n• Task names in first column');
                return;
            }
            
            // Show preview and confirm import
            const previewTasks = newTasks.slice(0, 5);
            const previewText = previewTasks.join('\n');
            const moreText = newTasks.length > 5 ? `\n... and ${newTasks.length - 5} more tasks` : '';
            
            const confirmMessage = `📋 Import ${newTasks.length} Tasks\n\nPreview:\n${previewText}${moreText}\n\n✅ Default settings will be applied:\n• Size: Medium (M)\n• Priority: P3\n• Status: To Do\n• Start Date: Next Monday\n• Assigned: Unassigned\n\nContinue with import?`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            // Apply default settings for new tasks
            const defaultSize = 'M'; // Medium
            const defaultPriority = 'P3'; // Default priority
            const defaultStartDate = getLocalDateString(getNextMonday(new Date()));
            const defaultAssigned = []; // Unassigned
            
            // Add tasks to the system
            let addedCount = 0;
            let skippedCount = 0;
            
            newTasks.forEach(taskName => {
                // Check for duplicate task descriptions
                const isDuplicate = tickets.some(ticket => 
                    ticket.description.toLowerCase() === taskName.toLowerCase()
                );
                
                if (isDuplicate) {
                    skippedCount++;
                    console.warn(`Skipping duplicate task: ${taskName}`);
                    return;
                }
                
                // Add the task
                tickets.push({
                    id: currentTicketId++,
                    description: taskName,
                    startDate: defaultStartDate,
                    size: defaultSize,
                    priority: defaultPriority,
                    status: 'To Do', // Default status for imported tasks
                    assigned: [...defaultAssigned],
                    pauseComments: [] // Initialize empty pause comments array
                });
                
                addedCount++;
            });
            
            // Update the system
            if (addedCount > 0) {
                // Refresh people display if not using common start date
                if (!useCommonStartDate) {
                    renderPeople();
                }
                
                calculateProjection();
                saveToLocalStorage();
                
                // Show success message
                let message = `✅ Task Import Complete!\n\n• ${addedCount} tasks added successfully`;
                if (skippedCount > 0) {
                    message += `\n• ${skippedCount} duplicates skipped`;
                }
                message += `\n\n📝 All tasks set to:\n• Size: Medium (M)\n• Priority: P3\n• Start Date: ${formatDate(defaultStartDate)}\n• Status: Unassigned\n\nYou can now edit individual tasks as needed.`;
                
                alert(message);
            } else {
                alert('❌ No tasks were added. All tasks may have been duplicates.');
            }
        }
        
        window.resetToDefaults = () => {
            if (confirm('This will reset all data to defaults with current dates. Are you sure?')) {
                localStorage.removeItem(STORAGE_KEY);
                initializeDefaultData();
                
                // Reset UI state
                useCommonStartDate = false;
                document.getElementById('use-common-start-date').checked = false;
                
                // Re-initialize
                calculateEffortMap();
                renderEffortMap();
                renderPeople();
                calculateProjection();
                
                alert('Data reset to defaults with current dates!');
            }
        }


        // --- COMMON START DATE FUNCTIONS ---
        
        window.toggleCommonStartDate = () => {
            const checkbox = document.getElementById('use-common-start-date');
            const commonDateInput = document.getElementById('common-start-date');
            const individualDateInput = document.getElementById('new-ticket-start-date');
            const startDateHelp = document.getElementById('start-date-help');
            
            useCommonStartDate = checkbox.checked;
            
            if (useCommonStartDate) {
                // Enable common start date, disable individual
                commonDateInput.disabled = false;
                commonDateInput.classList.remove('bg-gray-100');
                commonDateInput.classList.add('bg-white');
                
                // Set default to next Monday if empty
                if (!commonDateInput.value) {
                    commonDateInput.value = getLocalDateString(getDefaultTaskStartDate());
                }
                
                individualDateInput.disabled = true;
                individualDateInput.classList.add('bg-gray-100', 'text-gray-400');
                
                startDateHelp.innerHTML = 'Common start date is enabled - all tasks will use the same start date above. <strong>Team availability weeks are recalculated from this date.</strong>';
                
            } else {
                // Disable common start date, enable individual
                commonDateInput.disabled = true;
                commonDateInput.classList.add('bg-gray-100');
                commonDateInput.classList.remove('bg-white');
                
                individualDateInput.disabled = false;
                individualDateInput.classList.remove('bg-gray-100', 'text-gray-400');
                
                startDateHelp.innerHTML = 'Individual start dates enabled. <strong>Team availability weeks are calculated from the earliest task start date.</strong>';
            }
            
            // Refresh people display to show updated week dates
            renderPeople();
            
            markDirty(); // Mark as having unsaved changes
            
            // Recalculate projections (this will also update the table)
            calculateProjection();
            saveToLocalStorage();
        }
        
        window.updateAllTaskStartDates = () => {
            if (useCommonStartDate) {
                // Update header and refresh people display to show updated week dates
                updateAvailabilityHeader();
                renderPeople();
                
                // Recalculate when common start date changes
                calculateProjection();
                saveToLocalStorage();
            }
        }

        // --- DATA MODIFIERS (Trigger localStorage save and recalculation) ---
        
        // Legacy function - kept for compatibility but redirects to new functions
        window.updateEffortMapping = (value) => {
            updateProjectHours(value);
        };

        window.updateTicketSizeDays = (sizeKey, value) => {
            const newDays = parseInt(value, 10);
            if (isNaN(newDays) || newDays < 1) return; 

            ticketDays[sizeKey] = newDays;
            
            markDirty(); // Mark as having unsaved changes
            calculateEffortMap(); 
            renderEffortMap();
            calculateProjection();
            saveToLocalStorage();
        }
        
        // Enhanced task sizing functions
        window.updateTicketSizeDaysEnhanced = (sizeKey, value) => {
            const newDays = parseFloat(value);
            if (isNaN(newDays) || newDays < 0.1) return; 

            ticketDays[sizeKey] = newDays;
            taskSizeDefinitions[sizeKey].days = newDays;
            
            markDirty(); // Mark as having unsaved changes
            calculateEffortMap(); 
            renderTaskSizeCards();
            calculateProjection();
            saveToLocalStorage();
        }
        
        window.applyPreset = (presetName) => {
            const presets = {
                agile: {
                    XS: { name: 'Extra Small', days: 0.5, removable: true },
                    S: { name: 'Small', days: 1, removable: false },
                    M: { name: 'Medium', days: 3, removable: false },
                    L: { name: 'Large', days: 5, removable: false },
                    XL: { name: 'X-Large', days: 8, removable: false }
                },
                enterprise: {
                    S: { name: 'Small', days: 2, removable: false },
                    M: { name: 'Medium', days: 5, removable: false },
                    L: { name: 'Large', days: 10, removable: false },
                    XL: { name: 'X-Large', days: 20, removable: false },
                    XXL: { name: 'XX-Large', days: 40, removable: false }
                },
                startup: {
                    XS: { name: 'Quick Fix', days: 0.25, removable: true },
                    S: { name: 'Small', days: 1, removable: false },
                    M: { name: 'Medium', days: 2, removable: false },
                    L: { name: 'Large', days: 5, removable: false },
                    XL: { name: 'Epic', days: 10, removable: false }
                },
                conservative: {
                    S: { name: 'Small', days: 3, removable: false },
                    M: { name: 'Medium', days: 8, removable: false },
                    L: { name: 'Large', days: 15, removable: false },
                    XL: { name: 'X-Large', days: 25, removable: false },
                    XXL: { name: 'XX-Large', days: 40, removable: false }
                }
            };
            
            if (presets[presetName]) {
                if (confirm(`Apply ${presetName} preset? This will replace your current task sizes.`)) {
                    taskSizeDefinitions = { ...presets[presetName] };
                    syncTaskSizes();
                    markDirty(); // Mark as having unsaved changes
                    calculateEffortMap();
                    renderTaskSizeCards();
                    calculateProjection();
                    saveToLocalStorage();
                }
            }
        }
        
        window.showCustomSizeForm = () => {
            document.getElementById('custom-size-form').classList.remove('hidden');
        }
        
        window.hideCustomSizeForm = () => {
            document.getElementById('custom-size-form').classList.add('hidden');
            // Clear form
            document.getElementById('new-size-key').value = '';
            document.getElementById('new-size-name').value = '';
            document.getElementById('new-size-days').value = '';
        }
        
        window.addCustomSize = () => {
            const key = document.getElementById('new-size-key').value.trim().toUpperCase();
            const name = document.getElementById('new-size-name').value.trim();
            const days = parseFloat(document.getElementById('new-size-days').value);
            
            if (!key || !name || isNaN(days) || days < 0.1) {
                alert('Please fill all fields with valid values.');
                return;
            }
            
            if (taskSizeDefinitions[key]) {
                alert('Size key already exists. Choose a different key.');
                return;
            }
            
            taskSizeDefinitions[key] = { name, days, removable: true };
            ticketDays[key] = days;
            
            markDirty(); // Mark as having unsaved changes
            calculateEffortMap();
            renderTaskSizeCards();
            hideCustomSizeForm();
            saveToLocalStorage();
            
            alert(`✅ Added custom size: ${name} (${key}) - ${days} days`);
        }
        
        window.removeTaskSize = (sizeKey) => {
            if (!taskSizeDefinitions[sizeKey]?.removable) {
                alert('This task size cannot be removed.');
                return;
            }
            
            // Check if any tickets use this size
            const ticketsWithSize = tickets.filter(ticket => ticket.size === sizeKey);
            if (ticketsWithSize.length > 0) {
                alert(`Cannot remove size ${sizeKey}. It's used by ${ticketsWithSize.length} ticket(s).`);
                return;
            }
            
            if (confirm(`Remove task size ${sizeKey} (${taskSizeDefinitions[sizeKey].name})?`)) {
                delete taskSizeDefinitions[sizeKey];
                delete ticketDays[sizeKey];
                
                markDirty(); // Mark as having unsaved changes
                calculateEffortMap();
                renderTaskSizeCards();
                saveToLocalStorage();
            }
        }

        window.addPerson = () => {
            const nameInput = document.getElementById('new-person-name');
            const name = nameInput.value.trim();
            if (!name || people.some(p => p.name === name)) {
                // Simplified confirmation dialog for local environment
                if (name) alert("Person already exists or name is invalid.");
                return;
            }

            people.push({
                name: name,
                availability: [25, 25, 25, 25, 25, 25, 25, 25],
                isProjectReady: true // Default to true for new people
            });
            
            nameInput.value = '';
            markDirty(); // Mark as having unsaved changes
            renderPeople();
            calculateProjection();
            saveToLocalStorage();
        }

        window.removePerson = (name) => {
            people = people.filter(p => p.name !== name);
            tickets.forEach(ticket => {
                ticket.assigned = ticket.assigned.filter(n => n !== name);
            });

            markDirty(); // Mark as having unsaved changes
            renderPeople();
            calculateProjection();
            saveToLocalStorage();
        }

        window.updatePersonAvailability = (name, weekIndex, value) => {
            const hours = Math.max(0, parseInt(value, 10));
            if (isNaN(hours)) return;

            const person = people.find(p => p.name === name);
            if (person) {
                console.log(`🔄 AVAILABILITY UPDATE: ${name} Week ${weekIndex + 1} changed from ${person.availability[weekIndex]} to ${hours} hours`);
                person.availability[weekIndex] = hours;
                console.log(`📊 Updated ${name} availability:`, person.availability);
                markDirty(); // Mark as having unsaved changes
                calculateProjection(); 
                saveToLocalStorage();
                console.log(`✅ Recalculation triggered for availability change`);
            }
        }

        window.updatePersonProjectReady = (name, isReady) => {
            const person = people.find(p => p.name === name);
            if (person) {
                console.log(`🎯 PROJECT READY UPDATE: ${name} changed from ${person.isProjectReady ? 'Project Ready' : 'Not Project Ready'} to ${isReady ? 'Project Ready' : 'Not Project Ready'}`);
                person.isProjectReady = isReady;
                console.log(`📊 Updated ${name} project ready status:`, person.isProjectReady);
                markDirty(); // Mark as having unsaved changes
                calculateProjection(); 
                saveToLocalStorage();
                console.log(`✅ Recalculation triggered for project ready change`);
            }
        }

        // P1 Task Conflict Detection System
        function checkP1TaskConflicts(employeeNames, taskStartDate, taskSize, excludeTaskId = null) {
            console.log('🔍 P1 Conflict Check:', { employeeNames, taskStartDate, taskSize, excludeTaskId });
            
            if (!Array.isArray(employeeNames) || employeeNames.length === 0) {
                console.log('❌ No employees to check or invalid input');
                return { hasConflicts: false, conflictedEmployees: [], availableEmployees: [] };
            }

            // Get fresh projection data to ensure we have current end dates
            const projectedTickets = getProjectedTickets();
            
            console.log('📊 Fresh projected tickets count:', projectedTickets.length);
            console.log('📊 Sample projected ticket:', projectedTickets[0]);
            
            // Create a temporary task to get its projected end date
            const tempTask = {
                id: -1,
                description: 'temp',
                startDate: taskStartDate,
                size: taskSize,
                priority: 'P1',
                assigned: employeeNames
            };
            
            console.log('🔧 Created temp task:', tempTask);
            
            // Get projected end date for this temporary task
            const tempProjected = projectedTickets.concat([tempTask]);
            const recalculatedProjected = getProjectedTickets([tempTask]);
            let tempTaskProjected = recalculatedProjected.find(t => t.id === -1);
            
            console.log('📈 Temp task projected:', tempTaskProjected);
            
            if (!tempTaskProjected || !tempTaskProjected.rawEndDate) {
                // If we can't calculate end date, use a conservative 4-week estimate
                const estimatedEndDate = new Date(taskStartDate);
                estimatedEndDate.setDate(estimatedEndDate.getDate() + 28);
                tempTaskProjected = { rawEndDate: estimatedEndDate };
                console.log('⚠️ Using fallback end date calculation:', estimatedEndDate);
            }

            const newTaskStart = new Date(taskStartDate);
            const newTaskEnd = tempTaskProjected.rawEndDate;
            
            console.log('🗓️ New task date range:', {
                start: newTaskStart.toDateString(),
                end: newTaskEnd.toDateString()
            });

            const conflictedEmployees = [];
            const availableEmployees = [];

            // Check each employee for P1 conflicts
            employeeNames.forEach(employeeName => {
                console.log(`🔍 Checking ${employeeName} for P1 conflicts...`);
                let hasConflict = false;
                
                // Check all existing P1 tasks for this employee
                const existingP1Tasks = tickets.filter(ticket => 
                    ticket.priority === 'P1' && 
                    ticket.assigned.includes(employeeName) &&
                    ticket.id !== excludeTaskId // Exclude current task if editing
                );
                
                console.log(`📋 Found ${existingP1Tasks.length} existing P1 tasks for ${employeeName}:`, existingP1Tasks.map(t => ({ id: t.id, desc: t.description, start: t.startDate })));

                for (const existingTask of existingP1Tasks) {
                    console.log(`🔍 Checking existing task:`, { id: existingTask.id, desc: existingTask.description, start: existingTask.startDate, size: existingTask.size });
                    
                    // Get projected end date for existing task
                    const existingProjected = projectedTickets.find(pt => pt.id === existingTask.id);
                    console.log(`📊 Existing task projected:`, existingProjected);
                    console.log(`📊 Available properties:`, existingProjected ? Object.keys(existingProjected) : 'none');
                    
                    if (existingProjected && (existingProjected.rawEndDate || existingProjected.endDate)) {
                        const existingStart = new Date(existingTask.startDate);
                        const existingEndValue = existingProjected.rawEndDate || existingProjected.endDate;
                        const existingEnd = new Date(existingEndValue);

                        console.log(`📊 Date values:`, {
                            existingEndValue,
                            existingEnd,
                            isValidDate: !isNaN(existingEnd.getTime())
                        });

                        // If the projected end date is invalid, this indicates a bug in the projection system
                        if (isNaN(existingEnd.getTime()) || existingEndValue === 'N/A') {
                            console.error(`❌ PROJECTION SYSTEM BUG: Task ${existingTask.id} has invalid end date '${existingEndValue}'. This must be fixed!`);
                            console.log(`Task details:`, existingTask);
                            console.log(`Projected details:`, existingProjected);
                            // Skip this task for now, but log the issue
                            return;
                        }

                        // Check for date overlap
                        const hasOverlap = (newTaskStart <= existingEnd && newTaskEnd >= existingStart);
                        
                        console.log(`📅 Date overlap check for ${employeeName}:`, {
                            newTaskStart: newTaskStart.toDateString(),
                            newTaskEnd: newTaskEnd.toDateString(),
                            existingStart: existingStart.toDateString(),
                            existingEnd: existingEnd.toDateString(),
                            hasOverlap,
                            condition1: newTaskStart <= existingEnd,
                            condition2: newTaskEnd >= existingStart
                        });
                        
                        if (hasOverlap) {
                            console.log(`⚠️ CONFLICT DETECTED for ${employeeName}!`);
                            hasConflict = true;
                            if (!conflictedEmployees.find(ce => ce.name === employeeName)) {
                                conflictedEmployees.push({
                                    name: employeeName,
                                    conflictingTaskId: existingTask.id,
                                    conflictingTaskDescription: existingTask.description,
                                    conflictingTaskStart: existingTask.startDate
                                });
                            }
                            break;
                        }
                    } else {
                        console.log(`❌ No projected data found for existing task ${existingTask.id}, available properties:`, existingProjected ? Object.keys(existingProjected) : 'task not found');
                    }
                }

                if (!hasConflict) {
                    availableEmployees.push(employeeName);
                }
            });

            // Find all employees who are not selected but have no P1 conflicts
            const allEmployees = people.map(p => p.name);
            const unselectedEmployees = allEmployees.filter(name => !employeeNames.includes(name));
            
            unselectedEmployees.forEach(employeeName => {
                let hasConflict = false;
                
                const existingP1Tasks = tickets.filter(ticket => 
                    ticket.priority === 'P1' && 
                    ticket.assigned.includes(employeeName) &&
                    ticket.id !== excludeTaskId
                );

                for (const existingTask of existingP1Tasks) {
                    const existingProjected = projectedTickets.find(pt => pt.id === existingTask.id);
                    if (existingProjected && existingProjected.rawEndDate) {
                        const existingStart = new Date(existingTask.startDate);
                        const existingEnd = existingProjected.rawEndDate;
                        const hasOverlap = (newTaskStart <= existingEnd && newTaskEnd >= existingStart);
                        
                        if (hasOverlap) {
                            hasConflict = true;
                            break;
                        }
                    }
                }

                if (!hasConflict) {
                    availableEmployees.push(employeeName);
                }
            });

            const result = {
                hasConflicts: conflictedEmployees.length > 0,
                conflictedEmployees: conflictedEmployees,
                availableEmployees: availableEmployees
            };
            
            console.log('✅ P1 Conflict Check Result:', result);
            
            return result;
        }

        function showP1ConflictWarning(conflictResult) {
            const conflictedNames = conflictResult.conflictedEmployees.map(ce => ce.name);
            const availableNames = conflictResult.availableEmployees;
            
            let message = '';
            
            if (conflictedNames.length === 1) {
                const conflict = conflictResult.conflictedEmployees[0];
                message = `Employee ${conflictedNames[0]} already has another P1 task assigned ("${conflict.conflictingTaskDescription}") starting ${formatDate(conflict.conflictingTaskStart)}.`;
            } else {
                const conflictDetails = conflictResult.conflictedEmployees.map(ce => 
                    `${ce.name} ("${ce.conflictingTaskDescription}" from ${formatDate(ce.conflictingTaskStart)})`
                ).join(', ');
                message = `Employees ${conflictDetails} already have other P1 tasks assigned.`;
            }
            
            if (availableNames.length > 0) {
                message += `\n\nFollowing employees have no P1 tasks against them during this period - ${availableNames.join(', ')}. You can pick any of them.`;
            } else {
                message += `\n\nNo employees are available for P1 tasks during this period.`;
            }
            
            message += `\n\n⚠️ Do you want to proceed anyway? This person will have multiple P1 tasks during overlapping periods.`;
            
            // Use confirm() instead of alert() to provide OK/Cancel options
            return confirm(message);
        }

        window.addTicket = () => {
            const descInput = document.getElementById('new-ticket-desc');
            const startDateInput = document.getElementById('new-ticket-start-date');
            const sizeSelect = document.getElementById('new-ticket-size');
            const prioritySelect = document.getElementById('new-ticket-priority');
            const assignedContainer = document.getElementById('new-ticket-assigned');

            const description = descInput.value.trim();
            
            // Handle start date based on common start date setting
            let startDate;
            if (useCommonStartDate) {
                const commonDate = document.getElementById('common-start-date').value;
                startDate = commonDate || getLocalDateString(getDefaultTaskStartDate());
            } else {
                startDate = startDateInput.value || getLocalDateString(getDefaultTaskStartDate());
            }
            
            const size = sizeSelect.value;
            const priority = prioritySelect.value;
            const assigned = Array.from(assignedContainer.querySelectorAll('input[type="checkbox"]:checked')).map(checkbox => checkbox.value);

            if (!description) {
                alert("Ticket description cannot be empty.");
                return;
            }

            // Check for P1 task conflicts if this is a P1 task with assigned employees
            if (priority === 'P1' && assigned.length > 0) {
                const conflictResult = checkP1TaskConflicts(assigned, startDate, size);
                if (conflictResult.hasConflicts) {
                    const userWantsToProceed = showP1ConflictWarning(conflictResult);
                    if (!userWantsToProceed) {
                        // User clicked Cancel, abort the task creation
                        return;
                    }
                    // User clicked OK, continue with task creation
                }
            }

            const newTicket = {
                id: currentTicketId++,
                description: description,
                startDate: startDate,
                size: size,
                priority: priority,
                assigned: assigned,
                status: "To Do", // Default status for new tickets
                pauseComments: [] // Initialize empty pause comments array
            };
            
            // Initialize start date history for new ticket
            initializeStartDateHistory(newTicket);
            
            tickets.push(newTicket);

            descInput.value = '';
            startDateInput.value = '';
            sizeSelect.value = 'L';
            prioritySelect.value = 'P3'; // Reset to default priority
            // Clear all checkboxes
            assignedContainer.querySelectorAll('input[type="checkbox"]').forEach(checkbox => checkbox.checked = false);

            markDirty(); // Mark as having unsaved changes
            
            // Refresh people display since earliest task date might have changed
            if (!useCommonStartDate) {
                renderPeople();
            }
            
            calculateProjection();
            saveToLocalStorage();
        }

        window.removeTicket = (id) => {
            tickets = tickets.filter(t => t.id !== id);
            
            markDirty(); // Mark as having unsaved changes
            
            // Refresh people display since earliest task date might have changed
            if (!useCommonStartDate) {
                renderPeople();
            }
            
            calculateProjection();
            saveToLocalStorage();
        }

        window.updateTicketAssignment = (id, newAssignedArray) => {
            const ticket = tickets.find(t => t.id === id);
            if (ticket) {
                ticket.assigned = newAssignedArray;
                markDirty(); // Mark as having unsaved changes
                calculateProjection();
                saveToLocalStorage();
            }
        }
        
        window.handleAssignmentChange = (selectElement, ticketId) => {
            const newAssignedArray = Array.from(selectElement.selectedOptions).map(o => o.value);
            window.updateTicketAssignment(ticketId, newAssignedArray);
        }

        window.handleAssignmentCheckboxChange = (checkboxElement, ticketId) => {
            const personName = checkboxElement.value;
            const isChecked = checkboxElement.checked;
            
            // Find the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            // Check for P1 conflicts if this is a P1 task and person is being assigned
            if (isChecked && ticket.priority === 'P1') {
                console.log('🔍 Checkbox P1 check triggered for:', { personName, ticketId, priority: ticket.priority });
                const conflictResult = checkP1TaskConflicts([personName], ticket.startDate, ticket.size, ticketId);
                if (conflictResult.hasConflicts) {
                    console.log('⚠️ P1 conflicts found, showing warning...');
                    const userWantsToProceed = showP1ConflictWarning(conflictResult);
                    if (!userWantsToProceed) {
                        // User clicked Cancel, revert the checkbox state
                        checkboxElement.checked = false;
                        return;
                    }
                    // User clicked OK, continue with assignment
                } else {
                    console.log('✅ No P1 conflicts found');
                }
            }
            
            // Update the assignment array
            if (isChecked) {
                // Add person if not already assigned
                if (!ticket.assigned.includes(personName)) {
                    ticket.assigned.push(personName);
                }
            } else {
                // Remove person from assignment
                ticket.assigned = ticket.assigned.filter(name => name !== personName);
            }
            
            // Provide visual feedback
            checkboxElement.parentElement.style.background = '#dcfce7'; // Light green background
            setTimeout(() => {
                checkboxElement.parentElement.style.background = 'transparent';
            }, 500);
            
            // Mark as having unsaved changes
            markDirty();
            
            // Recalculate and re-render immediately
            calculateProjection();
            saveToLocalStorage();
        }

        window.handleSizeChange = (selectElement, ticketId) => {
            const newSize = selectElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldSize = ticket.size;
                ticket.size = newSize;
                
                // Clear any custom end date override when size is manually changed
                // This allows the system to recalculate end dates based on the new size
                if (ticket.customEndDate) {
                    console.log(`📅 Clearing custom end date for ticket #${ticketId} due to manual size change: ${oldSize} → ${newSize}`);
                    delete ticket.customEndDate;
                }
                
                // Provide visual feedback
                selectElement.style.background = '#dcfce7'; // Light green background
                setTimeout(() => {
                    selectElement.style.background = 'white';
                }, 500);
                
                // Mark as having unsaved changes
                markDirty();
                
                // Recalculate and re-render immediately
                calculateProjection();
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`📊 Ticket #${ticketId} size changed from ${oldSize} to ${newSize} - recalculating...`);
            }
        }

        window.handlePriorityChange = (selectElement, ticketId) => {
            const newPriority = selectElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldPriority = ticket.priority || 'P3';
                
                // Check for P1 conflicts if changing to P1 priority and ticket has assignments
                if (newPriority === 'P1' && ticket.assigned.length > 0) {
                    console.log('🔍 Priority change P1 check triggered for:', { ticketId, assigned: ticket.assigned });
                    const conflictResult = checkP1TaskConflicts(ticket.assigned, ticket.startDate, ticket.size, ticketId);
                    if (conflictResult.hasConflicts) {
                        console.log('⚠️ P1 conflicts found during priority change, showing warning...');
                        const userWantsToProceed = showP1ConflictWarning(conflictResult);
                        if (!userWantsToProceed) {
                            // User clicked Cancel, revert the priority change
                            selectElement.value = oldPriority;
                            return;
                        }
                        // User clicked OK, continue with priority change
                    } else {
                        console.log('✅ No P1 conflicts found during priority change');
                    }
                }
                
                ticket.priority = newPriority;
                
                // Provide visual feedback
                selectElement.style.background = '#e0e7ff'; // Light purple background
                setTimeout(() => {
                    selectElement.style.background = 'white';
                }, 500);
                
                // Mark as having unsaved changes
                markDirty();
                
                // Save to storage (no need to recalculate as priority doesn't affect timeline)
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`⭐ Ticket #${ticketId} priority changed from ${oldPriority} to ${newPriority}`);
            }
        }

        // Status management functions
        window.getStatusClass = (status) => {
            const statusClasses = {
                'To Do': 'status-todo',
                'In Progress': 'status-in-progress',
                'Paused': 'status-paused',
                'Done': 'status-done'
            };
            return statusClasses[status] || 'status-todo';
        }

        window.getStatusDisplay = (status) => {
            const statusDisplay = {
                'To Do': '📋 To Do',
                'In Progress': '🚀 In Progress',
                'Paused': '⏸️ Paused',
                'Done': '✅ Done'
            };
            return statusDisplay[status] || '📋 To Do';
        }

        // Enhanced status display that shows comment indicator for paused tasks
        window.getStatusDisplayWithComments = (ticket) => {
            const status = ticket.status || 'To Do';
            const baseDisplay = window.getStatusDisplay(status);
            
            // Add comment indicator for paused tasks with comments
            if (status === 'Paused' && ticket.pauseComments && ticket.pauseComments.length > 0) {
                return baseDisplay + ' 💬';
            }
            
            return baseDisplay;
        }

        // Generate tooltip text for status badges
        window.getStatusTooltip = (ticket) => {
            const status = ticket.status || 'To Do';
            let tooltip = 'Click to change status';
            
            if (status === 'Paused' && ticket.pauseComments && ticket.pauseComments.length > 0) {
                const latestComment = ticket.pauseComments[ticket.pauseComments.length - 1];
                tooltip += `\n\nLatest pause reason:\n"${latestComment.comment}"\n(${latestComment.timestamp})`;
                
                if (ticket.pauseComments.length > 1) {
                    tooltip += `\n\n${ticket.pauseComments.length} total pause comments`;
                }
            }
            
            return tooltip;
        }

        // Helper function to set task status without confirmation (for bulk operations)
        function setTaskStatusDirect(ticketId, newStatus) {
            const ticketIndex = tickets.findIndex(t => t.id === ticketId);
            if (ticketIndex > -1) {
                const oldStatus = tickets[ticketIndex].status || 'To Do';
                tickets[ticketIndex].status = newStatus;
                console.log(`📊 Ticket #${ticketId} status changed from "${oldStatus}" to "${newStatus}" (bulk operation)`);
                return true;
            }
            return false;
        }

        // Handle right-click on status badges for editing pause comments
        window.handleStatusRightClick = (event, ticketId) => {
            event.preventDefault(); // Prevent the default context menu
            
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) {
                console.error(`Ticket ${ticketId} not found`);
                return;
            }
            
            if (ticket.status !== 'Paused') {
                // For non-paused tasks, show a helpful message
                alert(`💡 Edit Comments\n\nThis feature is only available for paused tasks.\n\nCurrent status: ${ticket.status || 'To Do'}\n\nTo add pause comments, first change the task status to "Paused".`);
                return;
            }
            
            if (!ticket.pauseComments || ticket.pauseComments.length === 0) {
                // No existing comments - offer to add one
                const newComment = prompt(`➕ Add Pause Comment\n\nTask: "${ticket.description}"\n\nPlease provide a reason for why this task is paused:`);
                
                if (newComment === null) {
                    return; // User cancelled
                }
                
                // Initialize pause comments if not exists
                if (!ticket.pauseComments) {
                    ticket.pauseComments = [];
                }
                
                const timestamp = new Date().toLocaleString();
                ticket.pauseComments.push({
                    timestamp: timestamp,
                    comment: newComment || '(No reason specified)',
                    previousStatus: 'Unknown' // Since we don't know what status it was before
                });
                
                console.log(`➕ Added pause comment to ticket ${ticketId}: "${newComment}"`);
                
            } else {
                // Edit the latest comment
                const latestComment = ticket.pauseComments[ticket.pauseComments.length - 1];
                const currentComment = latestComment.comment;
                
                const editedComment = prompt(`✏️ Edit Latest Pause Comment\n\nTask: "${ticket.description}"\nOriginal comment: "${currentComment}"\nAdded: ${latestComment.timestamp}\n\nEdit your comment:`, currentComment);
                
                if (editedComment === null) {
                    return; // User cancelled
                }
                
                // Update the latest comment
                latestComment.comment = editedComment || '(No reason specified)';
                latestComment.editedAt = new Date().toLocaleString();
                
                console.log(`✏️ Edited pause comment for ticket ${ticketId}: "${editedComment}"`);
            }
            
            // Save changes and update display
            markDirty();
            saveToLocalStorage();
            calculateProjection(); // Re-render to update tooltips and display
            
            // Show success message
            alert(`✅ Comment Updated\n\nThe pause comment has been successfully updated.\nThe changes are automatically saved.`);
        }

        window.cycleTaskStatus = (ticketId) => {
            const statusCycle = ['To Do', 'In Progress', 'Paused', 'Done'];
            const ticketIndex = tickets.findIndex(t => t.id === ticketId);
            
            if (ticketIndex > -1) {
                const ticket = tickets[ticketIndex];
                const currentStatus = ticket.status || 'To Do';
                const currentIndex = statusCycle.indexOf(currentStatus);
                const nextIndex = (currentIndex + 1) % statusCycle.length;
                const nextStatus = statusCycle[nextIndex];
                
                // Get status icons for the confirmation message
                const statusIcons = {
                    'To Do': '📋',
                    'In Progress': '🚀',
                    'Paused': '⏸️',
                    'Done': '✅'
                };
                
                // Special handling for "Paused" status - request comment
                if (nextStatus === 'Paused') {
                    const pauseComment = prompt(`⏸️ Pausing Task: "${ticket.description}"\n\nPlease provide a reason for pausing this task:\n(This will help track why work was stopped)`);
                    
                    if (pauseComment === null) {
                        // User clicked Cancel on the comment prompt
                        console.log(`❌ Status change to Paused cancelled for Ticket #${ticketId} - no comment provided`);
                        return;
                    }
                    
                    // Store the pause comment (allow empty string if user wants no comment)
                    if (!ticket.pauseComments) {
                        ticket.pauseComments = [];
                    }
                    
                    const timestamp = new Date().toLocaleString();
                    ticket.pauseComments.push({
                        timestamp: timestamp,
                        comment: pauseComment || '(No reason specified)',
                        previousStatus: currentStatus
                    });
                    
                    // Update status
                    tickets[ticketIndex].status = nextStatus;
                    
                    console.log(`⏸️ Ticket #${ticketId} paused with comment: "${pauseComment}"`);
                    
                } else {
                    // Regular status change confirmation for non-Paused statuses
                    const confirmMessage = `🔄 Change Task Status?\n\n` +
                        `Task: "${ticket.description}"\n\n` +
                        `${statusIcons[currentStatus]} Current: ${currentStatus}\n` +
                        `${statusIcons[nextStatus]} New: ${nextStatus}\n\n` +
                        `Continue with status change?`;
                    
                    if (!confirm(confirmMessage)) {
                        console.log(`❌ Status change cancelled for Ticket #${ticketId}`);
                        return;
                    }
                    
                    // Update status
                    tickets[ticketIndex].status = nextStatus;
                    console.log(`📊 Ticket #${ticketId} status changed from "${currentStatus}" to "${nextStatus}"`);
                }
                
                // Provide visual feedback
                const statusElement = document.querySelector(`[onclick="cycleTaskStatus(${ticketId})"]`);
                if (statusElement) {
                    statusElement.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        statusElement.style.transform = 'scale(1)';
                    }, 150);
                }
                
                markDirty();
                saveToLocalStorage();
                calculateProjection(); // Re-calculate and render to update status display
            }
        }

        window.handleStartDateChange = (inputElement, ticketId) => {
            const newStartDate = inputElement.value;
            
            // Find and update the ticket
            const ticket = tickets.find(t => t.id === ticketId);
            if (ticket) {
                const oldStartDate = ticket.startDate;
                ticket.startDate = newStartDate;
                
                // Track start date change
                trackStartDateChange(ticket, oldStartDate, newStartDate, 'Manual update via UI');
                
                // Provide visual feedback
                inputElement.style.background = '#dcfce7'; // Light green background
                setTimeout(() => {
                    inputElement.style.background = 'white';
                }, 500);
                
                // Mark as having unsaved changes
                markDirty();
                
                // Refresh people display since earliest task date might have changed
                if (!useCommonStartDate) {
                    renderPeople();
                }
                
                // Recalculate and re-render immediately
                calculateProjection();
                saveToLocalStorage();
                
                // Optional: Show a brief notification
                console.log(`📅 Ticket #${ticketId} start date changed from ${formatDate(oldStartDate)} to ${formatDate(newStartDate)} - recalculating...`);
            }
        }

        // --- CALCULATION DETAILS MODAL FUNCTIONS ---

        window.showCalculationDetails = (ticketId) => {
            // Find the ticket and get its calculation details
            const projectedTickets = getProjectedTickets();
            const ticket = projectedTickets.find(t => t.id === ticketId);
            
            if (!ticket) {
                alert('Ticket not found.');
                return;
            }
            
            // Create enhanced content with better formatting
            const enhancedContent = `
🎯 TICKET: ${ticket.description} (ID: ${ticket.id})
📊 SIZE: ${ticket.size} 
📅 START DATE: ${formatDate(ticket.startDate)}
👥 ASSIGNED TO: ${ticket.assigned.join(', ')}
🎌 PROJECTED END: ${ticket.endDate}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

${ticket.explanation}

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

💡 HOW TO READ this calculation:
• Week numbers correspond to the planning horizon (8 weeks total)
• Pooled Capacity = combined hours available from all assigned team members
• Hours are distributed proportionally based on each person's availability
• Task completes when all required hours are allocated
• Any capacity constraints or delays are noted in the weekly breakdown
            `.trim();
            
            // Update modal content
            document.getElementById('modal-title').textContent = `📊 Calculation Details - Ticket #${ticket.id}`;
            document.getElementById('calculation-content').textContent = enhancedContent;
            
            // Show modal
            const modal = document.getElementById('calculation-modal');
            modal.classList.add('active');
            
            // Add event listener for clicking outside modal to close
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeCalculationModal();
                }
            });
        }

        window.closeCalculationModal = () => {
            const modal = document.getElementById('calculation-modal');
            modal.classList.remove('active');
        }

        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeCalculationModal();
            }
        });


        // --- INITIALIZATION ---

        function initializeDefaultData() {
            console.log("Setting up default people data.");
            people = [
                { name: 'Vipul', availability: [25, 25, 25, 25, 25, 25, 25, 25], isProjectReady: true },
                { name: 'Sameet', availability: [25, 25, 25, 25, 25, 25, 25, 25], isProjectReady: true },
                { name: 'Peter', availability: [25, 25, 25, 25, 25, 25, 25, 25], isProjectReady: true },
                { name: 'Sharanya', availability: [25, 25, 25, 25, 25, 25, 25, 25], isProjectReady: true },
                { name: 'Divya', availability: [25, 25, 25, 25, 25, 25, 25, 25], isProjectReady: true },
            ];
            
            // Use realistic current dates
            const today = new Date();
            const nextMonday = getNextMonday(new Date());
            const followingMonday = new Date(nextMonday.getTime() + 7 * 24 * 60 * 60 * 1000);
            
            tickets = [
                { id: 1, description: 'Design System Migration', size: 'XL', priority: 'P1', status: 'To Do', assigned: ['Vipul', 'Peter'], startDate: getLocalDateString(nextMonday) },
                { id: 2, description: 'Fix payment gateway bug', size: 'S', priority: 'P2', status: 'To Do', assigned: ['Sameet'], startDate: getLocalDateString(nextMonday) },
                { id: 3, description: 'Build new reporting dashboard', size: 'XXL', priority: 'P3', status: 'To Do', assigned: ['Sharanya', 'Divya'], startDate: getLocalDateString(followingMonday) },
                // Add some overdue tasks for testing (3 days ago)
                { id: 4, description: 'Update documentation', size: 'M', priority: 'P2', status: 'To Do', assigned: ['Vipul'], startDate: getLocalDateString(new Date(today.getTime() - 3 * 24 * 60 * 60 * 1000)) },
                { id: 5, description: 'Code review backlog', size: 'S', priority: 'P3', status: 'To Do', assigned: ['Peter'], startDate: getLocalDateString(new Date(today.getTime() - 2 * 24 * 60 * 60 * 1000)) },
                // Add some "In Progress" tasks that are overdue for testing bulk resolution
                { id: 6, description: 'API Security Audit', size: 'M', priority: 'P1', status: 'In Progress', assigned: ['Sameet'], startDate: getLocalDateString(new Date(today.getTime() - 5 * 24 * 60 * 60 * 1000)) },
                { id: 7, description: 'Performance Optimization', size: 'S', priority: 'P2', status: 'In Progress', assigned: ['Vipul'], startDate: getLocalDateString(new Date(today.getTime() - 3 * 24 * 60 * 60 * 1000)) },
                { id: 8, description: 'Database Migration Script', size: 'L', priority: 'P1', status: 'In Progress', assigned: ['Peter', 'Sharanya'], startDate: getLocalDateString(new Date(today.getTime() - 8 * 24 * 60 * 60 * 1000)) }
            ];
            
            // Initialize all history for all tasks
            tickets = tickets.map(ticket => {
                ticket = initializeStartDateHistory(ticket);
                ticket = initializeEndDateHistory(ticket);
                ticket = initializeSizeHistory(ticket);
                return ticket;
            });
            currentTicketId = 9;
            saveToLocalStorage(); 
        }

        // Check for overdue "To Do" tasks on startup
        function checkOverdueTasks() {
            console.log('🔍 Checking for overdue tasks...');
            
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Reset time to start of day for comparison
            
            // Use local date string instead of ISO to avoid timezone issues
            const todayStr = getLocalDateString(today);
            
            console.log(`📅 Today's date: ${todayStr}`);
            console.log(`📋 Total tickets: ${tickets.length}`);
            
            // Find all "To Do" tasks with start dates in the past
            const overdueTasks = tickets.filter(ticket => {
                const status = ticket.status || 'To Do'; // Default to 'To Do' if no status
                console.log(`🎫 Ticket #${ticket.id}: "${ticket.description}" - Status: "${status}", Start: ${ticket.startDate}`);
                
                if (status !== 'To Do') {
                    console.log(`  ⏭️ Skipping - not "To Do" status`);
                    return false;
                }
                
                const startDate = new Date(ticket.startDate);
                startDate.setHours(0, 0, 0, 0);
                
                const isOverdue = startDate < today;
                console.log(`  📅 Start date: ${getLocalDateString(startDate)}, Overdue: ${isOverdue}`);
                
                return isOverdue;
            });
            
            console.log(`⚠️ Found ${overdueTasks.length} overdue tasks`);
            
            if (overdueTasks.length === 0) {
                console.log('✅ No overdue tasks found');
                return; // No overdue tasks found
            }
            
            // Create detailed message about overdue tasks
            const taskList = overdueTasks.slice(0, 5).map(task => 
                `• "${task.description}" (Start: ${formatDate(task.startDate)})`
            ).join('\n');
            
            const moreText = overdueTasks.length > 5 ? `\n... and ${overdueTasks.length - 5} more tasks` : '';
            
            const confirmMessage = `⚠️ Found ${overdueTasks.length} Overdue "To Do" Tasks\n\n` +
                `These tasks have start dates in the past but are still marked as "To Do":\n\n${taskList}${moreText}\n\n` +
                `What would you like to do with these tasks?\n\n` +
                `✅ OK = Move start dates to today\n` +
                `❌ Cancel = Change status to "In Progress"`;
            
            if (confirm(confirmMessage)) {
                // Option 1: Move start dates to today
                // Use local date string instead of ISO to avoid timezone issues
                const todayStr = getLocalDateString(today);
                let updatedCount = 0;
                
                overdueTasks.forEach(task => {
                    const oldStartDate = task.startDate;
                    task.startDate = todayStr;
                    
                    // Track start date change for overdue task correction
                    trackStartDateChange(task, oldStartDate, todayStr, 'Overdue task correction');
                    updatedCount++;
                });
                
                console.log(`📅 Updated ${updatedCount} overdue tasks to start today (${todayStr})`);
                alert(`📅 Success!\n\nUpdated ${updatedCount} tasks to start today.\nStart dates have been moved to ${formatDate(todayStr)}.`);
                
            } else {
                // Option 2: Change status to "In Progress" (bypass confirmation popups)
                let updatedCount = 0;
                
                overdueTasks.forEach(task => {
                    if (setTaskStatusDirect(task.id, 'In Progress')) {
                        updatedCount++;
                    }
                });
                
                console.log(`🚀 Changed ${updatedCount} overdue tasks to "In Progress" status`);
                alert(`🚀 Success!\n\nChanged ${updatedCount} tasks to "In Progress" status.\nThese tasks are now marked as actively being worked on.`);
            }
            
            // Save changes and update display
            markDirty();
            saveToLocalStorage();
            
            // Force recalculation and re-render to show updated dates/statuses
            calculateProjection();
        }

        function initializeScheduler() {
            if (!loadFromLocalStorage()) {
                initializeDefaultData();
            }
            
            // Migration: Add priority to existing tasks that don't have it
            let migrationNeeded = false;
            tickets.forEach(ticket => {
                if (!ticket.priority) {
                    ticket.priority = 'P3'; // Default priority
                    migrationNeeded = true;
                }
                if (!ticket.status) {
                    ticket.status = 'To Do'; // Default status
                    migrationNeeded = true;
                }
            });
            
            if (migrationNeeded) {
                saveToLocalStorage();
                console.log('📊 Migrated existing tasks to include priority and status fields');
            }
            
            // Set default start date to a sensible default
            const defaultStartDate = getLocalDateString(getDefaultTaskStartDate());
            document.getElementById('new-ticket-start-date').value = defaultStartDate;
            document.getElementById('common-start-date').value = defaultStartDate;
            
            // Restore common start date state
            const checkbox = document.getElementById('use-common-start-date');
            checkbox.checked = useCommonStartDate;
            if (useCommonStartDate) {
                toggleCommonStartDate();
            }
            
            // Initial render
            calculateEffortMap();
            renderEffortMap();
            renderPeople();
            calculateProjection(); // This now includes timeline rendering
            
            // Initialize UI components
            updateTicketSizeDropdown(); // Populate the task size dropdown
            updateFilterUI();
            
            // Update form field displays
            document.getElementById('estimation-base-hours').value = estimationBaseHours;
            document.getElementById('project-hours-per-day').value = projectHoursPerDay;
            document.getElementById('estimation-base-display').textContent = estimationBaseHours;
            
            // Check for overdue "To Do" tasks AFTER initial rendering is complete
            checkOverdueTasks();
        }

        // --- TEAM WORKLOAD HEAT MAP ---
        function calculateWorkloadHeatMap() {
            const projectedTickets = getProjectedTickets();
            // Filter out completed and paused tasks for capacity calculation
            const activeTickets = projectedTickets.filter(ticket => 
                ticket.status !== 'Done' && ticket.status !== 'Paused'
            );
            const heatMapData = [];
            
            // Get the start date for the heat map (earliest task or today)
            let startDate = new Date();
            if (activeTickets.length > 0) {
                const earliestTask = activeTickets.reduce((earliest, task) => 
                    new Date(task.startDate) < new Date(earliest.startDate) ? task : earliest
                );
                startDate = new Date(earliestTask.startDate);
            }
            
            // Ensure we start from a Monday
            while (startDate.getDay() !== 1) {
                startDate.setDate(startDate.getDate() - 1);
            }
            
            // Calculate for each person
            people.forEach(person => {
                const personData = {
                    name: person.name,
                    weeks: []
                };
                
                // Calculate for next 8 weeks
                for (let weekIndex = 0; weekIndex < 8; weekIndex++) {
                    const weekStart = new Date(startDate);
                    weekStart.setDate(startDate.getDate() + (weekIndex * 7));
                    
                    const weekEnd = new Date(weekStart);
                    weekEnd.setDate(weekStart.getDate() + 6);
                    
                    // Get person's availability for this week
                    const availability = person.availability && person.availability[weekIndex] !== undefined 
                        ? person.availability[weekIndex] 
                        : projectHoursPerDay * 5; // Default to full week if not defined
                    
                    // Calculate assigned hours for this week
                    let assignedHours = 0;
                    
                    activeTickets.forEach(ticket => {
                        if (ticket.assigned.includes(person.name)) {
                            const taskStart = new Date(ticket.startDate);
                            const taskEnd = ticket.rawEndDate ? new Date(ticket.rawEndDate) : new Date(taskStart);
                            
                            // Check if task overlaps with this week
                            if (taskStart <= weekEnd && taskEnd >= weekStart) {
                                // Calculate overlap period
                                const overlapStart = new Date(Math.max(taskStart.getTime(), weekStart.getTime()));
                                const overlapEnd = new Date(Math.min(taskEnd.getTime(), weekEnd.getTime()));
                                
                                // Calculate business days in overlap period
                                let businessDays = 0;
                                const currentDate = new Date(overlapStart);
                                while (currentDate <= overlapEnd) {
                                    const dayOfWeek = currentDate.getDay();
                                    if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                                        businessDays++;
                                    }
                                    currentDate.setDate(currentDate.getDate() + 1);
                                }
                                
                                // Calculate hours for this person for this task
                                const totalTaskDays = taskSizeDefinitions[ticket.size]?.days || ticketDays[ticket.size] || 1;
                                const totalTaskHours = totalTaskDays * estimationBaseHours; // Use estimation base for task effort
                                const hoursPerAssignee = totalTaskHours / Math.max(ticket.assigned.length, 1); // Prevent division by zero
                                
                                // Distribute hours across task duration
                                const taskBusinessDays = Math.max(calculateBusinessDays(taskStart, taskEnd), 1); // Prevent division by zero
                                const dailyHours = hoursPerAssignee / taskBusinessDays;
                                
                                // Ensure we have valid numbers
                                if (!isNaN(dailyHours) && !isNaN(businessDays)) {
                                    assignedHours += dailyHours * businessDays;
                                }
                            }
                        }
                    });
                    
                    // Calculate utilization percentage with proper error handling
                    let utilization = 0;
                    if (availability > 0 && !isNaN(assignedHours) && !isNaN(availability)) {
                        utilization = Math.round((assignedHours / availability) * 100);
                    } else if (assignedHours > 0 && availability === 0) {
                        utilization = 999; // Indicate overload when no capacity but has assignments
                    }
                    
                    // Ensure utilization is a valid number
                    if (isNaN(utilization) || !isFinite(utilization)) {
                        utilization = 0;
                    }
                    
                    // Determine color based on utilization
                    let colorClass = 'bg-green-100 border-green-300 text-green-800';
                    if (utilization === 999 || utilization > 90) {
                        colorClass = 'bg-red-100 border-red-300 text-red-800';
                    } else if (utilization > 60) {
                        colorClass = 'bg-yellow-100 border-yellow-300 text-yellow-800';
                    }
                    
                    personData.weeks.push({
                        weekIndex: weekIndex + 1,
                        weekStart: formatDate(weekStart),
                        weekEnd: formatDate(weekEnd),
                        availability: availability,
                        assignedHours: Math.round(assignedHours * 10) / 10,
                        utilization: utilization,
                        colorClass: colorClass
                    });
                }
                
                heatMapData.push(personData);
            });
            
            return heatMapData;
        }
        
        function calculateBusinessDays(startDate, endDate) {
            let businessDays = 0;
            const currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                const dayOfWeek = currentDate.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                    businessDays++;
                }
                currentDate.setDate(currentDate.getDate() + 1);
            }
            return businessDays;
        }
        
        function addBusinessDays(startDate, businessDaysToAdd) {
            const result = new Date(startDate);
            let daysAdded = 0;
            
            while (daysAdded < businessDaysToAdd) {
                result.setDate(result.getDate() + 1);
                const dayOfWeek = result.getDay();
                if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                    daysAdded++;
                }
            }
            
            return result;
        }
        
        function getNextBusinessDay(date) {
            const result = new Date(date);
            const dayOfWeek = result.getDay();
            
            if (dayOfWeek === 0) { // Sunday
                result.setDate(result.getDate() + 1); // Move to Monday
            } else if (dayOfWeek === 6) { // Saturday
                result.setDate(result.getDate() + 2); // Move to Monday
            }
            
            return result;
        }
        
        function renderWorkloadHeatMap() {
            const heatMapData = calculateWorkloadHeatMap();
            const container = document.getElementById('workload-heatmap');
            
            if (heatMapData.length === 0) {
                container.innerHTML = '<p class="text-center py-4 text-gray-500">No team members defined. Add team members to see workload heat map.</p>';
                return;
            }
            
            // Create table
            let html = '<table class="w-full border-collapse">';
            
            // Header row
            html += '<thead><tr class="bg-gray-50">';
            html += '<th class="border border-gray-300 px-3 py-2 text-left font-semibold">Team Member</th>';
            for (let i = 1; i <= 8; i++) {
                const weekRange = getWeekDateRange(i - 1);
                html += `<th class="border border-gray-300 px-2 py-2 text-center font-semibold text-sm">
                    <div>Week ${i}</div>
                    <div class="text-xs text-gray-600 font-normal">${weekRange}</div>
                </th>`;
            }
            html += '</tr></thead>';
            
            // Data rows
            html += '<tbody>';
            heatMapData.forEach(person => {
                html += '<tr>';
                html += `<td class="border border-gray-300 px-3 py-2 font-medium">${person.name}</td>`;
                
                person.weeks.forEach((week, weekIndex) => {
                    const tooltip = `Week ${week.weekIndex} (${week.weekStart} - ${week.weekEnd})\\nAvailable: ${week.availability}h\\nAssigned: ${week.assignedHours}h\\nUtilization: ${week.utilization === 999 ? 'Overloaded' : week.utilization + '%'}`;
                    
                    // Format display value
                    const displayValue = week.utilization === 999 ? 'OVR' : `${week.utilization}%`;
                    
                    html += `<td class="border border-gray-300 p-1">
                        <div class="${week.colorClass} rounded px-2 py-1 text-center text-sm font-medium cursor-pointer hover:opacity-80 transition-opacity"
                             title="${tooltip}"
                             onclick="showWeekTaskDetails('${person.name}', ${weekIndex}, '${week.weekStart}', '${week.weekEnd}')">
                            ${displayValue}
                        </div>
                    </td>`;
                });
                
                html += '</tr>';
            });
            html += '</tbody></table>';
            
            container.innerHTML = html;
        }

        // --- WEEK TASK DETAILS MODAL ---
        
        function generateTaskCalendar(weekTasks, weekStartDate) {
            if (weekTasks.length === 0) return '';
            
            // Calculate the month view that includes the week
            const firstTaskDate = new Date(Math.min(...weekTasks.map(t => t.taskStartDate.getTime())));
            const lastTaskDate = new Date(Math.max(...weekTasks.map(t => t.taskEndDate ? t.taskEndDate.getTime() : t.taskStartDate.getTime())));
            
            // Start from the beginning of the month containing the earliest task
            const calendarStart = new Date(firstTaskDate.getFullYear(), firstTaskDate.getMonth(), 1);
            
            // End at the end of the month containing the latest task
            const calendarEnd = new Date(lastTaskDate.getFullYear(), lastTaskDate.getMonth() + 1, 0);
            
            // Generate calendar
            let calendarHtml = `
                <div class="mt-6 border-t pt-4">
                    <h5 class="font-semibold text-gray-800 mb-3">📅 Task Timeline Calendar</h5>
                    <div class="bg-white border border-gray-200 rounded-lg p-3">
            `;
            
            // Task colors for different tasks (cycling through colors)
            const taskColors = [
                'bg-blue-200 border-blue-400 text-blue-900',
                'bg-green-200 border-green-400 text-green-900', 
                'bg-purple-200 border-purple-400 text-purple-900',
                'bg-orange-200 border-orange-400 text-orange-900',
                'bg-pink-200 border-pink-400 text-pink-900'
            ];
            
            let currentMonth = calendarStart.getMonth();
            let currentDate = new Date(calendarStart);
            
            while (currentDate <= calendarEnd) {
                if (currentDate.getMonth() !== currentMonth) {
                    currentMonth = currentDate.getMonth();
                }
                
                // Month header
                const monthName = currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                calendarHtml += `<div class="text-center font-semibold text-gray-700 mb-2">${monthName}</div>`;
                
                // Days of week header
                calendarHtml += `
                    <div class="grid grid-cols-7 gap-1 mb-2 text-xs text-gray-600 text-center">
                        <div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div>
                    </div>
                `;
                
                // Calculate first day of month and padding
                const firstDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
                const startPadding = firstDayOfMonth.getDay();
                
                // Days in month
                const lastDayOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0);
                const daysInMonth = lastDayOfMonth.getDate();
                
                calendarHtml += '<div class="grid grid-cols-7 gap-1">';
                
                // Empty cells for padding
                for (let i = 0; i < startPadding; i++) {
                    calendarHtml += '<div class="h-8"></div>';
                }
                
                // Days of the month
                for (let day = 1; day <= daysInMonth; day++) {
                    const dayDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
                    const dayStr = getLocalDateString(dayDate);
                    const dayOfWeek = dayDate.getDay(); // 0 = Sunday, 6 = Saturday
                    
                    // Check which tasks are active on this day (only for business days)
                    const activeTasks = weekTasks.filter(task => {
                        const taskStart = task.taskStartDate;
                        const taskEnd = task.taskEndDate || task.taskStartDate;
                        
                        // Normalize dates to midnight for accurate day comparison
                        const dayDateNormalized = new Date(dayDate.getFullYear(), dayDate.getMonth(), dayDate.getDate());
                        const taskStartNormalized = new Date(taskStart.getFullYear(), taskStart.getMonth(), taskStart.getDate());
                        const taskEndNormalized = new Date(taskEnd.getFullYear(), taskEnd.getMonth(), taskEnd.getDate());
                        
                        // Only show tasks on business days (Monday = 1, Friday = 5)
                        return dayDateNormalized >= taskStartNormalized && dayDateNormalized <= taskEndNormalized && dayOfWeek >= 1 && dayOfWeek <= 5;
                    });
                    
                    let dayClass = 'h-8 flex items-center justify-center text-xs border border-gray-200';
                    let dayContent = day;
                    let title = '';
                    
                    // Add weekend styling
                    if (dayOfWeek === 0 || dayOfWeek === 6) {
                        dayClass += ' bg-gray-100 text-gray-400';
                    }
                    
                    if (activeTasks.length > 0) {
                        // Use the color of the first task, or a mixed color if multiple
                        const primaryTask = activeTasks[0];
                        const taskIndex = weekTasks.findIndex(t => t.id === primaryTask.id);
                        const colorClass = taskColors[taskIndex % taskColors.length];
                        dayClass += ` ${colorClass} font-medium`;
                        
                        // Create tooltip with task info
                        const taskTitles = activeTasks.map(t => `${t.title || `Task ${t.id}`} (${t.size})`).join(', ');
                        title = `title="${taskTitles}"`;
                        
                        if (activeTasks.length > 1) {
                            dayContent += `<span class="ml-1 text-xs">+${activeTasks.length - 1}</span>`;
                        }
                    } else {
                        dayClass += ' hover:bg-gray-50';
                    }
                    
                    calendarHtml += `<div class="${dayClass}" ${title}>${dayContent}</div>`;
                }
                
                calendarHtml += '</div>';
                
                // Move to next month
                currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
            }
            
            // Add legend
            if (weekTasks.length > 0) {
                calendarHtml += `
                    <div class="mt-3 pt-3 border-t border-gray-200">
                        <div class="text-xs text-gray-600 mb-2">Legend:</div>
                        <div class="grid grid-cols-1 gap-1 text-xs">
                `;
                
                weekTasks.forEach((task, index) => {
                    const colorClass = taskColors[index % taskColors.length];
                    calendarHtml += `
                        <div class="flex items-center gap-2">
                            <div class="w-4 h-3 ${colorClass} border rounded"></div>
                            <span>${task.title || `Task ${task.id}`} (${task.size})</span>
                        </div>
                    `;
                });
                
                calendarHtml += `
                        </div>
                    </div>
                `;
            }
            
            calendarHtml += '</div></div>';
            return calendarHtml;
        }
        
        function showWeekTaskDetails(personName, weekIndex, weekStart, weekEnd) {
            const modal = document.getElementById('week-task-modal');
            const title = document.getElementById('modal-title');
            const content = document.getElementById('modal-content');
            
            title.textContent = `${personName} - Week ${weekIndex + 1} (${weekStart} - ${weekEnd})`;
            
            // Get projected tickets with calculated end dates
            const projectedTickets = getProjectedTickets();
            
            // Find all tasks for this person in this week
            const weekTasks = [];
            projectedTickets.forEach(ticket => {
                if (ticket.assigned.includes(personName)) {
                    const taskStartDate = new Date(ticket.startDate || getEffectiveStartDate());
                    const taskEndDate = ticket.rawEndDate ? new Date(ticket.rawEndDate) : null;
                    
                    // Check if task overlaps with this week
                    const weekStartDate = new Date(getEffectiveStartDate());
                    weekStartDate.setDate(weekStartDate.getDate() + (weekIndex * 7));
                    const weekEndDate = new Date(weekStartDate);
                    weekEndDate.setDate(weekEndDate.getDate() + 4);
                    
                    // Task overlaps if it starts before week ends and ends after week starts
                    if (taskStartDate <= weekEndDate && (!taskEndDate || taskEndDate >= weekStartDate)) {
                        weekTasks.push({
                            ...ticket,
                            taskStartDate: taskStartDate,
                            taskEndDate: taskEndDate
                        });
                    }
                }
            });
            
            // Generate content
            let html = '';
            if (weekTasks.length === 0) {
                html = '<p class="text-gray-500 text-center py-4">No tasks assigned for this week.</p>';
            } else {
                html = '<div class="space-y-3">';
                weekTasks.forEach(task => {
                    const startStr = task.taskStartDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    const endStr = task.endDate || 'N/A'; // Use the calculated endDate from projection
                    
                    html += `
                        <div class="border border-gray-200 rounded-lg p-4 bg-gray-50">
                            <div class="flex justify-between items-start mb-2">
                                <h4 class="font-semibold text-lg">${task.title || `Task ${task.id}`}</h4>
                                <span class="text-sm font-medium px-2 py-1 bg-blue-100 text-blue-800 rounded">${task.size}</span>
                            </div>
                            <p class="text-gray-700 mb-2">${task.description}</p>
                            <div class="text-sm text-gray-600">
                                <div><strong>Start Date:</strong> ${startStr}</div>
                                <div><strong>End Date:</strong> ${endStr}</div>
                                <div><strong>Priority:</strong> ${task.priority}</div>
                                <div><strong>Assigned:</strong> ${task.assigned.join(', ')}</div>
                            </div>
                        </div>
                    `;
                });
                html += '</div>';
                
                // Add calendar visualization
                const weekStartDate = new Date(getEffectiveStartDate());
                weekStartDate.setDate(weekStartDate.getDate() + (weekIndex * 7));
                html += generateTaskCalendar(weekTasks, weekStartDate);
            }
            
            content.innerHTML = html;
            modal.classList.remove('hidden');
        }
        
        function closeWeekTaskModal() {
            const modal = document.getElementById('week-task-modal');
            modal.classList.add('hidden');
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('week-task-modal');
            if (event.target === modal) {
                closeWeekTaskModal();
            }
        });

        // --- CSV EXPORT FUNCTIONALITY ---
        function exportTaskMapCSV() {
            const projectedTickets = getProjectedTickets();
            const effectiveStartDate = getEffectiveStartDate();
            
            // Generate date range for next 8 weeks (business days only)
            const dates = [];
            const currentDate = new Date(effectiveStartDate);
            
            // Generate dates for 8 weeks (56 days), but only include business days
            for (let week = 0; week < 8; week++) {
                for (let day = 0; day < 7; day++) {
                    const date = new Date(effectiveStartDate);
                    date.setDate(date.getDate() + (week * 7) + day);
                    
                    // Only include Monday to Friday (1-5)
                    const dayOfWeek = date.getDay();
                    if (dayOfWeek >= 1 && dayOfWeek <= 5) {
                        dates.push(new Date(date));
                    }
                }
            }
            
            // Create CSV headers
            const headers = ['Employee'];
            dates.forEach(date => {
                const dateStr = date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric'
                });
                headers.push(dateStr);
            });
            
            // Create CSV rows - one row per task assignment
            const csvRows = [headers];
            
            // Get all unique task assignments
            const taskAssignments = [];
            projectedTickets.forEach(ticket => {
                ticket.assigned.forEach(personName => {
                    taskAssignments.push({
                        person: personName,
                        task: ticket,
                        taskName: ticket.description || ticket.title || `Task ${ticket.id}`
                    });
                });
            });
            
            // Group by person
            const assignmentsByPerson = {};
            taskAssignments.forEach(assignment => {
                if (!assignmentsByPerson[assignment.person]) {
                    assignmentsByPerson[assignment.person] = [];
                }
                assignmentsByPerson[assignment.person].push(assignment);
            });
            
            // Create rows for each person's tasks
            people.forEach(person => {
                const personTasks = assignmentsByPerson[person.name] || [];
                
                if (personTasks.length === 0) {
                    // Person has no tasks - create empty row
                    const row = [person.name];
                    dates.forEach(date => {
                        const dayOfWeek = date.getDay();
                        if (dayOfWeek === 0 || dayOfWeek === 6) {
                            row.push('Weekend');
                        } else {
                            row.push(''); // Empty for available days
                        }
                    });
                    csvRows.push(row);
                } else {
                    // Create one row per task for this person
                    personTasks.forEach((taskAssignment, taskIndex) => {
                        const row = [person.name];
                        const task = taskAssignment.task;
                        const taskStartDate = new Date(task.startDate || effectiveStartDate);
                        const taskEndDate = task.rawEndDate ? new Date(task.rawEndDate) : null;
                        
                        dates.forEach(date => {
                            // Check if this specific task is active on this date
                            let cellContent = '';
                            
                            if (taskEndDate) {
                                if (date >= taskStartDate && date <= taskEndDate) {
                                    cellContent = taskAssignment.taskName;
                                }
                            } else {
                                if (date.toDateString() === taskStartDate.toDateString()) {
                                    cellContent = taskAssignment.taskName;
                                }
                            }
                            
                            // If no task content, check if weekend
                            if (!cellContent) {
                                const dayOfWeek = date.getDay();
                                if (dayOfWeek === 0 || dayOfWeek === 6) {
                                    cellContent = 'Weekend';
                                }
                            }
                            
                            row.push(cellContent);
                        });
                        
                        csvRows.push(row);
                    });
                }
            });
            
            // Convert to CSV string
            const csvContent = csvRows.map(row => 
                row.map(cell => {
                    // Escape quotes and wrap in quotes if contains comma, quote, or newline
                    const cellStr = String(cell || '');
                    if (cellStr.includes(',') || cellStr.includes('"') || cellStr.includes('\n')) {
                        return `"${cellStr.replace(/"/g, '""')}"`;
                    }
                    return cellStr;
                }).join(',')
            ).join('\n');
            
            // Create and download file
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                
                // Generate filename with current date
                const today = new Date();
                const dateStr = getLocalDateString(today);
                link.setAttribute('download', `task-map-${dateStr}.csv`);
                
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Show success message
                alert('Task map CSV exported successfully!');
            } else {
                alert('CSV export not supported in this browser');
            }
        }

        // --- DELAY ANALYSIS FUNCTIONALITY ---
        function generateDelayAnalysis() {
            console.log('⏰ Generating start date delay analysis...');
            
            // Ensure all tasks have history initialized
            tickets.forEach(ticket => {
                initializeStartDateHistory(ticket);
                initializeEndDateHistory(ticket);
                initializeSizeHistory(ticket);
            });
            
            // Analyze delay patterns
            const delayData = tickets.map(ticket => {
                const history = ticket.startDateHistory || [];
                const delayCount = Math.max(0, history.length - 1); // Subtract 1 for initial planning
                const totalDelayDays = calculateTotalDelayDays(history);
                
                return {
                    ticket: ticket,
                    delayCount: delayCount,
                    totalDelayDays: totalDelayDays,
                    history: history,
                    isProblematic: delayCount >= 2 || totalDelayDays >= 7 // 2+ delays or 7+ days total delay
                };
            });
            
            // Sort by most problematic first
            delayData.sort((a, b) => {
                if (a.isProblematic !== b.isProblematic) {
                    return a.isProblematic ? -1 : 1; // Problematic tasks first
                }
                return b.delayCount - a.delayCount; // Then by delay count
            });
            
            console.log('📊 Delay analysis data:', delayData);
            
            // Show modal and render analysis
            document.getElementById('delayAnalysisModal').classList.remove('hidden');
            renderDelayAnalysis(delayData);
        }

        function calculateTotalDelayDays(history) {
            if (history.length <= 1) return 0;
            
            const originalDate = new Date(history[0].date);
            const currentDate = new Date(history[history.length - 1].date);
            
            // Calculate business days difference
            return Math.max(0, Math.floor((currentDate - originalDate) / (1000 * 60 * 60 * 24)));
        }

        function renderDelayAnalysis(delayData) {
            const container = document.getElementById('delayAnalysisContent');
            
            const problematicTasks = delayData.filter(d => d.isProblematic);
            const goodTasks = delayData.filter(d => !d.isProblematic);
            
            let html = `
                <div class="space-y-6">
                    <!-- Summary Section -->
                    <div class="bg-blue-50 border border-blue-200 rounded-lg p-4">
                        <h3 class="text-lg font-semibold text-blue-800 mb-2">📊 Delay Analysis Summary</h3>
                        <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm">
                            <div class="bg-white rounded p-3 text-center">
                                <div class="text-2xl font-bold text-gray-800">${delayData.length}</div>
                                <div class="text-gray-600">Total Tasks</div>
                            </div>
                            <div class="bg-white rounded p-3 text-center">
                                <div class="text-2xl font-bold text-red-600">${problematicTasks.length}</div>
                                <div class="text-gray-600">Problematic Tasks</div>
                            </div>
                            <div class="bg-white rounded p-3 text-center">
                                <div class="text-2xl font-bold text-green-600">${goodTasks.length}</div>
                                <div class="text-gray-600">On-Track Tasks</div>
                            </div>
                            <div class="bg-white rounded p-3 text-center">
                                <div class="text-2xl font-bold text-orange-600">${delayData.reduce((sum, d) => sum + d.delayCount, 0)}</div>
                                <div class="text-gray-600">Total Delays</div>
                            </div>
                        </div>
                    </div>

                    <!-- Problematic Tasks Section -->
                    ${problematicTasks.length > 0 ? `
                    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                        <h3 class="text-lg font-semibold text-red-800 mb-4">🚨 Problematic Tasks (High Delay Risk)</h3>
                        <div class="space-y-3">
                            ${problematicTasks.map(data => generateTaskDelayCard(data, 'red')).join('')}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Good Tasks Section -->
                    ${goodTasks.length > 0 ? `
                    <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                        <h3 class="text-lg font-semibold text-green-800 mb-4">✅ On-Track Tasks</h3>
                        <div class="space-y-2">
                            ${goodTasks.slice(0, 10).map(data => generateTaskDelayCard(data, 'green')).join('')}
                            ${goodTasks.length > 10 ? `<div class="text-sm text-gray-600 italic">... and ${goodTasks.length - 10} more on-track tasks</div>` : ''}
                        </div>
                    </div>
                    ` : ''}

                    <!-- Delay Pattern Chart -->
                    <div class="bg-gray-50 border border-gray-200 rounded-lg p-4">
                        <h3 class="text-lg font-semibold text-gray-800 mb-4">📈 Delay Pattern Visualization</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            ${renderDelayChart(delayData)}
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }

        function generateTaskDelayCard(data, type) {
            const colorClasses = {
                red: 'bg-red-100 border-red-300 text-red-800',
                green: 'bg-green-100 border-green-300 text-green-800'
            };
            
            const colorClass = colorClasses[type] || colorClasses.green;
            
            return `
                <div class="border rounded p-3 ${colorClass}">
                    <div class="flex justify-between items-start">
                        <div class="flex-1">
                            <div class="font-semibold">${data.ticket.description}</div>
                            <div class="text-sm mt-1">
                                ${data.delayCount} delays • ${data.totalDelayDays} days total delay
                            </div>
                        </div>
                        <div class="text-right text-sm">
                            <div>Size: ${data.ticket.size}</div>
                            <div>Priority: ${data.ticket.priority || 'P3'}</div>
                        </div>
                    </div>
                    ${data.history.length > 1 ? `
                    <div class="mt-2 text-xs">
                        <div class="font-medium">Start Date History:</div>
                        ${data.history.map((entry, index) => `
                            <div class="ml-2">${index + 1}. ${formatDate(entry.date)} ${entry.reason ? `(${entry.reason})` : ''}</div>
                        `).join('')}
                    </div>
                    ` : ''}
                </div>
            `;
        }

        function renderDelayChart(delayData) {
            // Create a simple histogram of delay counts
            const delayCounts = {};
            delayData.forEach(data => {
                const count = data.delayCount;
                delayCounts[count] = (delayCounts[count] || 0) + 1;
            });
            
            const maxCount = Math.max(...Object.values(delayCounts));
            const chartHtml = Object.keys(delayCounts).sort((a, b) => parseInt(a) - parseInt(b)).map(delayCount => {
                const count = delayCounts[delayCount];
                const barHeight = (count / maxCount) * 100;
                return `
                    <div class="text-center">
                        <div class="bg-blue-200 border border-blue-300 mx-auto mb-1" style="width: 40px; height: ${Math.max(barHeight, 5)}px; max-height: 100px;"></div>
                        <div class="text-xs">${delayCount} delays</div>
                        <div class="text-xs font-semibold">${count} tasks</div>
                    </div>
                `;
            }).join('');
            
            return `
                <div>
                    <h4 class="font-semibold mb-2">Delay Distribution</h4>
                    <div class="flex items-end justify-center space-x-2" style="height: 120px;">
                        ${chartHtml}
                    </div>
                </div>
                <div>
                    <h4 class="font-semibold mb-2">Key Insights</h4>
                    <ul class="text-sm space-y-1">
                        <li>• ${delayData.filter(d => d.delayCount === 0).length} tasks started on original date</li>
                        <li>• ${delayData.filter(d => d.delayCount >= 1).length} tasks experienced delays</li>
                        <li>• ${delayData.filter(d => d.isProblematic).length} tasks need attention</li>
                        <li>• Avg delays per task: ${(delayData.reduce((sum, d) => sum + d.delayCount, 0) / delayData.length).toFixed(1)}</li>
                    </ul>
                </div>
            `;
        }

        function closeDelayAnalysis() {
            document.getElementById('delayAnalysisModal').classList.add('hidden');
        }

        // === BULK TASK RESOLUTION FUNCTIONS ===
        
        function openBulkTaskResolution() {
            // Find all "In Progress" tasks with past end dates
            const overdueInProgressTasks = getOverdueInProgressTasks();
            
            if (overdueInProgressTasks.length === 0) {
                alert('✅ No overdue "In Progress" tasks found!\n\nAll tasks are either on track or not yet in progress.');
                return;
            }
            
            renderBulkTaskResolutionContent(overdueInProgressTasks);
            document.getElementById('bulkTaskResolutionModal').classList.remove('hidden');
        }

        function closeBulkTaskResolution() {
            document.getElementById('bulkTaskResolutionModal').classList.add('hidden');
        }

        function getOverdueInProgressTasks() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            const projectedTickets = getProjectedTickets();
            
            return tickets.filter(ticket => {
                // Must be "In Progress"
                if (ticket.status !== 'In Progress') return false;
                
                // Must have a calculated end date that's in the past
                const projectedTicket = projectedTickets.find(pt => pt.id === ticket.id);
                if (!projectedTicket || !projectedTicket.rawEndDate) return false;
                
                const endDate = new Date(projectedTicket.rawEndDate);
                endDate.setHours(0, 0, 0, 0);
                
                return endDate < today;
            });
        }

        function renderBulkTaskResolutionContent(overdueInProgressTasks) {
            const projectedTickets = getProjectedTickets();
            
            let html = `
                <div class="space-y-4">
                    <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
                        <h3 class="text-lg font-semibold text-yellow-800 mb-2">📊 Summary</h3>
                        <p class="text-yellow-700">
                            Found <strong>${overdueInProgressTasks.length}</strong> overdue "In Progress" task${overdueInProgressTasks.length !== 1 ? 's' : ''} that need resolution.
                        </p>
                    </div>
            `;
            
            overdueInProgressTasks.forEach(ticket => {
                const projectedTicket = projectedTickets.find(pt => pt.id === ticket.id);
                const endDate = projectedTicket ? new Date(projectedTicket.rawEndDate) : null;
                const daysOverdue = endDate ? Math.floor((new Date() - endDate) / (1000 * 60 * 60 * 24)) : 0;
                
                html += `
                    <div class="border border-gray-200 rounded-lg p-4 bg-white" id="task-${ticket.id}">
                        <div class="flex justify-between items-start mb-3">
                            <div class="flex-1">
                                <h4 class="text-lg font-semibold text-gray-800">Task #${ticket.id}: ${ticket.description}</h4>
                                <div class="text-sm text-gray-600 mt-1">
                                    <span class="inline-block mr-4">📅 Started: ${ticket.startDate}</span>
                                    <span class="inline-block mr-4">📊 Size: ${ticket.size} (${taskSizeDefinitions[ticket.size]?.days || 0} days)</span>
                                    <span class="inline-block mr-4">👥 Assigned: ${ticket.assigned.join(', ')}</span>
                                </div>
                                <div class="text-sm mt-1">
                                    <span class="text-red-600 font-medium">
                                        🚨 Overdue by ${daysOverdue} day${daysOverdue !== 1 ? 's' : ''} 
                                        (expected completion: ${endDate ? endDate.toLocaleDateString() : 'Unknown'})
                                    </span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-3">
                            <!-- Mark Done -->
                            <div class="bg-green-50 border border-green-200 rounded p-3">
                                <h5 class="font-medium text-green-800 mb-2">✅ Mark as Done</h5>
                                <button onclick="markTaskDone(${ticket.id})" 
                                        class="w-full px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 transition-colors">
                                    Complete Task
                                </button>
                            </div>
                            
                            <!-- Pause with Comment -->
                            <div class="bg-yellow-50 border border-yellow-200 rounded p-3">
                                <h5 class="font-medium text-yellow-800 mb-2">⏸️ Pause Task</h5>
                                <textarea id="pause-comment-${ticket.id}" placeholder="Reason for pausing..." 
                                          class="w-full p-2 border border-yellow-300 rounded text-sm mb-2 h-16 resize-none"></textarea>
                                <button onclick="pauseTaskWithComment(${ticket.id})" 
                                        class="w-full px-3 py-2 bg-yellow-600 text-white rounded hover:bg-yellow-700 transition-colors">
                                    Pause Task
                                </button>
                            </div>
                            
                            <!-- Extend End Date -->
                            <div class="bg-blue-50 border border-blue-200 rounded p-3">
                                <h5 class="font-medium text-blue-800 mb-2">📅 Extend Deadline</h5>
                                <input type="date" id="new-end-date-${ticket.id}" 
                                       class="w-full p-2 border border-blue-300 rounded text-sm mb-2"
                                       min="${getLocalDateString(new Date())}"
                                       onchange="validateNewEndDate(${ticket.id})">
                                <div id="size-info-${ticket.id}" class="text-xs text-blue-600 mb-2 min-h-[2rem]">
                                    Select a new end date to see size impact
                                </div>
                                <button onclick="extendTaskDeadline(${ticket.id})" 
                                        id="extend-btn-${ticket.id}"
                                        class="w-full px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors disabled:bg-gray-400"
                                        disabled>
                                    Extend Deadline
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                </div>
                <div class="mt-6 pt-4 border-t border-gray-200 text-center">
                    <button onclick="closeBulkTaskResolution()" 
                            class="px-6 py-2 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
                        Close
                    </button>
                </div>
            `;
            
            document.getElementById('bulkTaskResolutionContent').innerHTML = html;
        }

        function markTaskDone(ticketId) {
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            const oldStatus = ticket.status;
            ticket.status = 'Done';
            
            console.log(`✅ Marked task #${ticketId} as Done (was: ${oldStatus})`);
            
            // Remove the task from the modal display
            const taskElement = document.getElementById(`task-${ticketId}`);
            if (taskElement) {
                taskElement.style.opacity = '0.5';
                taskElement.innerHTML = `
                    <div class="text-center py-4">
                        <div class="text-green-600 font-semibold">✅ Task marked as Done!</div>
                        <div class="text-sm text-gray-600 mt-1">Status updated successfully</div>
                    </div>
                `;
            }
            
            saveToLocalStorage();
            
            // Clear any active status filters so user can see resolved tasks
            selectedStatusFilters = [];
            
            // Refresh the main task list with proper projection
            const doneProjectedTickets = getProjectedTickets();
            renderTickets(doneProjectedTickets);
            
            // Check if all tasks are resolved
            setTimeout(() => checkAllTasksResolved(), 1000);
        }

        function pauseTaskWithComment(ticketId) {
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            const comment = document.getElementById(`pause-comment-${ticketId}`).value.trim();
            if (!comment) {
                alert('Please provide a reason for pausing this task.');
                return;
            }
            
            const oldStatus = ticket.status;
            ticket.status = 'Paused';
            
            // Add pause comment to ticket
            if (!ticket.pauseComments) {
                ticket.pauseComments = [];
            }
            ticket.pauseComments.push({
                comment: comment,
                timestamp: new Date().toISOString(),
                action: 'Paused from bulk resolution'
            });
            
            console.log(`⏸️ Paused task #${ticketId} (was: ${oldStatus}): ${comment}`);
            
            // Remove the task from the modal display
            const taskElement = document.getElementById(`task-${ticketId}`);
            if (taskElement) {
                taskElement.style.opacity = '0.5';
                taskElement.innerHTML = `
                    <div class="text-center py-4">
                        <div class="text-yellow-600 font-semibold">⏸️ Task paused!</div>
                        <div class="text-sm text-gray-600 mt-1">Reason: ${comment}</div>
                    </div>
                `;
            }
            
            saveToLocalStorage();
            
            // Clear any active status filters so user can see resolved tasks
            selectedStatusFilters = [];
            
            // Refresh the main task list with proper projection
            const pausedProjectedTickets = getProjectedTickets();
            renderTickets(pausedProjectedTickets);
            
            // Check if all tasks are resolved
            setTimeout(() => checkAllTasksResolved(), 1000);
        }

        function validateNewEndDate(ticketId) {
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            const newEndDateInput = document.getElementById(`new-end-date-${ticketId}`);
            const sizeInfoDiv = document.getElementById(`size-info-${ticketId}`);
            const extendBtn = document.getElementById(`extend-btn-${ticketId}`);
            
            const newEndDate = newEndDateInput.value;
            if (!newEndDate) {
                sizeInfoDiv.innerHTML = 'Select a new end date to see size impact';
                extendBtn.disabled = true;
                return;
            }
            
            const startDate = new Date(ticket.startDate);
            const endDate = new Date(newEndDate);
            const daysDiff = calculateBusinessDays(startDate, endDate);
            
            // Find the appropriate size for the new duration
            const newSize = calculateSizeFromDays(daysDiff);
            const maxSize = getMaximumSize();
            const maxDays = taskSizeDefinitions[maxSize]?.days || 0;
            
            if (daysDiff > maxDays) {
                // Calculate the maximum allowed end date
                const startDate = new Date(ticket.startDate);
                const maxAllowedEndDate = addBusinessDays(startDate, maxDays - 1); // -1 because start date counts as day 1
                const maxAllowedDateStr = maxAllowedEndDate.toLocaleDateString('en-GB'); // dd/mm/yyyy format
                
                sizeInfoDiv.innerHTML = `
                    <span class="text-red-600">
                        ❌ Duration too long: ${daysDiff} business days exceeds maximum (${maxDays} days for ${maxSize}). Latest allowed is ${maxAllowedDateStr}
                    </span>
                `;
                extendBtn.disabled = true;
            } else {
                const currentSize = ticket.size;
                const currentDays = taskSizeDefinitions[currentSize]?.days || 0;
                
                sizeInfoDiv.innerHTML = `
                    <div class="text-blue-700">
                        📊 New duration: ${daysDiff} business days<br>
                        📏 Size change: ${currentSize} (${currentDays}d) → ${newSize} (${taskSizeDefinitions[newSize]?.days || 0}d)
                    </div>
                `;
                extendBtn.disabled = false;
            }
        }

        function calculateSizeFromDays(days) {
            // Find the smallest size that can accommodate the required days
            const sizes = Object.keys(taskSizeDefinitions).sort((a, b) => 
                taskSizeDefinitions[a].days - taskSizeDefinitions[b].days
            );
            
            for (const size of sizes) {
                if (taskSizeDefinitions[size].days >= days) {
                    return size;
                }
            }
            
            // If no size fits, return the largest
            return sizes[sizes.length - 1];
        }

        function getMaximumSize() {
            // Find the size with the most days
            let maxSize = 'S';
            let maxDays = 0;
            
            for (const [size, config] of Object.entries(taskSizeDefinitions)) {
                if (config.days > maxDays) {
                    maxDays = config.days;
                    maxSize = size;
                }
            }
            
            return maxSize;
        }

        function extendTaskDeadline(ticketId) {
            const ticket = tickets.find(t => t.id === ticketId);
            if (!ticket) return;
            
            const newEndDateInput = document.getElementById(`new-end-date-${ticketId}`);
            const newEndDate = newEndDateInput.value;
            
            if (!newEndDate) {
                alert('Please select a new end date.');
                return;
            }
            
            const startDate = new Date(ticket.startDate);
            const endDate = new Date(newEndDate);
            const daysDiff = calculateBusinessDays(startDate, endDate);
            
            const oldSize = ticket.size;
            const newSize = calculateSizeFromDays(daysDiff);
            
            // Track the size change
            trackSizeChange(ticket, oldSize, newSize, 'Deadline extension via bulk resolution');
            
            // Track the end date change (calculate current projected end date)
            const projectedTickets = getProjectedTickets();
            const projectedTicket = projectedTickets.find(pt => pt.id === ticketId);
            const oldEndDate = projectedTicket ? projectedTicket.rawEndDate : null;
            
            if (oldEndDate) {
                trackEndDateChange(ticket, oldEndDate, newEndDate, 'Deadline extension via bulk resolution');
            }
            
            // Update the ticket with new size and custom end date
            ticket.size = newSize;
            ticket.customEndDate = newEndDate; // Store the custom end date to override calculations
            
            console.log(` Extended deadline for task #${ticketId}: ${oldSize} → ${newSize} (${daysDiff} business days)`);
            
            // Remove the task from the modal display
            const taskElement = document.getElementById(`task-${ticketId}`);
            if (taskElement) {
                taskElement.style.opacity = '0.5';
                taskElement.innerHTML = `
                    <div class="text-center py-4">
                        <div class="text-blue-600 font-semibold">📅 Deadline extended!</div>
                        <div class="text-sm text-gray-600 mt-1">
                            Size updated: ${oldSize} → ${newSize}<br>
                            New target: ${new Date(newEndDate).toLocaleDateString()}
                        </div>
                    </div>
                `;
            }
            
            saveToLocalStorage();
            
            // Refresh the main task list with proper projection
            const extendedProjectedTickets = getProjectedTickets();
            renderTickets(extendedProjectedTickets);
            
            // Check if all tasks are resolved
            setTimeout(() => checkAllTasksResolved(), 1000);
        }

        function checkAllTasksResolved() {
            const remainingTasks = getOverdueInProgressTasks();
            if (remainingTasks.length === 0) {
                // All tasks resolved, show success message and close modal
                document.getElementById('bulkTaskResolutionContent').innerHTML = `
                    <div class="text-center py-8">
                        <div class="text-6xl mb-4">🎉</div>
                        <h3 class="text-2xl font-bold text-green-600 mb-2">All Tasks Resolved!</h3>
                        <p class="text-gray-600 mb-4">Great job! All overdue tasks have been addressed.</p>
                        <button onclick="closeBulkTaskResolution()" 
                                class="px-6 py-3 bg-green-600 text-white rounded hover:bg-green-700 transition-colors">
                            Close
                        </button>
                    </div>
                `;
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('delayAnalysisModal');
            if (event.target === modal) {
                closeDelayAnalysis();
            }
        });

        // Close bulk task resolution modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('bulkTaskResolutionModal');
            if (event.target === modal) {
                closeBulkTaskResolution();
            }
        });

        // --- COMPLETION GRAPH FUNCTIONALITY ---
        function generateCompletionGraph() {
            console.log('📈 Generating completion projection graph...');
            
            const projectedTickets = getProjectedTickets();
            console.log('🔍 Projected tickets:', projectedTickets);
            
            if (projectedTickets.length === 0) {
                alert('No tasks found to generate completion graph. Please add some tasks first.');
                return;
            }

            // Sort tasks by completion date - use rawEndDate instead of taskEndDate
            const sortedTasks = projectedTickets
                .filter(task => task.rawEndDate && task.rawEndDate !== 'N/A') // Only include tasks with valid end dates
                .sort((a, b) => new Date(a.rawEndDate) - new Date(b.rawEndDate));

            console.log('🔍 Filtered and sorted tasks:', sortedTasks);

            if (sortedTasks.length === 0) {
                alert('No scheduled tasks found. Please ensure tasks have valid start dates and team assignments.');
                return;
            }

            // Create cumulative completion data
            const graphData = [];
            let cumulativeCount = 0;
            
            sortedTasks.forEach((task, index) => {
                cumulativeCount++;
                graphData.push({
                    taskNumber: cumulativeCount,
                    completionDate: formatDate(getLocalDateString(task.rawEndDate)),
                    task: task,
                    dateString: getLocalDateString(task.rawEndDate)
                });
            });

            console.log('📊 Graph data prepared:', graphData);
            
            // Show modal and render chart
            document.getElementById('completionGraphModal').classList.remove('hidden');
            renderCompletionChart(graphData);
        }

        function renderCompletionChart(data) {
            const container = document.getElementById('completionGraphContent');
            
            // Generate all unique dates for proper x-axis
            const allDates = [...new Set(data.map(item => item.dateString))].sort();
            const dateLabels = allDates.map(dateStr => formatDate(dateStr));
            
            // Create cumulative data points for each date
            const chartPoints = [];
            let cumulativeCount = 0;
            
            allDates.forEach(dateStr => {
                const tasksCompletingOnThisDate = data.filter(item => item.dateString === dateStr).length;
                cumulativeCount += tasksCompletingOnThisDate;
                chartPoints.push({
                    date: dateStr,
                    dateLabel: formatDate(dateStr),
                    cumulativeCount: cumulativeCount,
                    tasksThisDate: tasksCompletingOnThisDate
                });
            });
            
            // Create a simple HTML-based chart
            let chartHTML = `
                <div class="w-full h-full bg-gray-50 border rounded-lg p-4">
                    <div class="mb-4">
                        <h3 class="text-lg font-semibold text-gray-800 mb-2">Task Completion Timeline</h3>
                        <div class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded text-sm text-blue-800">
                            <p><strong>📊 Chart Explanation:</strong> This graph shows the projected completion dates for all tasks based on current scheduling and team capacity. The line shows cumulative tasks completed over time, with each point representing when tasks are scheduled to finish.</p>
                        </div>
                        <p class="text-sm text-gray-600">Showing projected completion dates for ${data.length} scheduled tasks across ${allDates.length} completion dates</p>
                    </div>
                    
                    <div class="relative h-64 mb-6 bg-white border rounded">
                        <!-- Y-axis labels (Task Count) -->
                        <div class="absolute left-0 top-0 bottom-0 w-12 flex flex-col justify-between text-xs text-gray-500 py-4">
                            <span>${data.length}</span>
                            <span>${Math.floor(data.length * 0.75)}</span>
                            <span>${Math.floor(data.length * 0.5)}</span>
                            <span>${Math.floor(data.length * 0.25)}</span>
                            <span>0</span>
                        </div>
                        
                        <!-- Chart area -->
                        <div class="ml-12 h-full relative">
                            <svg class="w-full h-full" viewBox="0 0 800 200">
                                <!-- Grid lines -->
                                ${generateGridLines(data.length)}
                                
                                <!-- Data points and line -->
                                ${generateRealisticChartPath(chartPoints, 800, 200, data.length)}
                                
                                <!-- Data points -->
                                ${generateRealisticDataPoints(chartPoints, 800, 200, data.length)}
                            </svg>
                        </div>
                        
                        <!-- X-axis labels (Dates) -->
                        <div class="ml-12 mt-2 flex justify-between text-xs text-gray-500">
                            ${generateDateLabels(chartPoints)}
                        </div>
                    </div>
                    
                    <!-- Task list -->
                    <div class="max-h-48 overflow-y-auto">
                        <h4 class="font-semibold mb-2 text-gray-800">Task Details:</h4>
                        <div class="space-y-1">
                            ${data.map(item => `
                                <div class="flex justify-between items-center p-2 bg-gray-50 rounded text-sm">
                                    <span class="font-medium text-blue-600">Task #${item.taskNumber}</span>
                                    <span class="text-gray-600">${item.task.description}</span>
                                    <span class="text-gray-800 font-medium">${item.completionDate}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            
            container.innerHTML = chartHTML;
        }

        function generateGridLines(maxTasks) {
            let lines = '';
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * 200;
                lines += `<line x1="0" y1="${y}" x2="800" y2="${y}" stroke="#e5e7eb" stroke-width="1"/>`;
            }
            return lines;
        }

        function generateChartPath(data, width, height) {
            if (data.length < 2) return '';
            
            let path = '';
            data.forEach((point, index) => {
                const x = (index / (data.length - 1)) * width;
                const y = height - (point.taskNumber / data.length) * height;
                
                if (index === 0) {
                    path += `M ${x} ${y}`;
                } else {
                    path += ` L ${x} ${y}`;
                }
            });
            
            return `<path d="${path}" stroke="#3b82f6" stroke-width="2" fill="none"/>`;
        }

        function generateRealisticChartPath(chartPoints, width, height, maxTasks) {
            if (chartPoints.length < 2) return '';
            
            let path = '';
            chartPoints.forEach((point, index) => {
                const x = (index / (chartPoints.length - 1)) * width;
                const y = height - (point.cumulativeCount / maxTasks) * height;
                
                if (index === 0) {
                    path += `M ${x} ${y}`;
                } else {
                    path += ` L ${x} ${y}`;
                }
            });
            
            return `<path d="${path}" stroke="#3b82f6" stroke-width="2" fill="none"/>`;
        }

        function generateDataPoints(data, width, height) {
            return data.map((point, index) => {
                const x = (index / (data.length - 1)) * width;
                const y = height - (point.taskNumber / data.length) * height;
                
                return `<circle cx="${x}" cy="${y}" r="4" fill="#3b82f6" stroke="white" stroke-width="2">
                    <title>Task ${point.taskNumber}: ${point.task.description} - ${point.completionDate}</title>
                </circle>`;
            }).join('');
        }

        function generateRealisticDataPoints(chartPoints, width, height, maxTasks) {
            return chartPoints.map((point, index) => {
                const x = (index / (chartPoints.length - 1)) * width;
                const y = height - (point.cumulativeCount / maxTasks) * height;
                
                return `<circle cx="${x}" cy="${y}" r="4" fill="#3b82f6" stroke="white" stroke-width="2">
                    <title>${point.cumulativeCount} tasks completed by ${point.dateLabel} (${point.tasksThisDate} task${point.tasksThisDate > 1 ? 's' : ''} completing this date)</title>
                </circle>`;
            }).join('');
        }

        function generateDateLabels(chartPoints) {
            if (chartPoints.length <= 3) {
                return chartPoints.map(point => `<span>${point.dateLabel}</span>`).join('');
            }
            
            // Show first, middle, and last dates
            const first = chartPoints[0];
            const middle = chartPoints[Math.floor(chartPoints.length / 2)];
            const last = chartPoints[chartPoints.length - 1];
            
            return `
                <span>${first.dateLabel}</span>
                <span>${middle.dateLabel}</span>
                <span>${last.dateLabel}</span>
            `;
        }

        function closeCompletionGraph() {
            document.getElementById('completionGraphModal').classList.add('hidden');
        }

        // Close modal when clicking outside
        document.addEventListener('click', function(event) {
            const modal = document.getElementById('completionGraphModal');
            if (event.target === modal) {
                closeCompletionGraph();
            }
        });

        // Start the application
        window.onload = initializeScheduler;
    </script>
</body>
</html>
